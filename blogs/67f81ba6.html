<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>.NET面试题-C#基础知识 | 木漏れ日</title><meta name="keywords" content=".Net,C#,.NET面试题,C#基础知识"><meta name="author" content="itaru"><meta name="copyright" content="itaru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文多数问题基于：.NET 面试题 - C#基础 如何理解装箱和拆箱？ 装箱：将值类型转换成引用类型。   拆箱：将引用类型转换成值类型。  详情：C#装箱和拆箱（Boxing 和 UnBoxing） C# 中什么是值类型与引用类型？ 值类型：在线程栈分配空间。 引用类型：在托管堆分配空间，并在线程栈中留有引用。  详情：C# 值类型和引用类型 值传递与引用传递默认情况下所有对象都通过值传递而不是"><meta property="og:type" content="article"><meta property="og:title" content=".NET面试题-C#基础知识"><meta property="og:url" content="https://www.itaru.xyz/blogs/67f81ba6.html"><meta property="og:site_name" content="木漏れ日"><meta property="og:description" content="本文多数问题基于：.NET 面试题 - C#基础 如何理解装箱和拆箱？ 装箱：将值类型转换成引用类型。   拆箱：将引用类型转换成值类型。  详情：C#装箱和拆箱（Boxing 和 UnBoxing） C# 中什么是值类型与引用类型？ 值类型：在线程栈分配空间。 引用类型：在托管堆分配空间，并在线程栈中留有引用。  详情：C# 值类型和引用类型 值传递与引用传递默认情况下所有对象都通过值传递而不是"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/水果篮子.jpg"><meta property="article:published_time" content="2021-12-09T03:18:53.000Z"><meta property="article:modified_time" content="2021-12-15T13:43:53.671Z"><meta property="article:author" content="itaru"><meta property="article:tag" content="C#"><meta property="article:tag" content=".NET面试题"><meta property="article:tag" content="合集"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/水果篮子.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/favicon.png"><link rel="canonical" href="https://www.itaru.xyz/blogs/67f81ba6"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Kiwi+Maru&amp;family=Zen+Old+Mincho&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"簡"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:!1},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{jQuery:"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js",justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js",css:"https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css"},fancybox:{js:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js",css:"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isanchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:".NET面试题-C#基础知识",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-12-15 21:43:53"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));const n=saveToLocal.get("global-font-size");void 0!==n&&document.documentElement.style.setProperty("--global-font-size",n+"px");GLOBAL_CONFIG_SITE.isHome&&/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/css/icon.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/l-lin/font-awesome-animation/dist/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css" media="defer" onload='this.media="all"'><script async src="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/carousel-touch.min.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="木漏れ日" type="application/atom+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/limuru.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i> <span>留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/水果篮子.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">木漏れ日</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i> <span>留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">.NET面试题-C#基础知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-12-09T03:18:53.000Z" title="undefined 2021-12-09 11:18:53">2021-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E5%90%88%E9%9B%86/">合集</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文多数问题基于：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/355257871">.NET 面试题 - C#基础</a></p><h3 id="如何理解装箱和拆箱？"><a href="#如何理解装箱和拆箱？" class="headerlink" title="如何理解装箱和拆箱？"></a>如何理解装箱和拆箱？</h3><ul><li>装箱：将值类型转换成引用类型。</li><li>拆箱：将引用类型转换成值类型。</li></ul><p>详情：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/qiaoquan3/article/details/51439726">C#装箱和拆箱（Boxing 和 UnBoxing）</a></p><h3 id="C-中什么是值类型与引用类型？"><a href="#C-中什么是值类型与引用类型？" class="headerlink" title="C# 中什么是值类型与引用类型？"></a>C# 中什么是值类型与引用类型？</h3><ul><li>值类型：在线程栈分配空间。</li><li>引用类型：在托管堆分配空间，并在线程栈中留有引用。</li></ul><p>详情：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/yinrq/p/5588330.html">C# 值类型和引用类型</a></p><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><p>默认情况下所有对象都通过值传递而不是引用传递，不管是值类型还是引用类型。</p><ul><li>值传递：传递的是变量在线程栈（Thread Stack 又称线程堆栈）中的值的<code>副本</code>（即拷贝一份传入）。值类型则传递值，引用类型则传递引用。</li><li>引用传递：ref 关键字让形参（parameter）成为实参（argument）的别名（注意别名和拷贝副本的区别）。</li></ul><p>注意：</p><p>不要混淆通过引用传递与引用类型的概念。这两种概念是不同的。无论方法参数是值类型还是引用类型，均可由 ref 修改。当通过引用传递时，不会对值类型装箱。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/UploadFile/f1047f/story-of-pass-by-value-and-pass-by-reference-in-C-Sharp/">Story Of Pass By Value And Pass By Reference In C# - C#Corner</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference">ref（C# 参考）- microsoft</a></p><h3 id="关键字：ref-out-（以及-in）"><a href="#关键字：ref-out-（以及-in）" class="headerlink" title="关键字：ref out （以及 in）"></a>关键字：ref out （以及 in）</h3><h4 id="ref-与-out"><a href="#ref-与-out" class="headerlink" title="ref 与 out"></a>ref 与 out</h4><table><thead><tr><th>ref</th><th>out</th></tr></thead><tbody><tr><td>参数在传递给 ref 之前必须先初始化。</td><td>参数传递给 out 之前，不需要对其进行初始化。</td></tr><tr><td>在返回<code>被调用方法</code>之前，不需要分配或初始化参数的值。</td><td>需要在返回被调用方法之前分配或初始化参数的值。</td></tr><tr><td><code>当被调用的方法还需要修改传递参数时，可选择 ref 。</code></td><td><code>当需要从函数或方法返回多个值时，可选择 out 。</code></td></tr><tr><td>在被调用方法中使用参数值之前，不必对其进行初始化。</td><td>参数值在使用前必须在被调用方法中初始化。</td></tr><tr><td>当我们使用 ref 时，数据可以双向传递。</td><td>当我们使用 out 时，数据仅以单向方式传递（从被调用的方法到调用者的方法）<tr><td colspan="2">ref 和 out 在运行时的处理方式不同，在编译时的处理方式相同。<tr><td colspan="2">属性不是变量，因此不能作为 ref 或 out 参数传递。</td></tr></td></tr></td></tr></tbody></table><h4 id="ref-out-和-方法重载"><a href="#ref-out-和-方法重载" class="headerlink" title="ref/out 和 方法重载"></a>ref/out 和 方法重载</h4><p>ref 和 out 在运行时的处理方式不同，在编译时的处理方式相同，因此如果一个方法将参数作为 ref 而另一个方法将参数作为 out，则方法不能重载。</p><p>但是，当一个方法采用 ref 或 out 参数而另一个采用相同的参数而没有 ref 或 out 时，方法重载是可能的。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/UploadFile/ff2f08/ref-vs-out-keywords-in-C-Sharp/">ref vs out in C# - C#Corner</a></p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p>in 关键字会导致按引用传递参数，但确保不会修改参数。它让形参成为实参的别名，这必须是变量。换而言之，对形参执行的任何操作都是对实参执行的。它类似于 ref 或 out 关键字，不同之处在于 in 参数<code>无法通过调用的方法进行修改</code>。而ref 参数是可以修改的，out 参数则必须由调用的方法进行修改，这些修改在调用上下文中是可观察的。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier">in parameter modifier (C# Reference) - microsoft</a></p><h3 id="请详述在-C-中类-class-与结构-struct-的异同。"><a href="#请详述在-C-中类-class-与结构-struct-的异同。" class="headerlink" title="请详述在 C# 中类(class)与结构(struct)的异同。"></a>请详述在 C# 中类(class)与结构(struct)的异同。</h3><p>共同点：</p><ul><li>都可以用来封装字段、属性、方法、构造器等。</li><li>都可以实现接口。</li></ul><p>区别：</p><ul><li>class：可以作为基类和继承其他类。引用类型，存储在托管堆中。</li><li>struct：不能通过new创建实例。值类型，存储在线程栈中。是不可变（immutable)类型。</li></ul><h3 id="C-中-托管堆-和-线程堆栈-的区别？"><a href="#C-中-托管堆-和-线程堆栈-的区别？" class="headerlink" title="C#中 托管堆 和 线程堆栈 的区别？"></a>C#中 托管堆 和 线程堆栈 的区别？</h3><ul><li>托管堆（Managed Heap）：动态分配内存，可改变大小；区域无序内存，可以任何顺序存储和删除；访问速度慢；存放引用类型，通过GC（Garbage Collector）监视清理内存。</li><li>线程堆栈（Thread Stack）：静态分配内存，不能改变大小；数组有序内存，后进先出；访问速度快；存放值类型数据，离开作用域自动释放内存。</li></ul><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/article/stack-vs-heap-memory-c-sharp/">Stack Vs Heap Memory - C#</a></p><h3 id="托管代码-和-非托管代码"><a href="#托管代码-和-非托管代码" class="headerlink" title="托管代码 和 非托管代码"></a>托管代码 和 非托管代码</h3><h4 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h4><p>托管代码就是执行过程交由运行时管理的代码。</p><p>不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+），在这里，相关的运行时是公共语言运行时 (CLR)。CLR 负责获取托管代码、将其编译成机器代码，然后执行它。除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。</p><h4 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h4><p>将托管代码与运行 C/C++ 程序（也称为“非托管代码”）的方式作对比。在非托管环境中，程序员需要亲自负责处理相当多的事情。程序本质上是一个二进制文件，操作系统 (OS) 将其加载到内存中并启动。其他任何工作，从内存管理到安全因素都由程序员负担。（我的理解是，你的程序（代码）不由运行时管理，而是直接由操作系统加载并启动。而操作系统只负责运行你的程序，其他的一概都得你自己负责。）</p><p>以上只是对非托管代码的通俗解释，对于 .NET 来说，非托管代码就是 执行过程不由 CLR 管理的代码。比如调用了不属于 .NET 共享代码库中的某个 DLL，而这里面的代码就是非托管代码。</p><h3 id="托管资源-和-非托管资源"><a href="#托管资源-和-非托管资源" class="headerlink" title="托管资源 和 非托管资源"></a>托管资源 和 非托管资源</h3><ul><li>托管资源是那些纯 .NET 代码并由运行时管理并受其直接控制的资源。</li><li>其他则是非托管资源。包括文件句柄、固定存储、COM 对象、数据库连接等。</li></ul><p>详情：<a href="/blogs/15902c4f.html" title="C# 中的托管与非托管（堆、资源、类型、代码）">C# 中的托管与非托管（堆、资源、类型、代码）</a></p><h3 id="GC（Garbage-Collection）"><a href="#GC（Garbage-Collection）" class="headerlink" title="GC（Garbage Collection）"></a>GC（Garbage Collection）</h3><p>垃圾回收器。当程序需要更多的堆空间时，由 GC 进行垃圾清理工作，暂停所有线程，找出托管堆中没有被引用的对象，进行清理，并通知栈中的指针重新指向<code>地址排序后的对象</code>。</p><p>GC 只对<code>托管资源</code>进行回收。对于<code>非托管资源</code>则不能使用 GC 进行回收，必须由程序员手动回收。</p><p>例如 FileStream 或 SqlConnection 需要调用 Dispose 进行资源的回收。</p><p>精简：</p><p>GC：垃圾回收器，用于自动回收托管堆中无效对象的内存，释放内存空间。</p><h3 id="CLR（Common-Language-Runtime）"><a href="#CLR（Common-Language-Runtime）" class="headerlink" title="CLR（Common Language Runtime）"></a>CLR（Common Language Runtime）</h3><p>Microsoft .NET Framework的虚拟机组件，管理.NET程序的执行。即时编译将托管代码（编译后的中间语言代码）转换为机器指令，然后在计算机的CPU上执行。CLR提供额外的服务，包括内存管理、类型安全、异常处理、垃圾收集、安全和线程管理。为.NET Framework编写的所有程序，无论使用何种编程语言，都由CLR执行。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime - wiki</a></p><h3 id="简述6中可访问性级别"><a href="#简述6中可访问性级别" class="headerlink" title="简述6中可访问性级别"></a>简述6中可访问性级别</h3><ol><li>public 公有访问，不受任何限制。</li><li>private 私有访问，仅限当前类。</li><li>protected 保护访问，当前类及其子类。</li><li>internal 内部访问，当前程序集。</li><li>protected internal 当前程序集 及 其他程序集中<code>当前类</code>的子类。</li><li>private protected 子类且得是在当前程序集中。</li></ol><p>详情：<a href="/blogs/9f8c60c3.html" title="C#中的protected internal 和 private protected可访问级别">C#中的protected internal 和 private protected可访问级别</a></p><h3 id="virtual-vs-abstract"><a href="#virtual-vs-abstract" class="headerlink" title="virtual vs abstract"></a>virtual vs abstract</h3><p>共同点：</p><ul><li>都是为了实现多态。</li><li>子类重写的时候都得加override描述。</li></ul><p>区别：</p><ul><li>virtual意思是虚拟，abstract意思是抽象。</li><li>virtual只修饰方法，abstract修饰方法和类。</li><li>virtual方法必须有实现，abstract方法不能有实现。</li><li>virtual方法可以在普通类里，也可以在抽象类里，而abstract方法必须在抽象类中。（abstract class，抽象类只能被继承，不能实例化）</li><li>virtual方法可以被重写，abstract方法必须被重写。</li></ul><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/woostundy/p/3424213.html">C#中virtual和abstract的区别</a></p><h3 id="C-中abstract-class和interface有什么区别"><a href="#C-中abstract-class和interface有什么区别" class="headerlink" title="C#中abstract class和interface有什么区别?"></a>C#中abstract class和interface有什么区别?</h3><p>共同点：</p><ul><li>都不能被实例化</li></ul><p>区别：</p><ul><li>abstract class可以拥有字段；interface不能。</li><li>abstract class可以对成员进行实现；interface不能。</li><li>abstract class成员可以拥有访问修饰符，成员默认私有，可以更改；interface不能拥有访问修饰符，成员默认公有，且不能修改。</li><li>abstract class可以继承类和接口；interface只能继承接口。</li><li>一个类只能继承一个抽象类，但可以继承多个接口。</li></ul><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/article/abstract-class-vs-interface-c-sharp/">Abstract Class Vs Interface - C#</a></p><h3 id="new关键字的几种用法"><a href="#new关键字的几种用法" class="headerlink" title="new关键字的几种用法"></a>new关键字的几种用法</h3><ul><li>运算符：创建对象和调用构造函数。</li><li>修饰符：隐藏从基类继承的成员。</li><li>约束：它指定泛型类型必须具有公共无参数构造函数。</li></ul><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/UploadFile/g_arora/discussing-new-keyword-of-C-Sharp/">“new” Keyword of C#</a></p><h3 id="using关键字的几种用法"><a href="#using关键字的几种用法" class="headerlink" title="using关键字的几种用法"></a>using关键字的几种用法</h3><ul><li>作为指令：用于导入其他命名空间中定义的类型或为命名空间创建别名。（引用命名空间）</li><li>作为语句：用于定义一个范围，在此范围的末尾将释放对象。（定义一个代码块）</li></ul><h3 id="重载-overload-与重写-override-的区别"><a href="#重载-overload-与重写-override-的区别" class="headerlink" title="重载(overload)与重写(override)的区别"></a>重载(overload)与重写(override)的区别</h3><table><thead><tr><th>方法重载</th><th>方法重写</th></tr></thead><tbody><tr><td>在同一个类中创建多个具有相同名称但不同签名或参数的方法称为方法重载。</td><td>在派生类中创建与基类中的方法具有相同签名的方法称为方法覆盖</td></tr><tr><td>它被称为编译时多态性</td><td>它被称为运行时多态性</td></tr><tr><td>它具有相同的方法名称，但具有不同的签名或参数</td><td>它必须具有相同的方法名称以及签名或参数。</td></tr><tr><td>方法重载不需要继承</td><td>方法覆盖需要继承</td></tr><tr><td>可以是任何访问修饰符</td><td>只能是public</td></tr></tbody></table><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/blogs/difference-between-method-overloading-and-method-overriding">Difference Between Method Overloading And Method Overriding</a></p><h3 id="new-与-override"><a href="#new-与-override" class="headerlink" title="new 与 override"></a>new 与 override</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>在用作声明修饰符时，new 关键字可以显式隐藏从基类继承的成员。隐藏继承的成员时，该成员的派生版本将替换基类版本。（不改变执行逻辑，只是编译时不警告）</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/new-modifier">new 修饰符（C# 参考）- microsoft</a></p><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>扩展或修改继承的方法、属性、索引器或事件的抽象或虚拟实现需要 override 修饰符。</p><p>override 方法提供从基类继承的方法的新实现。不能重写非虚方法或静态方法。重写基方法必须是 virtual、abstract 或 override 修饰的。override 方法和 virtual 方法必须具有相同级别访问修饰符。</p><p>参考；<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/override">override（C# 参考）- microsoft</a></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseClass bcdc = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">bcdc.Method();</span><br></pre></td></tr></table></figure><p>默认情况（未加修饰符）：执行BaseClass中的Method。<br>new：执行BaseClass中的Method。<br>override：执行DerivedClass中的Method。</p><p>另外：new 可以用来修饰字段，Override 不能。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords">了解何时使用 Override 和 New 关键字（C# 编程指南）- microsoft</a></p><h3 id="字段（Field）和属性（Property）的关系"><a href="#字段（Field）和属性（Property）的关系" class="headerlink" title="字段（Field）和属性（Property）的关系"></a>字段（Field）和属性（Property）的关系</h3><p>字段是一个类的普通成员变量或成员实例。</p><p>属性也称为访问器，它是获取和设置字段的值的抽象。</p><p>属性是基于字段的，如果没有声明字段，编译器会自动声明字段，这属于隐式声明字段。</p><p>通常，应该将成员变量声明为私有，然后为它们声明或定义属性。</p><h3 id="属性与方法的关系"><a href="#属性与方法的关系" class="headerlink" title="属性与方法的关系"></a>属性与方法的关系</h3><p>属性是被称为<code>访问器</code>的一种特殊方法。</p><p>一般来说，方法代表行为，属性代表数据。属性旨在像字段一样使用，这意味着属性不应在计算上复杂或产生副作用。</p><p>如果不违反以下准则，请考虑使用属性而不是方法，因为经验不足的开发人员会发现属性更易于使用。</p><p>详情：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms229054(v=vs.100)?redirectedfrom=MSDN">Choosing Between Properties and Methods</a></p><h3 id="类（Class）和实例（Instance）"><a href="#类（Class）和实例（Instance）" class="headerlink" title="类（Class）和实例（Instance）"></a>类（Class）和实例（Instance）</h3><p>类是<code>抽象的模板</code>，实例是根据类创建出来的一个个<code>具体的对象</code>，每个对象都拥有相同的方法，但各自的数据可能不同。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/ym01213/article/details/86698455">python 类（Class）和实例（Instance）</a></p><h3 id="const-vs-readonly"><a href="#const-vs-readonly" class="headerlink" title="const vs readonly"></a>const vs readonly</h3><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const 关键字用来声明某个常量字段或常量局部变量。常量字段和常量局部变量不是变量并且不能修改。常量可以为数字、布尔值、字符串或 null 引用。</p><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>在字段声明中，readonly 指示只能在声明期间或在同一个类的构造函数中向字段赋值。可以在字段声明和构造函数中多次分配和重新分配只读字段。</p><p>构造函数退出后，不能分配 readonly 字段。<code>此规则对于值类型和引用类型具有不同的含义：</code></p><p>由于值类型直接包含数据，因此属于 readonly 值类型的字段不可变。<br>由于引用类型包含对其数据的引用，因此属于 readonly 引用类型的字段必须始终引用同一对象。该对象是可变的。 readonly 修饰符可防止字段替换为其他实例，但不会阻止修改该字段中的数据。</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>readonly 关键字不同于 const 关键字。 const 字段只能在该字段的声明中初始化。readonly 字段可以在字段声明和任何构造函数中多次分配。因此，根据所使用的构造函数，readonly 字段可能具有不同的值。另外，const 字段是编译时常量，而 readonly 字段可用作运行时常量。const 常量既可以声明在类中也可以在函数体内，但是 readonly 常量只能声明在类中。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static">static (C# Reference) - microsoft</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly">readonly (C# Reference) - microsoft</a></p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>使用 static 修饰符声明静态成员，该成员属于类型本身而不是特定对象。static 修饰符可用于声明静态类。在类、接口和结构中，您可以向字段、方法、属性、运算符、事件和构造函数添加静态修饰符。static 修饰符不能与索引器或终结器一起使用。</p><p>静态类不能被实例化，不能包含实例构造函数，无法被继承，静态类中只能有静态成员。（非静态成员需要其类的实例才能访问，故静态类只有静态成员；或者反过来说，因为静态类只有静态成员，实例化也没意义。）</p><p>使用建议：</p><p>静态类可以用作只对输入参数进行操作而不必获取或设置任何内部实例字段的方法集的方便容器。例如，在 .NET 类库中，静态 System.Math 类包含执行数学运算的方法，无需存储或检索特定于 Math 类实例的数据。</p><p>更典型的做法是声明具有一些静态成员的非静态类（而不是将整个类都声明为静态）。 静态字段的两个常见用途是保留已实例化的对象数的计数，或是存储必须在所有实例间共享的值。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static">static (C# Reference) - microsoft</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members">Static Classes and Static Class Members (C# Programming Guide) - microsoft</a></p><p>注: 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。</p><h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>静态构造函数用于初始化任何静态数据，或执行只需要执行一次的特定操作。在创建第一个实例或引用任何静态成员之前会被自动调用。</p><ul><li><p>静态构造函数不接受访问修饰符或参数。</p></li><li><p>一个类或结构只能有一个静态构造函数。</p></li><li><p>静态构造函数不能被继承或重载。</p></li><li><p>静态构造函数不能直接调用，只能由公共语言运行时 (CLR) 调用。它是自动调用的。</p><p>等等。</p></li></ul><p>详情：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors">Static Constructors - microsoft</a></p><h3 id="委托（delegate）与事件（event）"><a href="#委托（delegate）与事件（event）" class="headerlink" title="委托（delegate）与事件（event）"></a>委托（delegate）与事件（event）</h3><ul><li>委托：通常，我们将委托称为函数指针，这意味着委托对象存储方法的引用。</li><li>事件：事件是由一个对象引发的通知，用于通知其他对象发生了某些操作。</li></ul><p>事件是一种特殊的多播委托，仅可以从声明事件的类或结构（the publisher class 发布类）中对其进行调用。 如果其他类或结构订阅该事件，则在发布类引发该事件时，将调用其事件处理程序方法。</p><p>在基于事件的通信中，一个对象引发事件，另一个对象捕获并处理该事件并对其做出响应。因此处理程序方法（handler method）只不过是一种通过委托调用的方法。委托帮助我们将事件与其处理程序方法（handler method）连接起来，并帮助我们识别提供事件响应的方法。</p><p>比如：OnClick事件中的参数就是一种方法。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/event">event (C# 参考) - microsoft</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/article/how-events-and-delegates-are-releated/">How Events And Delegates Are Related</a></p><h3 id="简述Func与Action的区别"><a href="#简述Func与Action的区别" class="headerlink" title="简述Func与Action的区别"></a>简述Func与Action的区别</h3><p>Func是有返回值的委托，Action是没有返回值的委托。</p><h3 id="finally和return的执行顺序"><a href="#finally和return的执行顺序" class="headerlink" title="finally和return的执行顺序"></a>finally和return的执行顺序</h3><ol><li>执行return语句前的代码</li><li>计算return语句中的表达式</li><li>finally块被执行</li><li>返回在步骤2中得到的结果</li></ol><p>当返回值类型时，finally中给返回的变量修改值，不会影响返回值；<br>当返回值为引用类型时，返回的其实是指向该引用的指针，如果finally中更改该指针指向的数据的值，是会影响返回值的。（注意区分，更改<code>指针指向的数据的值</code>和<code>更改指针</code>的区别，更改指针不会影响返回值。）</p><p>finally中不能有return。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/a/421827/8910566">What really happens in a try { return x; } finally { x = null; } statement? - Jon Skeet</a></p><h3 id="反射Reflection"><a href="#反射Reflection" class="headerlink" title="反射Reflection"></a>反射Reflection</h3><p>程序运行时获取程序集信息，动态创建实例。反射的命名空间位于System.Reflection</p><p>反射可用于：</p><ul><li>根据条件，动态创建实例，动态调用函数，或者是调用不同版本的程序集。</li><li>不明确程序集信息，只能运行时获取程序集信息的情况。</li><li>延迟绑定，调用第三方插件（程序发布后，允许用户写插件，然后程序自行调用的情况）。</li><li>绕开一些安全机制，比如循环引用、可访问级别。</li></ul><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。泛型的提出是为了编写重用性更好的代码。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>引入泛型的目标：</p><ul><li>类型安全</li><li>消除强制类型转换（装箱拆箱）</li><li>潜在的性能收益</li></ul><p>当编译器对带有泛型的java代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这被称为 类型擦除（type erasure）。（ C# 同样适用，以泛型方法为例，编译器会根据你对该方法的使用情况，生成<code>多个相应类型的非泛型方法</code>。编译时的开销，不会影响程序运行速度。）</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://m.php.cn/article/411947.html?tdsourcetag=s_pctim_aiomsg">深入理解什么是Java泛型？泛型怎么使用？</a></p><h3 id="什么是扩展方法"><a href="#什么是扩展方法" class="headerlink" title="什么是扩展方法"></a>什么是扩展方法</h3><ul><li>扩展方法允许扩展现有类，而无需依赖继承或更改类的源代码。</li><li>密封类也可以扩展。</li><li>必须定义在非嵌套非泛型的静态类中（<code>原文是顶级静态类</code> 查了下，貌似对顶级类的定义有争议，类名是否要等于文件名）。</li><li>第一个参数的类型是要扩展的类型，并且需要添加this关键字以标识其为扩展方法。</li><li>扩展方法不能用于覆盖现有方法，与实例方法具有相同签名的扩展方法将不会被调用。</li><li>扩展方法的概念不能应用于字段、属性或事件。</li><li><code>过度使用扩展方法不是一种好的编程风格。</code></li></ul><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.c-sharpcorner.com/uploadfile/puranindia/extension-methods-in-C-Sharp-3-0/">Extension Methods in C#</a></p><h3 id="C-可否对内存直接操作"><a href="#C-可否对内存直接操作" class="headerlink" title="C#可否对内存直接操作"></a>C#可否对内存直接操作</h3><p>C#在 unsafe 模式下可以使用指针对内存进行操作，但在托管模式下不可以使用指针。</p><p>C#默认不允许操作指针，需要设置下，选择项目右键-&gt;属性-&gt;选择生成-&gt;“允许不安全代码”打勾-&gt;保存。</p><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和 &amp;&amp; 的区别"></a>&amp; 和 &amp;&amp; 的区别</h3><ul><li>&amp; 是位运算，返回结果是int类型</li><li>&amp;&amp; 是逻辑运算，返回结果是bool类型。</li></ul><p>注： C# 中 &amp;&amp; 和 || 具有短路的功能。</p><h3 id="as-和-is-的区别"><a href="#as-和-is-的区别" class="headerlink" title="as 和 is 的区别"></a>as 和 is 的区别</h3><ul><li>is: 检查表达式的运行时类型是否与给定类型兼容。</li><li>as: 将表达式显式转换为给定类型（如果其运行时类型与该类型兼容）。如果无法进行转换，则 as 运算符返回 null。与强制转换表达式 不同，as 运算符永远不会引发异常。</li><li>cast expression（强制转换表达式）：形式为 (T)E 的强制转换表达式将表达式 E 的结果显式转换为类型 T。如果不存在从类型 E 到类型 T 的显式转换，则发生编译时错误。在运行时，显式转换可能不会成功，强制转换表达式可能会引发异常。</li></ul><p>参考（详情）：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast">Type-testing operators and cast expression (C# reference)</a></p><h3 id="什么是匿名类型，有什么好处？"><a href="#什么是匿名类型，有什么好处？" class="headerlink" title="什么是匿名类型，有什么好处？"></a>什么是匿名类型，有什么好处？</h3><p>匿名类型（Anonymous Types）提供了一种方便的方法，可以将一组<code>只读属性</code>封装到单个对象中，而无需先显式定义类型。类型名称由编译器生成，在源代码级别不可用。每个属性的类型由编译器推断。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; Amount = <span class="number">108</span>, Message = <span class="string">&quot;Hello&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>使用方便。Linq 常用。无法修改。虽然可以当做 dynamic 类型的参数和返回值，但建议别这么用。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types">Anonymous Types - microsoft</a><br><a target="_blank" rel="noopener external nofollow noreferrer" href="https://stackoverflow.com/questions/6624811/how-to-pass-anonymous-types-as-parameters">How to pass anonymous types as parameters?</a></p><h3 id="动态类型（dynamic）"><a href="#动态类型（dynamic）" class="headerlink" title="动态类型（dynamic）"></a>动态类型（dynamic）</h3><p>在编译时，假定动态类型的元素支持任何操作。但是，如果代码无效，会在程序运行时报错。</p><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/using-type-dynamic">Using type dynamic (C# Programming Guide)</a></p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li>可以使用 lambda 表达式来创建匿名函数。使用 lambda 声明运算符 <code>=&gt;</code> 将 lambda 的参数列表与其主体分开。</li><li>lambda 表达是可以指派给委托类型的变量，也可以转换为表达式树类型（Expression Trees）。</li><li>可以在任何需要<code>委托类型</code>或<code>表达式树类型</code>实例的代码中使用 lambda 表达式。如（Task.Run(Action)、Linq)</li></ul><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda expressions (C# reference)</a></p><h3 id="如何提高-NET的性能"><a href="#如何提高-NET的性能" class="headerlink" title="如何提高.NET的性能"></a>如何提高.NET的性能</h3><p>这个得具体问题具体分型，随便列举几个：</p><ul><li>优化代码（废话）。</li><li>高效管理内存。合理利用缓存，及时释放资源。</li><li>尝试使用异步。</li><li>正确处理异常。</li><li>正确选择 string 和 StringBuilder</li><li>选择正确的数据类型。避免装箱拆箱。</li><li><code>测试多种方法</code>，择最优。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">itaru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://www.itaru.xyz/blogs/67f81ba6.html">https://www.itaru.xyz/blogs/67f81ba6.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.itaru.xyz" target="_blank">木漏れ日</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#</a><a class="post-meta__tags" href="/tags/NET%E9%9D%A2%E8%AF%95%E9%A2%98/">.NET面试题</a><a class="post-meta__tags" href="/tags/%E5%90%88%E9%9B%86/">合集</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/水果篮子.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blogs/6b4f6d08.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/宿命回响.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Chrome浏览器实用小技巧</div></div></a></div><div class="next-post pull-right"><a href="/blogs/15902c4f.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/鬼灭之刃.jpg" onerror='onerror=null,src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C# 中的托管与非托管（堆、资源、类型、代码）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blogs/d8b002a3.html" title=".NET面试题-C#与数据库"><img class="cover" src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/银河英雄传说-帝国.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-15</div><div class="title">.NET面试题-C#与数据库</div></div></a></div><div><a href="/blogs/eb0f2435.html" title=".NET面试题-C#与网站"><img class="cover" src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/银河英雄传说-同盟.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-16</div><div class="title">.NET面试题-C#与网站</div></div></a></div><div><a href="/blogs/a2a26768.html" title=".NET面试题-编程基础知识"><img class="cover" src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/某科学的超电磁炮.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-17</div><div class="title">.NET面试题-编程基础知识</div></div></a></div><div><a href="/blogs/9f8c60c3.html" title="C#中的protected internal 和 private protected可访问级别"><img class="cover" src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/咒术回战.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-30</div><div class="title">C#中的protected internal 和 private protected可访问级别</div></div></a></div><div><a href="/blogs/15902c4f.html" title="C# 中的托管与非托管（堆、资源、类型、代码）"><img class="cover" src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/鬼灭之刃.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-10</div><div class="title">C# 中的托管与非托管（堆、资源、类型、代码）</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/limuru.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">itaru</div><div class="author-info__description">.NET程序员。喜欢动漫，小说，音乐。希望能成为一个自在的人。</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/simpleworldz" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:932266563@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="iconfont icon-mail"></i></a><a class="social-icon" href="https://space.bilibili.com/32998251" rel="external nofollow noreferrer" target="_blank" title="bilibili"><i class="iconfont icon-bilibili-line"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=255604997" rel="external nofollow noreferrer" target="_blank" title="netease"><i class="iconfont icon-netease-cloud-music-fill"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">但行好事，莫问前程。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">如何理解装箱和拆箱？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">C# 中什么是值类型与引用类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">3.</span> <span class="toc-text">值传递与引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9Aref-out-%EF%BC%88%E4%BB%A5%E5%8F%8A-in%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">关键字：ref out （以及 in）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ref-%E4%B8%8E-out"><span class="toc-number">4.1.</span> <span class="toc-text">ref 与 out</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ref-out-%E5%92%8C-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">4.2.</span> <span class="toc-text">ref&#x2F;out 和 方法重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#in"><span class="toc-number">4.3.</span> <span class="toc-text">in</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E8%AF%A6%E8%BF%B0%E5%9C%A8-C-%E4%B8%AD%E7%B1%BB-class-%E4%B8%8E%E7%BB%93%E6%9E%84-struct-%E7%9A%84%E5%BC%82%E5%90%8C%E3%80%82"><span class="toc-number">5.</span> <span class="toc-text">请详述在 C# 中类(class)与结构(struct)的异同。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD-%E6%89%98%E7%AE%A1%E5%A0%86-%E5%92%8C-%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">C#中 托管堆 和 线程堆栈 的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81-%E5%92%8C-%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">7.</span> <span class="toc-text">托管代码 和 非托管代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">7.1.</span> <span class="toc-text">托管代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%89%98%E7%AE%A1%E4%BB%A3%E7%A0%81"><span class="toc-number">7.2.</span> <span class="toc-text">非托管代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90-%E5%92%8C-%E9%9D%9E%E6%89%98%E7%AE%A1%E8%B5%84%E6%BA%90"><span class="toc-number">8.</span> <span class="toc-text">托管资源 和 非托管资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%EF%BC%88Garbage-Collection%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">GC（Garbage Collection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CLR%EF%BC%88Common-Language-Runtime%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">CLR（Common Language Runtime）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B06%E4%B8%AD%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E7%BA%A7%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">简述6中可访问性级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual-vs-abstract"><span class="toc-number">12.</span> <span class="toc-text">virtual vs abstract</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%ADabstract-class%E5%92%8Cinterface%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">C#中abstract class和interface有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">new关键字的几种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#using%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%A8%E6%B3%95"><span class="toc-number">15.</span> <span class="toc-text">using关键字的几种用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-overload-%E4%B8%8E%E9%87%8D%E5%86%99-override-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">重载(overload)与重写(override)的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E4%B8%8E-override"><span class="toc-number">17.</span> <span class="toc-text">new 与 override</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#new"><span class="toc-number">17.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#override"><span class="toc-number">17.2.</span> <span class="toc-text">override</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">17.3.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%EF%BC%88Field%EF%BC%89%E5%92%8C%E5%B1%9E%E6%80%A7%EF%BC%88Property%EF%BC%89%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">18.</span> <span class="toc-text">字段（Field）和属性（Property）的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">19.</span> <span class="toc-text">属性与方法的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%EF%BC%88Class%EF%BC%89%E5%92%8C%E5%AE%9E%E4%BE%8B%EF%BC%88Instance%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">类（Class）和实例（Instance）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-vs-readonly"><span class="toc-number">21.</span> <span class="toc-text">const vs readonly</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#const"><span class="toc-number">21.1.</span> <span class="toc-text">const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readonly"><span class="toc-number">21.2.</span> <span class="toc-text">readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%87%E6%B3%A8"><span class="toc-number">21.3.</span> <span class="toc-text">备注</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">23.</span> <span class="toc-text">静态构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A7%94%E6%89%98%EF%BC%88delegate%EF%BC%89%E4%B8%8E%E4%BA%8B%E4%BB%B6%EF%BC%88event%EF%BC%89"><span class="toc-number">24.</span> <span class="toc-text">委托（delegate）与事件（event）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0Func%E4%B8%8EAction%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">25.</span> <span class="toc-text">简述Func与Action的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally%E5%92%8Creturn%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">26.</span> <span class="toc-text">finally和return的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84Reflection"><span class="toc-number">27.</span> <span class="toc-text">反射Reflection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">28.</span> <span class="toc-text">什么是泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">29.</span> <span class="toc-text">什么是扩展方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%8F%AF%E5%90%A6%E5%AF%B9%E5%86%85%E5%AD%98%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">30.</span> <span class="toc-text">C#可否对内存直接操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">31.</span> <span class="toc-text">&amp; 和 &amp;&amp; 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#as-%E5%92%8C-is-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">32.</span> <span class="toc-text">as 和 is 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">33.</span> <span class="toc-text">什么是匿名类型，有什么好处？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%EF%BC%88dynamic%EF%BC%89"><span class="toc-number">34.</span> <span class="toc-text">动态类型（dynamic）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">35.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98-NET%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">36.</span> <span class="toc-text">如何提高.NET的性能</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blogs/a2a26768.html" title=".NET面试题-编程基础知识"><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/某科学的超电磁炮.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/404.jpg"' alt=".NET面试题-编程基础知识"></a><div class="content"><a class="title" href="/blogs/a2a26768.html" title=".NET面试题-编程基础知识">.NET面试题-编程基础知识</a><time datetime="2021-12-17T00:41:27.000Z" title="发表于 2021-12-17 08:41:27">2021-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/eb0f2435.html" title=".NET面试题-C#与网站"><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/银河英雄传说-同盟.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/404.jpg"' alt=".NET面试题-C#与网站"></a><div class="content"><a class="title" href="/blogs/eb0f2435.html" title=".NET面试题-C#与网站">.NET面试题-C#与网站</a><time datetime="2021-12-16T14:01:35.000Z" title="发表于 2021-12-16 22:01:35">2021-12-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/d8b002a3.html" title=".NET面试题-C#与数据库"><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/银河英雄传说-帝国.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/404.jpg"' alt=".NET面试题-C#与数据库"></a><div class="content"><a class="title" href="/blogs/d8b002a3.html" title=".NET面试题-C#与数据库">.NET面试题-C#与数据库</a><time datetime="2021-12-15T00:49:22.000Z" title="发表于 2021-12-15 08:49:22">2021-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/7402d6ca.html" title="Git/GitHub 常用语法"><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/知晓天空之蓝的人啊.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/404.jpg"' alt="Git/GitHub 常用语法"></a><div class="content"><a class="title" href="/blogs/7402d6ca.html" title="Git/GitHub 常用语法">Git/GitHub 常用语法</a><time datetime="2021-12-14T14:12:14.000Z" title="发表于 2021-12-14 22:12:14">2021-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blogs/15902c4f.html" title="C# 中的托管与非托管（堆、资源、类型、代码）"><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/鬼灭之刃.jpg" onerror='this.onerror=null,this.src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/img/404.jpg"' alt="C# 中的托管与非托管（堆、资源、类型、代码）"></a><div class="content"><a class="title" href="/blogs/15902c4f.html" title="C# 中的托管与非托管（堆、资源、类型、代码）">C# 中的托管与非托管（堆、资源、类型、代码）</a><time datetime="2021-12-10T09:32:02.000Z" title="发表于 2021-12-10 17:32:02">2021-12-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By itaru</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/js/utils.js"></script><script src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/js/main.js"></script><script src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/gh/simpleworldz/simpleworldz.github.io/js/search/local-search.js"></script><script>var preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",preloader.endLoading())</script><div class="js-pjax"><script>function loadValine(){function e(){new Valine(Object.assign({el:"#vcomment",appId:"genl4SqketCh2IXRGUKmS9Kg-MdYXbMMI",appKey:"KRzjoOF52pJ1v80H8uisHTkC",placeholder:"记得留下你的昵称和邮箱....可以快速收到回复",avatar:"monsterid",meta:"nick,mail,link".split(","),pageSize:"10",lang:"zh-CN",recordIP:!1,serverURLs:"",emojiCDN:"",emojiMaps:"",enableQQ:!1,path:window.location.pathname,requiredFields:["nick,mail"],visitor:!1},null))}"function"==typeof Valine?e():getScript("https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js").then(e)}{function loadOtherComment(){loadValine()}setTimeout(loadValine,0)}</script></div><script defer id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zindex="-1" mobile="false" data-click="true"></script></div><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script></body></html>