<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>木漏れ日</title>
  
  
  <link href="https://www.itaru.xyz/atom.xml" rel="self"/>
  
  <link href="https://www.itaru.xyz/"/>
  <updated>2021-12-15T14:28:08.554Z</updated>
  <id>https://www.itaru.xyz/</id>
  
  <author>
    <name>itaru</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>.NET面试题-C#与数据库</title>
    <link href="https://www.itaru.xyz/blogs/d8b002a3.html"/>
    <id>https://www.itaru.xyz/blogs/d8b002a3.html</id>
    <published>2021-12-15T00:49:22.000Z</published>
    <updated>2021-12-15T14:28:08.554Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库操作的相关类"><a href="#数据库操作的相关类" class="headerlink" title="数据库操作的相关类"></a>数据库操作的相关类</h3><ul><li><p>特定类：Connection，Command，CommandBuilder，DataAdapter，DataReader，Parameter，Transaction 等</p></li><li><p>共享类：DataSet，DataTable，DataRow，DataColumn，DataRealtion，Constraint，DataColumnMapping，DataTableMapping 等</p></li></ul><p>参考：<a href="https://www.cnblogs.com/AlinaL/p/12852153.html">C#学习笔记之——数据库操作的相关类</a><br><a href="https://www.c-sharpcorner.com/UploadFile/puranindia/ado-net-objects-part-i/">ADO.NET Objects: Part I - C#Corner</a></p><h3 id="ADO-NET-五大对象"><a href="#ADO-NET-五大对象" class="headerlink" title="ADO.NET 五大对象"></a>ADO.NET 五大对象</h3><ul><li><p>Connection(连接对象)：与数据源建立连接。Close以后还可以Open，Dispose以后则不能再用。</p></li><li><p>DataAdapter(适配器对象)：对数据源执行操作并返回结果，在DataSet与数据源之间建立通信，将数据源中的数据写入DataSet中，或根据DataSet中的数据绑定数据源。</p></li><li><p>DataSet(数据集对象)：内存中的数据库，是数据表的集合，它可以包含任意多个数据表。</p></li><li><p>Command(命令对象)：对数据源执行SQL命令并返回结果。</p></li><li><p>DataReader(数据流对象)：取数据源的数据，只允许对将数据源以只读、顺向的方式查看其中所存储的数据。其常用于检索大量数据，DataReader对象还是一种非常节省资源的数据对象。</p></li></ul><p>DataReader时刻与远程数据库服务器保持连接，将远程的数据通过“流”的形式单向传输给客户端，它是“只读”的。由于是直接访问数据库，所以效率较高，但使用起来不方便。</p><p>DataSet一次性从数据源获取数据到本地，并在本地建立一个微型数据库（包含表、行、列、规则、表之间的关系等），期间可以断开与服务器的连接，使用DataAdapter对象操作“本地微型数据库”，结束后通过DataAdapter一次性更新到远程数据库服务器。这种方式使用起来更方便，便简单。但性能较第一种稍微差一点。（在一般的情况下两者的性能差异可以忽略不计。）</p><p>参考：<a href="https://www.cnblogs.com/igqx/archive/2020/06/22/13175824.html">C# 连接SQL数据库以及操作数据库</a><br><a href="https://www.cnblogs.com/qi123/p/9217010.html">C# 连接SQL数据库以及操作数据库</a><br><a href="https://stackoverflow.com/a/17553377/8910566">C# Data Connections Best Practice? - D Stanley</a></p><h3 id="DataTable和DataSet"><a href="#DataTable和DataSet" class="headerlink" title="DataTable和DataSet"></a>DataTable和DataSet</h3><p>DataSet是数据集（可以比作一个内存中的数据库），DataTable是数据表，DataSet中存储多个DataTable。DataSet和DataTable像是专门存储数据的一个容器，你查询数据库得到的一些结果可以存在里面。</p><p>DataSet功能强大有浏览、排序、搜索、过滤、处理分级数据、缓存更改等功能，还可以与XML数据互换。</p><p>参考：<a href="https://www.cnblogs.com/vaevvaev/p/6815384.html">C# DataSet与DataTable的区别和用法</a></p><h3 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h3><p>ORM（对象关系映射 Object–relational mapping）是一种使用面向对象的编程语言在不兼容的类型系统之间转换数据的编程技术。它可以说是创建了一个可以在编程语言中使用的“虚拟对象数据库”。</p><p>说白了就是表映射成类，外键映射成指向另一个类的属性，索引、字段长度约束等等都可以映射。</p><p>参考：<a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">Object–relational mapping</a></p><h3 id="EF-Entity-Framework-与-ADO-Net"><a href="#EF-Entity-Framework-与-ADO-Net" class="headerlink" title="EF(Entity Framework) 与 ADO.Net"></a>EF(Entity Framework) 与 ADO.Net</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/#:~:text=ADO.NET%20is%20a%20set%20of%20classes%20that%20expose%20data%20access%20services%20for%20.NET%20Framework%20programmers.">ADO.NET</a> 是为 .NET Framework 程序员提供的一组用于公开数据访问服务的类。</p><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/overview#:~:text=The%20Entity%20Framework%20is%20a%20set%20of%20technologies%20in%20ADO.NET%20that%20support%20the%20development%20of%20data-oriented%20software%20applications.">实体框架（Entity Framework）</a>是 ADO.NET 中的一组技术，用于支持面向数据的软件应用程序的开发。</p><p><a href="https://en.wikipedia.org/wiki/Entity_Framework#:~:text=Entity%20Framework%20(EF)%20is%20an%20open%20source[3]%20object%E2%80%93relational%20mapping%20(ORM)%20framework%20for%20ADO.NET.">Wiki</a> 上也说：Entity Framework 是 ADO.NET 的开源对象关系映射 (ORM) 框架。</p><p>所以说 Entity Framework 其实是包括在 ADO.Net 里的，是个 ORM 模型。但其实 ADO.Net 不止与数据库对接，还包括许多其他和数据访问相关的组件。但业界普遍喜欢将（SQLCommand, SQLDataReader, SQLConnection 和 SQLDataAdapter）的一套组件 代指 ADO.NET 。如果是以这种区分方式，EF 就是基于 ADO.Net 的。</p><p>封装的组件往往更易用，但性能<code>可能</code>稍有不如底层组件。</p><h3 id="EF-的三种编程方式"><a href="#EF-的三种编程方式" class="headerlink" title="EF 的三种编程方式"></a>EF 的三种编程方式</h3><ul><li>Model First （ADO.NET Entity Data Model）</li><li>Database First</li><li>Code First</li></ul><h3 id="Entity-Framework（或者ORM）中的-延迟加载（Lazy-Loading）、直接加载（Eager-Loading）、显式加载（Explicit-Loading）"><a href="#Entity-Framework（或者ORM）中的-延迟加载（Lazy-Loading）、直接加载（Eager-Loading）、显式加载（Explicit-Loading）" class="headerlink" title="Entity Framework（或者ORM）中的 延迟加载（Lazy Loading）、直接加载（Eager Loading）、显式加载（Explicit Loading）"></a>Entity Framework（或者ORM）中的 延迟加载（Lazy Loading）、直接加载（Eager Loading）、显式加载（Explicit Loading）</h3><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>延迟加载又叫惰性加载：即在需要或者使用的时候加载数据。默认情况下，EF会使用延迟加载方式加载数据，即数据库上下文的属性：Configuration.LazyLoadingEnabled = true。</p><ul><li>非常宽容，因为只在需要的时候加载数据，不需要预先计划</li><li>可能会因为数据访问的延迟而降低性能，考虑到每次访问父实体的子实体时，就需要访问数据库。</li></ul><h4 id="直接加载（预加载）"><a href="#直接加载（预加载）" class="headerlink" title="直接加载（预加载）"></a>直接加载（预加载）</h4><p>直接加载可一次性加载所有需要的实体。即相关对象（子对象）与其父对象一起自动加载。</p><ul><li>减少数据访问的延迟，在一次数据库的访问中返回所有的数据。</li><li>减少与数据库的交互次数</li></ul><h4 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h4><p>显式加载和延迟加载非常类似，不同的是显式加载要手动关闭 EF 的延迟加载属性，通过代码 Configuration.LazyLoadingEnabled = false 来完成。</p><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ul><li>当关系不是太多时，使用直接加载。因为，直接加载是减少服务器上进一步查询的好方法。</li><li>当您确定每当使用主实体时都会用到相关实体，请使用直接加载。</li><li>当您使用 一对多 集合时，请使用延迟加载。</li><li>当您确定不会立即使用相关实体时，请使用延迟加载。</li><li>当您关闭延迟加载时，如果您事先不确定是否会使用相关实体​​，请使用显式加载。</li></ul><p>参考：<a href="https://blog.csdn.net/u010028869/article/details/48531863">EF学习和使用（五）Lazy Loading and Eager Loading</a><br><a href="https://blog.csdn.net/u010028869/article/details/48791983">EF学习和使用（六）显式加载、按需加载</a><br><a href="https://www.c-sharpcorner.com/article/eager-loading-lazy-loading-and-explicit-loading-in-entity-framework/">Eager Loading, Lazy Loading And Explicit Loading In Entity Framework - C#Corner</a></p><h3 id="如何解决数据并发问题"><a href="#如何解决数据并发问题" class="headerlink" title="如何解决数据并发问题?"></a>如何解决数据并发问题?</h3><ul><li>加锁</li><li>数据库乐观锁（即：添加版本号字段）</li><li>使用消息队列</li></ul><p>处理并发的最终原理其实就是：将用户的<code>并行操作转换成串行操作</code>。</p><p>参考：<a href="https://blog.csdn.net/love1793912554/article/details/92437035">如何有效处理数据并发操作问题</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库操作的相关类&quot;&gt;&lt;a href=&quot;#数据库操作的相关类&quot; class=&quot;headerlink&quot; title=&quot;数据库操作的相关类&quot;&gt;&lt;/a&gt;数据库操作的相关类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;特定类：Connection，Command，CommandBui</summary>
      
    
    
    
    <category term="C#" scheme="https://www.itaru.xyz/categories/C/"/>
    
    <category term="合集" scheme="https://www.itaru.xyz/categories/C/%E5%90%88%E9%9B%86/"/>
    
    
    <category term="C#" scheme="https://www.itaru.xyz/tags/C/"/>
    
    <category term=".NET面试题" scheme="https://www.itaru.xyz/tags/NET%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="合集" scheme="https://www.itaru.xyz/tags/%E5%90%88%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Git/GitHub 常用语法</title>
    <link href="https://www.itaru.xyz/blogs/7402d6ca.html"/>
    <id>https://www.itaru.xyz/blogs/7402d6ca.html</id>
    <published>2021-12-14T14:12:14.000Z</published>
    <updated>2021-12-15T14:13:04.631Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GitHub-两种类型的-URL-地址"><a href="#GitHub-两种类型的-URL-地址" class="headerlink" title="GitHub 两种类型的 URL 地址"></a>GitHub 两种类型的 URL 地址</h3><p>以前将更改提交到 GitHub 老是报错：<code>SSL certificate problem: self signed certificate</code></p><p>也有尝试使用 <code>git config --global http.sslVerify false</code></p><p>但过段时间又报相同的错误，而且这个语句时灵时不灵，有时得执行好几次才能提交成功。就跟玄学一样。</p><p>后来发现了根源，<a href="https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories">原来 GitHub 有两种中 Url</a>：</p><ul><li>HTTPS URL 如： <code>https://github.com/user/repo.git</code></li><li>SSH URL 如： <code>git@github.com:user/repo.git</code></li></ul><p>我原先一直使用的是 https 类型的 Url，改为 ssh 类型的后，就没有再报错了。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>本地有一个 master 分支，GitHub 上有一个 main 分支。将 main 分支合并到 master 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull //将 main 分支拉到本地。或者用 git fetch</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a //查看所有分支</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch //查看当前分支。</span></span><br><span class="line"></span><br><span class="line">//若当前分支不是 master，则切换成 master：</span><br><span class="line"><span class="meta">$</span><span class="bash"> git chechout master</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/main //合并分支</span></span><br><span class="line"></span><br><span class="line">//若提示 fatal: refusing to merge unrelated histories。请加上 --allow-unrelated-histories</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/main --allow-unrelated-histories</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push //将更改推送至GitHub</span></span><br><span class="line"></span><br><span class="line">//检查更新无误后，删除 main 分支。</span><br><span class="line">//git branch -d origin/main 会报：error: branch &#x27;origin/main&#x27; not found. 因为它是</span><br><span class="line">//删除本地分支的语句</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete main //或者简化的语句 git push origin :main</span></span><br><span class="line">//如果报 ! [remote rejected] main (refusing to delete the current branch: refs/heads/main)</span><br><span class="line">//GitHub页面 -&gt; Settings -&gt; Branchs -&gt; 将默认分区从 main 切换成 master。重新尝试命令。</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/runnerjack/p/9342362.html">git pull = git fetch + git merge</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GitHub-两种类型的-URL-地址&quot;&gt;&lt;a href=&quot;#GitHub-两种类型的-URL-地址&quot; class=&quot;headerlink&quot; title=&quot;GitHub 两种类型的 URL 地址&quot;&gt;&lt;/a&gt;GitHub 两种类型的 URL 地址&lt;/h3&gt;&lt;p&gt;以前</summary>
      
    
    
    
    <category term="Git" scheme="https://www.itaru.xyz/categories/Git/"/>
    
    
    <category term="Git" scheme="https://www.itaru.xyz/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C# 中的托管与非托管（堆、资源、类型、代码）</title>
    <link href="https://www.itaru.xyz/blogs/15902c4f.html"/>
    <id>https://www.itaru.xyz/blogs/15902c4f.html</id>
    <published>2021-12-10T09:32:02.000Z</published>
    <updated>2021-12-15T12:48:49.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="托管堆（Managed-Heap）"><a href="#托管堆（Managed-Heap）" class="headerlink" title="托管堆（Managed Heap）"></a>托管堆（Managed Heap）</h3><p>一个进程中，每个线程都有自己的栈（线程堆栈 Thread Stack)，而堆<sup><a href="#1">[1]</a></sup>（Heap）是整个进程共享的。进程初始化时，CLR 划出了一个地址空间区域作为托管堆。要求所有的对象从托管堆中分配，并由 GC (垃圾回收器 Garbage Collection) 管理。</p><p><a id="1">[1]</a> <a href="https://stackoverflow.com/a/11199154/8910566">不止有托管堆，堆有好多。</a></p><div class="note info simple"><p>当对象中包含值类型的成员时，这个值类型的数据也是分配在托管堆中的。即：对象的数据（无论是值类型还是引用类型）都被打包存在托管堆中，线程堆栈中只保留一个引用。</p></div><h3 id="非托管类型（Unmanaged-Type）"><a href="#非托管类型（Unmanaged-Type）" class="headerlink" title="非托管类型（Unmanaged Type）"></a>非托管类型（Unmanaged Type）</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">非托管类型</a>：非指针，不可为 null。不包含指向托管堆中的引用<sup><a href="#2">[2]</a></sup>，不归 GC 管的类型。</p><p>包含：</p><ul><li>sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal 或 bool</li><li>任何枚举类型</li><li>任何<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code#pointer-types">指针类型</a></li><li>只包含非托管类型的字段的非泛型结构</li><li>从 C# 8.0 开始，指定的类型也是非托管类型的泛型结构也算。</li></ul><p><a id="2">[2]</a> 注意和值类型的区别，一个包含引用类型字段的结构内部是会有指向托管堆的指针的。</p><h3 id="非托管资源（Unmanaged-Resource）-与-托管资源-（Managed-Resource）"><a href="#非托管资源（Unmanaged-Resource）-与-托管资源-（Managed-Resource）" class="headerlink" title="非托管资源（Unmanaged Resource） 与 托管资源 （Managed Resource）"></a>非托管资源（Unmanaged Resource） 与 托管资源 （Managed Resource）</h3><h4 id="非托管资源"><a href="#非托管资源" class="headerlink" title="非托管资源"></a>非托管资源</h4><p>对于应用创建的大多数对象，可以依赖 GC 来进行内存管理。但是，如果创建包含非托管资源的对象，则当你使用完非托管资源后，必须显式释放这些资源。最常用的非托管资源类型是包装操作系统资源的对象，如文件、窗口、网络连接或数据库连接。虽然垃圾回收器可以跟踪<code>封装非托管资源的对象</code>的生命周期，但无法了解如何释放和清理这些非托管资源。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/unmanaged">Cleaning up unmanaged resources</a></p><h4 id="托管资源"><a href="#托管资源" class="headerlink" title="托管资源"></a>托管资源</h4><p>并没有在 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/">C# 文档</a> 找到托管资源的定义。托管资源应该是相对于非托管资源的。一般认为：托管资源是那些纯 .NET 代码并由运行时管理并受其直接控制的资源。</p><p>参考：<a href="https://stackoverflow.com/a/3607223/8910566">What is meant by “managed” vs “unmanaged” resources in .NET? - Oded</a></p><h3 id="托管代码（Managed-Code）-和-非托管代码（Unmanaged-Code）"><a href="#托管代码（Managed-Code）-和-非托管代码（Unmanaged-Code）" class="headerlink" title="托管代码（Managed Code） 和 非托管代码（Unmanaged Code）"></a>托管代码（Managed Code） 和 非托管代码（Unmanaged Code）</h3><h4 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h4><p>托管代码就是执行过程交由运行时管理的代码。</p><p>不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+）。在这里，相关的运行时是公共语言运行时 (CLR)。CLR 负责获取托管代码、将其编译成机器代码，然后执行它。除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。</p><h4 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h4><p>将此与运行 C/C++ 程序（也称为“非托管代码”）的方式形成对比。在非托管环境中，程序员需要亲自负责处理相当多的事情。程序本质上是一个二进制文件，操作系统 (OS) 将其加载到内存中并启动。其他任何工作，从内存管理到安全因素都是程序员的负担。（我的理解是，你的程序（代码）不由运行时管理，而是直接由操作系统加载并启动。而操作系统只负责运行你的程序，其他的一概都得你自己负责。）</p><p>以上只是对非托管代码的通俗解释，对于 .NET 来说，非托管代码就是 执行过程不由 CLR 管理的代码。比如调用了不属于 .NET 共享代码库中的某个 DLL，而这里面的代码就是非托管代码。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/standard/managed-code">What is “managed code”? - microsoft</a></p><h3 id="举一个例子便于理解（System-IO-FileStream）"><a href="#举一个例子便于理解（System-IO-FileStream）" class="headerlink" title="举一个例子便于理解（System.IO.FileStream）"></a>举一个例子便于理解（System.IO.FileStream）</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a>（<code>托管类型</code>，因为它包含指向<code>托管堆</code>中的引用）对象会调用 Win32 <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.safehandles.safefilehandle?view=net-6.0#:~:text=the%20unmanaged%20CreateFile%20function">CreateFile</a> 函数（<code>非托管代码</code>，因为其执行过程不由 CLR 管理），函数返回的句柄（<a href="https://docs.microsoft.com/en-us/dotnet/api/system.intptr?view=net-6.0">IntPtr</a>  它指向<code>非托管资源</code>）保存到 SafeFileHandle 对象中，然后通过 FileStream 对象的一个私有字段来维护该对象的引用。</p><div class="note info simple"><p>不能说 FileStream 的对象是非托管资源，它只是包含托管资源。当线程堆栈中没有该对象的引用时，托管堆中的 FileStream 对象是会被清理的，只是它指向的非托管资源无法被自动清理。所以要趁还能找到这些非托管资源时（即：FileStream 还没被清理时），将这些非托管资源释放掉。</p></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;托管堆（Managed-Heap）&quot;&gt;&lt;a href=&quot;#托管堆（Managed-Heap）&quot; class=&quot;headerlink&quot; title=&quot;托管堆（Managed Heap）&quot;&gt;&lt;/a&gt;托管堆（Managed Heap）&lt;/h3&gt;&lt;p&gt;一个进程中，每个线程</summary>
      
    
    
    
    <category term="C#" scheme="https://www.itaru.xyz/categories/C/"/>
    
    
    <category term="C#" scheme="https://www.itaru.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>.NET面试题-C#基础知识</title>
    <link href="https://www.itaru.xyz/blogs/67f81ba6.html"/>
    <id>https://www.itaru.xyz/blogs/67f81ba6.html</id>
    <published>2021-12-09T03:18:53.000Z</published>
    <updated>2021-12-15T13:43:53.671Z</updated>
    
    <content type="html"><![CDATA[<p>本文多数问题基于：<a href="https://zhuanlan.zhihu.com/p/355257871">.NET 面试题 - C#基础</a></p><h3 id="如何理解装箱和拆箱？"><a href="#如何理解装箱和拆箱？" class="headerlink" title="如何理解装箱和拆箱？"></a>如何理解装箱和拆箱？</h3><ul><li>装箱：将值类型转换成引用类型。  </li><li>拆箱：将引用类型转换成值类型。</li></ul><p>详情：<a href="https://blog.csdn.net/qiaoquan3/article/details/51439726">C#装箱和拆箱（Boxing 和 UnBoxing）</a></p><h3 id="C-中什么是值类型与引用类型？"><a href="#C-中什么是值类型与引用类型？" class="headerlink" title="C# 中什么是值类型与引用类型？"></a>C# 中什么是值类型与引用类型？</h3><ul><li>值类型：在线程栈分配空间。</li><li>引用类型：在托管堆分配空间，并在线程栈中留有引用。</li></ul><p>详情：<a href="https://www.cnblogs.com/yinrq/p/5588330.html">C# 值类型和引用类型</a></p><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><p>默认情况下所有对象都通过值传递而不是引用传递，不管是值类型还是引用类型。</p><ul><li>值传递：传递的是变量在线程栈（Thread Stack 又称线程堆栈）中的值的<code>副本</code>（即拷贝一份传入）。值类型则传递值，引用类型则传递引用。</li><li>引用传递：ref 关键字让形参（parameter）成为实参（argument）的别名（注意别名和拷贝副本的区别）。</li></ul><p>注意：</p><p>不要混淆通过引用传递与引用类型的概念。这两种概念是不同的。无论方法参数是值类型还是引用类型，均可由 ref 修改。当通过引用传递时，不会对值类型装箱。</p><p>参考：<a href="https://www.c-sharpcorner.com/UploadFile/f1047f/story-of-pass-by-value-and-pass-by-reference-in-C-Sharp/">Story Of Pass By Value And Pass By Reference In C# - C#Corner</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference">ref（C# 参考）- microsoft</a></p><h3 id="关键字：ref-out-（以及-in）"><a href="#关键字：ref-out-（以及-in）" class="headerlink" title="关键字：ref out （以及 in）"></a>关键字：ref out （以及 in）</h3><h4 id="ref-与-out"><a href="#ref-与-out" class="headerlink" title="ref 与 out"></a>ref 与 out</h4><table><thead><tr><th>ref</th><th>out</th></tr></thead><tbody><tr><td>参数在传递给 ref 之前必须先初始化。</td><td>参数传递给 out 之前，不需要对其进行初始化。</td></tr><tr><td>在返回<code>被调用方法</code>之前，不需要分配或初始化参数的值。</td><td>需要在返回被调用方法之前分配或初始化参数的值。</td></tr><tr><td><code>当被调用的方法还需要修改传递参数时，可选择 ref 。</code></td><td><code>当需要从函数或方法返回多个值时，可选择 out 。</code></td></tr><tr><td>在被调用方法中使用参数值之前，不必对其进行初始化。</td><td>参数值在使用前必须在被调用方法中初始化。</td></tr><tr><td>当我们使用 ref 时，数据可以双向传递。</td><td>当我们使用 out 时，数据仅以单向方式传递（从被调用的方法到调用者的方法） <tr><td colspan=2> ref 和 out 在运行时的处理方式不同，在编译时的处理方式相同。<tr><td colspan=2> 属性不是变量，因此不能作为 ref 或 out 参数传递。</td></tr></tbody></table><h4 id="ref-out-和-方法重载"><a href="#ref-out-和-方法重载" class="headerlink" title="ref/out 和 方法重载"></a>ref/out 和 方法重载</h4><p>ref 和 out 在运行时的处理方式不同，在编译时的处理方式相同，因此如果一个方法将参数作为 ref 而另一个方法将参数作为 out，则方法不能重载。</p><p>但是，当一个方法采用 ref 或 out 参数而另一个采用相同的参数而没有 ref 或 out 时，方法重载是可能的。</p><p>参考：<a href="https://www.c-sharpcorner.com/UploadFile/ff2f08/ref-vs-out-keywords-in-C-Sharp/">ref vs out in C# - C#Corner</a></p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p>in 关键字会导致按引用传递参数，但确保不会修改参数。它让形参成为实参的别名，这必须是变量。换而言之，对形参执行的任何操作都是对实参执行的。它类似于 ref 或 out 关键字，不同之处在于 in 参数<code>无法通过调用的方法进行修改</code>。而ref 参数是可以修改的，out 参数则必须由调用的方法进行修改，这些修改在调用上下文中是可观察的。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier">in parameter modifier (C# Reference) - microsoft</a></p><h3 id="请详述在-C-中类-class-与结构-struct-的异同。"><a href="#请详述在-C-中类-class-与结构-struct-的异同。" class="headerlink" title="请详述在 C# 中类(class)与结构(struct)的异同。"></a>请详述在 C# 中类(class)与结构(struct)的异同。</h3><p>共同点：</p><ul><li>都可以用来封装字段、属性、方法、构造器等。</li><li>都可以实现接口。</li></ul><p>区别：</p><ul><li>class：可以作为基类和继承其他类。引用类型，存储在托管堆中。</li><li>struct：不能通过new创建实例。值类型，存储在线程栈中。是不可变（immutable)类型。</li></ul><h3 id="C-中-托管堆-和-线程堆栈-的区别？"><a href="#C-中-托管堆-和-线程堆栈-的区别？" class="headerlink" title="C#中 托管堆 和 线程堆栈 的区别？"></a>C#中 托管堆 和 线程堆栈 的区别？</h3><ul><li>托管堆（Managed Heap）：动态分配内存，可改变大小；区域无序内存，可以任何顺序存储和删除；访问速度慢；存放引用类型，通过GC（Garbage Collector）监视清理内存。</li><li>线程堆栈（Thread Stack）：静态分配内存，不能改变大小；数组有序内存，后进先出；访问速度快；存放值类型数据，离开作用域自动释放内存。</li></ul><p>参考：<a href="https://www.c-sharpcorner.com/article/stack-vs-heap-memory-c-sharp/">Stack Vs Heap Memory - C#</a></p><h3 id="托管代码-和-非托管代码"><a href="#托管代码-和-非托管代码" class="headerlink" title="托管代码 和 非托管代码"></a>托管代码 和 非托管代码</h3><h4 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h4><p>托管代码就是执行过程交由运行时管理的代码。</p><p>不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+），在这里，相关的运行时是公共语言运行时 (CLR)。CLR 负责获取托管代码、将其编译成机器代码，然后执行它。除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。</p><h4 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h4><p>将托管代码与运行 C/C++ 程序（也称为“非托管代码”）的方式作对比。在非托管环境中，程序员需要亲自负责处理相当多的事情。程序本质上是一个二进制文件，操作系统 (OS) 将其加载到内存中并启动。其他任何工作，从内存管理到安全因素都由程序员负担。（我的理解是，你的程序（代码）不由运行时管理，而是直接由操作系统加载并启动。而操作系统只负责运行你的程序，其他的一概都得你自己负责。）</p><p>以上只是对非托管代码的通俗解释，对于 .NET 来说，非托管代码就是 执行过程不由 CLR 管理的代码。比如调用了不属于 .NET 共享代码库中的某个 DLL，而这里面的代码就是非托管代码。</p><h3 id="托管资源-和-非托管资源"><a href="#托管资源-和-非托管资源" class="headerlink" title="托管资源 和 非托管资源"></a>托管资源 和 非托管资源</h3><ul><li>托管资源是那些纯 .NET 代码并由运行时管理并受其直接控制的资源。</li><li>其他则是非托管资源。包括文件句柄、固定存储、COM 对象、数据库连接等。</li></ul><p>详情：<a href="/blogs/15902c4f.html" title="C# 中的托管与非托管（堆、资源、类型、代码）">C# 中的托管与非托管（堆、资源、类型、代码）</a> </p><h3 id="GC（Garbage-Collection）"><a href="#GC（Garbage-Collection）" class="headerlink" title="GC（Garbage Collection）"></a>GC（Garbage Collection）</h3><p>垃圾回收器。当程序需要更多的堆空间时，由 GC 进行垃圾清理工作，暂停所有线程，找出托管堆中没有被引用的对象，进行清理，并通知栈中的指针重新指向<code>地址排序后的对象</code>。</p><p>GC 只对<code>托管资源</code>进行回收。对于<code>非托管资源</code>则不能使用 GC 进行回收，必须由程序员手动回收。</p><p>例如 FileStream 或 SqlConnection 需要调用 Dispose 进行资源的回收。</p><p>精简：</p><p>GC：垃圾回收器，用于自动回收托管堆中无效对象的内存，释放内存空间。</p><h3 id="CLR（Common-Language-Runtime）"><a href="#CLR（Common-Language-Runtime）" class="headerlink" title="CLR（Common Language Runtime）"></a>CLR（Common Language Runtime）</h3><p>Microsoft .NET Framework的虚拟机组件，管理.NET程序的执行。即时编译将托管代码（编译后的中间语言代码）转换为机器指令，然后在计算机的CPU上执行。CLR提供额外的服务，包括内存管理、类型安全、异常处理、垃圾收集、安全和线程管理。为.NET Framework编写的所有程序，无论使用何种编程语言，都由CLR执行。</p><p>参考：<a href="https://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime - wiki</a></p><h3 id="简述6中可访问性级别"><a href="#简述6中可访问性级别" class="headerlink" title="简述6中可访问性级别"></a>简述6中可访问性级别</h3><ol><li>public 公有访问，不受任何限制。</li><li>private 私有访问，仅限当前类。</li><li>protected 保护访问，当前类及其子类。</li><li>internal 内部访问，当前程序集。</li><li>protected internal 当前程序集 及 其他程序集中<code>当前类</code>的子类。</li><li>private protected 子类且得是在当前程序集中。</li></ol><p>详情：<a href="/blogs/9f8c60c3.html" title="C#中的protected internal 和 private protected可访问级别">C#中的protected internal 和 private protected可访问级别</a></p><h3 id="virtual-vs-abstract"><a href="#virtual-vs-abstract" class="headerlink" title="virtual vs abstract"></a>virtual vs abstract</h3><p>共同点：</p><ul><li>都是为了实现多态。</li><li>子类重写的时候都得加override描述。</li></ul><p>区别：</p><ul><li>virtual意思是虚拟，abstract意思是抽象。</li><li>virtual只修饰方法，abstract修饰方法和类。</li><li>virtual方法必须有实现，abstract方法不能有实现。</li><li>virtual方法可以在普通类里，也可以在抽象类里，而abstract方法必须在抽象类中。（abstract class，抽象类只能被继承，不能实例化）</li><li>virtual方法可以被重写，abstract方法必须被重写。</li></ul><p>参考：<a href="https://www.cnblogs.com/woostundy/p/3424213.html">C#中virtual和abstract的区别</a></p><h3 id="C-中abstract-class和interface有什么区别"><a href="#C-中abstract-class和interface有什么区别" class="headerlink" title="C#中abstract class和interface有什么区别?"></a>C#中abstract class和interface有什么区别?</h3><p>共同点：</p><ul><li>都不能被实例化</li></ul><p>区别：</p><ul><li>abstract class可以拥有字段；interface不能。</li><li>abstract class可以对成员进行实现；interface不能。</li><li>abstract class成员可以拥有访问修饰符，成员默认私有，可以更改；interface不能拥有访问修饰符，成员默认公有，且不能修改。</li><li>abstract class可以继承类和接口；interface只能继承接口。</li><li>一个类只能继承一个抽象类，但可以继承多个接口。</li></ul><p>参考：<a href="https://www.c-sharpcorner.com/article/abstract-class-vs-interface-c-sharp/">Abstract Class Vs Interface - C#</a></p><h3 id="new关键字的几种用法"><a href="#new关键字的几种用法" class="headerlink" title="new关键字的几种用法"></a>new关键字的几种用法</h3><ul><li>运算符：创建对象和调用构造函数。</li><li>修饰符：隐藏从基类继承的成员。</li><li>约束：它指定泛型类型必须具有公共无参数构造函数。</li></ul><p>参考：<a href="https://www.c-sharpcorner.com/UploadFile/g_arora/discussing-new-keyword-of-C-Sharp/">“new” Keyword of C#</a></p><h3 id="using关键字的几种用法"><a href="#using关键字的几种用法" class="headerlink" title="using关键字的几种用法"></a>using关键字的几种用法</h3><ul><li>作为指令：用于导入其他命名空间中定义的类型或为命名空间创建别名。（引用命名空间）</li><li>作为语句：用于定义一个范围，在此范围的末尾将释放对象。（定义一个代码块）</li></ul><h3 id="重载-overload-与重写-override-的区别"><a href="#重载-overload-与重写-override-的区别" class="headerlink" title="重载(overload)与重写(override)的区别"></a>重载(overload)与重写(override)的区别</h3><table><thead><tr><th>方法重载</th><th>方法重写</th></tr></thead><tbody><tr><td>在同一个类中创建多个具有相同名称但不同签名或参数的方法称为方法重载。</td><td>在派生类中创建与基类中的方法具有相同签名的方法称为方法覆盖</td></tr><tr><td>它被称为编译时多态性</td><td>它被称为运行时多态性</td></tr><tr><td>它具有相同的方法名称，但具有不同的签名或参数</td><td>它必须具有相同的方法名称以及签名或参数。</td></tr><tr><td>方法重载不需要继承</td><td>方法覆盖需要继承</td></tr><tr><td>可以是任何访问修饰符</td><td>只能是public</td></tr></tbody></table><p>参考：<a href="https://www.c-sharpcorner.com/blogs/difference-between-method-overloading-and-method-overriding">Difference Between Method Overloading And Method Overriding</a></p><h3 id="new-与-override"><a href="#new-与-override" class="headerlink" title="new 与 override"></a>new 与 override</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>在用作声明修饰符时，new 关键字可以显式隐藏从基类继承的成员。隐藏继承的成员时，该成员的派生版本将替换基类版本。（不改变执行逻辑，只是编译时不警告）</p><p>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/new-modifier">new 修饰符（C# 参考）- microsoft</a></p><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>扩展或修改继承的方法、属性、索引器或事件的抽象或虚拟实现需要 override 修饰符。</p><p>override 方法提供从基类继承的方法的新实现。不能重写非虚方法或静态方法。重写基方法必须是 virtual、abstract 或 override 修饰的。override 方法和 virtual 方法必须具有相同级别访问修饰符。</p><p>参考；<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/override">override（C# 参考）- microsoft</a></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseClass bcdc = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">bcdc.Method();</span><br></pre></td></tr></table></figure><p>默认情况（未加修饰符）：执行BaseClass中的Method。<br>new：执行BaseClass中的Method。<br>override：执行DerivedClass中的Method。</p><p>另外：new 可以用来修饰字段，Override 不能。</p><p>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords">了解何时使用 Override 和 New 关键字（C# 编程指南）- microsoft</a></p><h3 id="字段（Field）和属性（Property）的关系"><a href="#字段（Field）和属性（Property）的关系" class="headerlink" title="字段（Field）和属性（Property）的关系"></a>字段（Field）和属性（Property）的关系</h3><p>字段是一个类的普通成员变量或成员实例。</p><p>属性也称为访问器，它是获取和设置字段的值的抽象。</p><p>属性是基于字段的，如果没有声明字段，编译器会自动声明字段，这属于隐式声明字段。</p><p>通常，应该将成员变量声明为私有，然后为它们声明或定义属性。</p><h3 id="属性与方法的关系"><a href="#属性与方法的关系" class="headerlink" title="属性与方法的关系"></a>属性与方法的关系</h3><p>属性是被称为<code>访问器</code>的一种特殊方法。</p><p>一般来说，方法代表行为，属性代表数据。属性旨在像字段一样使用，这意味着属性不应在计算上复杂或产生副作用。</p><p>如果不违反以下准则，请考虑使用属性而不是方法，因为经验不足的开发人员会发现属性更易于使用。</p><p>详情：<a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms229054(v=vs.100)?redirectedfrom=MSDN">Choosing Between Properties and Methods</a></p><h3 id="类（Class）和实例（Instance）"><a href="#类（Class）和实例（Instance）" class="headerlink" title="类（Class）和实例（Instance）"></a>类（Class）和实例（Instance）</h3><p>类是<code>抽象的模板</code>，实例是根据类创建出来的一个个<code>具体的对象</code>，每个对象都拥有相同的方法，但各自的数据可能不同。</p><p>参考：<a href="https://blog.csdn.net/ym01213/article/details/86698455">python 类（Class）和实例（Instance）</a></p><h3 id="const-vs-readonly"><a href="#const-vs-readonly" class="headerlink" title="const vs readonly"></a>const vs readonly</h3><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const 关键字用来声明某个常量字段或常量局部变量。常量字段和常量局部变量不是变量并且不能修改。常量可以为数字、布尔值、字符串或 null 引用。</p><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>在字段声明中，readonly 指示只能在声明期间或在同一个类的构造函数中向字段赋值。可以在字段声明和构造函数中多次分配和重新分配只读字段。</p><p>构造函数退出后，不能分配 readonly 字段。<code>此规则对于值类型和引用类型具有不同的含义：</code></p><p>由于值类型直接包含数据，因此属于 readonly 值类型的字段不可变。<br>由于引用类型包含对其数据的引用，因此属于 readonly 引用类型的字段必须始终引用同一对象。该对象是可变的。 readonly 修饰符可防止字段替换为其他实例，但不会阻止修改该字段中的数据。</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>readonly 关键字不同于 const 关键字。 const 字段只能在该字段的声明中初始化。readonly 字段可以在字段声明和任何构造函数中多次分配。因此，根据所使用的构造函数，readonly 字段可能具有不同的值。另外，const 字段是编译时常量，而 readonly 字段可用作运行时常量。const 常量既可以声明在类中也可以在函数体内，但是 readonly 常量只能声明在类中。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static">static (C# Reference) - microsoft</a><br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly">readonly (C# Reference) - microsoft</a></p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>使用 static 修饰符声明静态成员，该成员属于类型本身而不是特定对象。static 修饰符可用于声明静态类。在类、接口和结构中，您可以向字段、方法、属性、运算符、事件和构造函数添加静态修饰符。static 修饰符不能与索引器或终结器一起使用。</p><p>静态类不能被实例化，不能包含实例构造函数，无法被继承，静态类中只能有静态成员。（非静态成员需要其类的实例才能访问，故静态类只有静态成员；或者反过来说，因为静态类只有静态成员，实例化也没意义。）</p><p>使用建议：</p><p>静态类可以用作只对输入参数进行操作而不必获取或设置任何内部实例字段的方法集的方便容器。例如，在 .NET 类库中，静态 System.Math 类包含执行数学运算的方法，无需存储或检索特定于 Math 类实例的数据。</p><p>更典型的做法是声明具有一些静态成员的非静态类（而不是将整个类都声明为静态）。 静态字段的两个常见用途是保留已实例化的对象数的计数，或是存储必须在所有实例间共享的值。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static">static (C# Reference) - microsoft</a><br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members">Static Classes and Static Class Members (C# Programming Guide) - microsoft</a></p><p>注: 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。</p><h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>静态构造函数用于初始化任何静态数据，或执行只需要执行一次的特定操作。在创建第一个实例或引用任何静态成员之前会被自动调用。</p><ul><li><p>静态构造函数不接受访问修饰符或参数。</p></li><li><p>一个类或结构只能有一个静态构造函数。</p></li><li><p>静态构造函数不能被继承或重载。</p></li><li><p>静态构造函数不能直接调用，只能由公共语言运行时 (CLR) 调用。它是自动调用的。</p><p>  等等。</p></li></ul><p>详情：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors">Static Constructors - microsoft</a></p><h3 id="委托（delegate）与事件（event）"><a href="#委托（delegate）与事件（event）" class="headerlink" title="委托（delegate）与事件（event）"></a>委托（delegate）与事件（event）</h3><ul><li>委托：通常，我们将委托称为函数指针，这意味着委托对象存储方法的引用。</li><li>事件：事件是由一个对象引发的通知，用于通知其他对象发生了某些操作。</li></ul><p>事件是一种特殊的多播委托，仅可以从声明事件的类或结构（the publisher class   发布类）中对其进行调用。 如果其他类或结构订阅该事件，则在发布类引发该事件时，将调用其事件处理程序方法。</p><p>在基于事件的通信中，一个对象引发事件，另一个对象捕获并处理该事件并对其做出响应。因此处理程序方法（handler method）只不过是一种通过委托调用的方法。委托帮助我们将事件与其处理程序方法（handler method）连接起来，并帮助我们识别提供事件响应的方法。</p><p>比如：OnClick事件中的参数就是一种方法。</p><p>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/event">event (C# 参考) - microsoft</a><br><a href="https://www.c-sharpcorner.com/article/how-events-and-delegates-are-releated/">    How Events And Delegates Are Related</a></p><h3 id="简述Func与Action的区别"><a href="#简述Func与Action的区别" class="headerlink" title="简述Func与Action的区别"></a>简述Func与Action的区别</h3><p>Func是有返回值的委托，Action是没有返回值的委托。</p><h3 id="finally和return的执行顺序"><a href="#finally和return的执行顺序" class="headerlink" title="finally和return的执行顺序"></a>finally和return的执行顺序</h3><ol><li>执行return语句前的代码 </li><li>计算return语句中的表达式 </li><li>finally块被执行 </li><li>返回在步骤2中得到的结果</li></ol><p>当返回值类型时，finally中给返回的变量修改值，不会影响返回值；<br>当返回值为引用类型时，返回的其实是指向该引用的指针，如果finally中更改该指针指向的数据的值，是会影响返回值的。（注意区分，更改<code>指针指向的数据的值</code>和<code>更改指针</code>的区别，更改指针不会影响返回值。）</p><p>finally中不能有return。</p><p>参考：<a href="https://stackoverflow.com/a/421827/8910566">What really happens in a try { return x; } finally { x = null; } statement? - Jon Skeet</a></p><h3 id="反射Reflection"><a href="#反射Reflection" class="headerlink" title="反射Reflection"></a>反射Reflection</h3><p>程序运行时获取程序集信息，动态创建实例。反射的命名空间位于System.Reflection</p><p>反射可用于：</p><ul><li>根据条件，动态创建实例，动态调用函数，或者是调用不同版本的程序集。</li><li>不明确程序集信息，只能运行时获取程序集信息的情况。</li><li>延迟绑定，调用第三方插件（程序发布后，允许用户写插件，然后程序自行调用的情况）。</li><li>绕开一些安全机制，比如循环引用、可访问级别。</li></ul><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。泛型的提出是为了编写重用性更好的代码。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>引入泛型的目标：</p><ul><li>类型安全</li><li>消除强制类型转换（装箱拆箱）</li><li>潜在的性能收益</li></ul><p>当编译器对带有泛型的java代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这被称为 类型擦除（type erasure）。（ C# 同样适用，以泛型方法为例，编译器会根据你对该方法的使用情况，生成<code>多个相应类型的非泛型方法</code>。编译时的开销，不会影响程序运行速度。）</p><p>参考：<a href="http://m.php.cn/article/411947.html?tdsourcetag=s_pctim_aiomsg">深入理解什么是Java泛型？泛型怎么使用？</a></p><h3 id="什么是扩展方法"><a href="#什么是扩展方法" class="headerlink" title="什么是扩展方法"></a>什么是扩展方法</h3><ul><li>扩展方法允许扩展现有类，而无需依赖继承或更改类的源代码。</li><li>密封类也可以扩展。</li><li>必须定义在非嵌套非泛型的静态类中（<code>原文是顶级静态类</code> 查了下，貌似对顶级类的定义有争议，类名是否要等于文件名）。</li><li>第一个参数的类型是要扩展的类型，并且需要添加this关键字以标识其为扩展方法。</li><li>扩展方法不能用于覆盖现有方法，与实例方法具有相同签名的扩展方法将不会被调用。</li><li>扩展方法的概念不能应用于字段、属性或事件。</li><li><code>过度使用扩展方法不是一种好的编程风格。</code></li></ul><p>参考：<a href="https://www.c-sharpcorner.com/uploadfile/puranindia/extension-methods-in-C-Sharp-3-0/">Extension Methods in C#</a></p><h3 id="C-可否对内存直接操作"><a href="#C-可否对内存直接操作" class="headerlink" title="C#可否对内存直接操作"></a>C#可否对内存直接操作</h3><p>C#在 unsafe 模式下可以使用指针对内存进行操作，但在托管模式下不可以使用指针。</p><p>C#默认不允许操作指针，需要设置下，选择项目右键-&gt;属性-&gt;选择生成-&gt;“允许不安全代码”打勾-&gt;保存。</p><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和 &amp;&amp; 的区别"></a>&amp; 和 &amp;&amp; 的区别</h3><ul><li>&amp; 是位运算，返回结果是int类型 </li><li>&amp;&amp; 是逻辑运算，返回结果是bool类型。</li></ul><p>注： C# 中 &amp;&amp; 和 || 具有短路的功能。</p><h3 id="as-和-is-的区别"><a href="#as-和-is-的区别" class="headerlink" title="as 和 is 的区别"></a>as 和 is 的区别</h3><ul><li>is: 检查表达式的运行时类型是否与给定类型兼容。</li><li>as: 将表达式显式转换为给定类型（如果其运行时类型与该类型兼容）。如果无法进行转换，则 as 运算符返回 null。与强制转换表达式 不同，as 运算符永远不会引发异常。</li><li>cast expression（强制转换表达式）：形式为 (T)E 的强制转换表达式将表达式 E 的结果显式转换为类型 T。如果不存在从类型 E 到类型 T 的显式转换，则发生编译时错误。在运行时，显式转换可能不会成功，强制转换表达式可能会引发异常。</li></ul><p>参考（详情）：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast">Type-testing operators and cast expression (C# reference)</a></p><h3 id="什么是匿名类型，有什么好处？"><a href="#什么是匿名类型，有什么好处？" class="headerlink" title="什么是匿名类型，有什么好处？"></a>什么是匿名类型，有什么好处？</h3><p>匿名类型（Anonymous Types）提供了一种方便的方法，可以将一组<code>只读属性</code>封装到单个对象中，而无需先显式定义类型。类型名称由编译器生成，在源代码级别不可用。每个属性的类型由编译器推断。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; Amount = <span class="number">108</span>, Message = <span class="string">&quot;Hello&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>使用方便。Linq 常用。无法修改。虽然可以当做 dynamic 类型的参数和返回值，但建议别这么用。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types">Anonymous Types - microsoft</a><br><a href="https://stackoverflow.com/questions/6624811/how-to-pass-anonymous-types-as-parameters">How to pass anonymous types as parameters?</a></p><h3 id="动态类型（dynamic）"><a href="#动态类型（dynamic）" class="headerlink" title="动态类型（dynamic）"></a>动态类型（dynamic）</h3><p>在编译时，假定动态类型的元素支持任何操作。但是，如果代码无效，会在程序运行时报错。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/using-type-dynamic">Using type dynamic (C# Programming Guide)</a></p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li>可以使用 lambda 表达式来创建匿名函数。使用 lambda 声明运算符 <code>=&gt;</code> 将 lambda 的参数列表与其主体分开。</li><li>lambda 表达是可以指派给委托类型的变量，也可以转换为表达式树类型（Expression Trees）。</li><li>可以在任何需要<code>委托类型</code>或<code>表达式树类型</code>实例的代码中使用 lambda 表达式。如（Task.Run(Action)、Linq)</li></ul><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda expressions (C# reference)</a></p><h3 id="如何提高-NET的性能"><a href="#如何提高-NET的性能" class="headerlink" title="如何提高.NET的性能"></a>如何提高.NET的性能</h3><p>这个得具体问题具体分型，随便列举几个：</p><ul><li>优化代码（废话）。</li><li>高效管理内存。合理利用缓存，及时释放资源。</li><li>尝试使用异步。</li><li>正确处理异常。</li><li>正确选择 string 和 StringBuilder</li><li>选择正确的数据类型。避免装箱拆箱。</li><li><code>测试多种方法</code>，择最优。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文多数问题基于：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/355257871&quot;&gt;.NET 面试题 - C#基础&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何理解装箱和拆箱？&quot;&gt;&lt;a href=&quot;#如何理解装箱和拆箱？&quot; class=&quot;header</summary>
      
    
    
    
    <category term="C#" scheme="https://www.itaru.xyz/categories/C/"/>
    
    <category term="合集" scheme="https://www.itaru.xyz/categories/C/%E5%90%88%E9%9B%86/"/>
    
    
    <category term="C#" scheme="https://www.itaru.xyz/tags/C/"/>
    
    <category term=".NET面试题" scheme="https://www.itaru.xyz/tags/NET%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="合集" scheme="https://www.itaru.xyz/tags/%E5%90%88%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Chrome浏览器实用小技巧</title>
    <link href="https://www.itaru.xyz/blogs/6b4f6d08.html"/>
    <id>https://www.itaru.xyz/blogs/6b4f6d08.html</id>
    <published>2021-12-02T14:06:08.000Z</published>
    <updated>2021-12-15T12:45:06.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="text"><a href="#text" class="headerlink" title="#:~:text="></a>#:~:text=</h3><p>Url + #:~:text= + text 可定位并高亮显示text。</p><p>点击以下链接测试效果：</p><p><a href="https://www.itaru.xyz/blogs/6b4f6d08.html#:~:text=%E7%82%B9%E5%87%BB%E4%BB%A5%E4%B8%8B%E9%93%BE%E6%8E%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">https://www.itaru.xyz/blogs/6b4f6d08.html#:~:text=点击以下链接测试效果</a></p><h3 id="Programmable-Search-Engine"><a href="#Programmable-Search-Engine" class="headerlink" title="Programmable Search Engine"></a>Programmable Search Engine</h3><p><a href="https://programmablesearchengine.google.com/about/">Programmable Search Engine</a> 可以看做是 site:domain 的升级版。</p><p>添加几个网站，点击创建。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211203220642.png" alt="20211203220642"></p><p>效果：</p><script async src="https://cse.google.com/cse.js?cx=172f19e93bd715f48"></script><div class="gcse-search"></div><p>或者也可以这么用：<a href="https://cse.google.com/cse?cx=172f19e93bd715f48">编程网址</a></p><p>如果你自己的网站能被谷歌很好的收录，也可以使用 Programmable Search Engine 创建自己的站点的搜索引擎。效果类似于本站顶部的搜索，但本站使用的是专门用于hexo的 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a>。</p><h3 id="MEMEX"><a href="#MEMEX" class="headerlink" title="MEMEX"></a>MEMEX</h3><p><a href="https://memex.garden/">WorldBrain’s Memex</a> 是一个浏览器扩展，<a href="https://github.com/WorldBrain/Memex#:~:text=full-text%20search%20your%20browsing%20history%20&%20bookmarks">可以全文检索你的浏览历史记录和书签</a>。</p><p>Chrome书签管理器中的搜索框只能根据书签的标题进行检索，而这个Google插件可以对书签进行全文检索。</p><p>效果：</p><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211203222740.png" alt="20211203222740"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;text&quot;&gt;&lt;a href=&quot;#text&quot; class=&quot;headerlink&quot; title=&quot;#:~:text=&quot;&gt;&lt;/a&gt;#:~:text=&lt;/h3&gt;&lt;p&gt;Url + #:~:text= + text 可定位并高亮显示text。&lt;/p&gt;
&lt;p&gt;点击以下链接测试</summary>
      
    
    
    
    <category term="Tips" scheme="https://www.itaru.xyz/categories/Tips/"/>
    
    <category term="Chrome" scheme="https://www.itaru.xyz/categories/Tips/Chrome/"/>
    
    
    <category term="Chrome" scheme="https://www.itaru.xyz/tags/Chrome/"/>
    
    <category term="Tips" scheme="https://www.itaru.xyz/tags/Tips/"/>
    
  </entry>
  
  <entry>
    <title>C#中的protected internal 和 private protected可访问级别</title>
    <link href="https://www.itaru.xyz/blogs/9f8c60c3.html"/>
    <id>https://www.itaru.xyz/blogs/9f8c60c3.html</id>
    <published>2021-11-30T09:58:14.000Z</published>
    <updated>2021-12-15T14:27:31.971Z</updated>
    
    <content type="html"><![CDATA[<h3 id="protected-internal"><a href="#protected-internal" class="headerlink" title="protected internal"></a>protected internal</h3><p><a href="https://stackoverflow.com/questions/585859/what-is-the-difference-between-protected-and-protected-internal/64951530#64951530#:~:text=Everyone%20inside%20the%20city%20(internal)%20and%20everyone%20outside%20of%20city%20that%20their%20parents%20live%20here%20(protected)%20are%20allowed%20to%20visit%20the%20museum%20(protected%20internal).">What is the difference between ‘protected’ and ‘protected internal’ - Hassan Monjezi</a><br>这个答案有一句描述是：</p><div class="note simple"><p>Everyone inside the city (internal) and everyone outside of city that their parents live here (protected) are allowed to visit the museum (protected internal).</p></div><p>我对这句话的理解是，该程序集中的所有类 以及 该程序集中<code>任一</code>类的派生类 可访问。（不懂是不是我的蹩脚英语理解错了他的意思。）而我记得应该是<code>该成员所在类</code>的派生类。</p><p>而这个官方文档中的 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal#:~:text=containing%20class">containing class</a>也不懂什么意思。（谷歌翻译是 包含类）。</p><p>平时压根就没用过protected internal这个访问修饰符，还真不确定哪个是对的。于是自己测试了下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassLibrary1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="built_in">int</span> myValue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestAccess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassLibrary2</span></span><br><span class="line"><span class="comment">// 引用ClassLibrary1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">        derivedObject.myValue = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass2</span> : <span class="title">TestAccess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">        derivedObject.myValue = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能提示的结果：<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211130213600.png" alt="20211130213600"></p><p>于是乎我突然发现这个答案是0赞的。。并且高赞答案 <a href="https://stackoverflow.com/questions/585859/what-is-the-difference-between-protected-and-protected-internal/585869#585869#:~:text=Access%20from%20another%20assembly%20must%20take%20place%20within%20a%20class%20declaration%20that%20derives%20from%20the%20class%20in%20which%20the%20protected%20internal%20element%20is%20declared,%20and%20it%20must%20take%20place%20through%20an%20instance%20of%20the%20derived%20class%20type.">What is the difference between ‘protected’ and ‘protected internal’ - M4N</a> 的描述是：</p><div class="note simple"><p>Access from another assembly must take place within a class declaration that derives from the class in which the protected internal element is declared, and it must take place through an instance of the derived class type.</p></div><p>其实早就注意到这个答案，只是一开始没有理解是什么意思，测试后算是理解了：</p><p>在别的程序集中，<code>不能通过父类的实例访问。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">baseObject.myValue = <span class="number">5</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p><code>得通过该派生类本身的实例访问。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">derivedObject.myValue = <span class="number">10</span>;<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure><p>另外：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal#:~:text=containing%20class">containing class</a> 可以理解为容器类。</p><h3 id="private-protected"><a href="#private-protected" class="headerlink" title="private protected"></a>private protected</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected#:~:text=A%20private%20protected%20member%20is%20accessible%20by%20types%20derived%20from%20the%20containing%20class,%20but%20only%20within%20its%20containing%20assembly.">官方文档</a>中的描述是：</p><div class="note simple"><p>A private protected member is accessible by types derived from the containing class, but only within its containing assembly.</p></div><p>即 <code>不仅得是该成员所在类的派生类，还的是在同一程序集中。</code></p><p>将上文中的 protected internal 改为 private protected。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//protected internal int myValue = 0;</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">protected</span> <span class="built_in">int</span> myValue = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>并在 ClassLibrary1 再添加一个派生类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">          derivedObject.myValue = <span class="number">10</span>;</span><br><span class="line">          <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">          baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>智能提示的结果：<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211130214037.png" alt="20211130214037"><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211130213621.png" alt="20211130213621"></p><p>只有一处有权限。显然这个也有和protected internal一样的限制：<code>不能通过父类的实例访问，得通过自己（派生类）的实例访问。</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;protected-internal&quot;&gt;&lt;a href=&quot;#protected-internal&quot; class=&quot;headerlink&quot; title=&quot;protected internal&quot;&gt;&lt;/a&gt;protected internal&lt;/h3&gt;&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="C#" scheme="https://www.itaru.xyz/categories/C/"/>
    
    
    <category term="C#" scheme="https://www.itaru.xyz/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>图片上传到博客后被自动拉伸的原因</title>
    <link href="https://www.itaru.xyz/blogs/eda0a079.html"/>
    <id>https://www.itaru.xyz/blogs/eda0a079.html</id>
    <published>2021-11-05T03:42:56.000Z</published>
    <updated>2021-11-05T14:18:17.984Z</updated>
    
    <content type="html"><![CDATA[<p>写上一篇文章的时候遇到一个问题，图片上传到博客后长宽都被自动拉伸到了原先的1.5倍。</p><div class="note info simple"><p>只有部分人的电脑会出现这个问题，这和电脑的设置有关。</p></div><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用微信截图工具截一个 300 x 200 的图片。<br>上传到博客后，这图占据的大小成了 450 x 300，但其实图片的像素还是 300 x 200。</p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/小电视.png" align='left' /><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/1636119728(1).png" alt="1636119728(1)"><br><b>另外：</b><br>不仅是自己的博客，其他网页也会出现图片占用大小比实际像素多的情况。<br>将图片放入OneNote中，图片也会被放大。<br>用ImageClass或电脑自带的画图软件打开图片，图片则没有被放大。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p><code>显示-&gt;缩放与布局-&gt;更改文本、应用等项目的大小 默认设置为了150%。</code><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211105214515.png" alt="20211105214515"><br><b>推荐值和屏幕的大小以及分辨率有关，设置成自己感觉最舒服的值即可，这个值往往就是推荐值。所以这个没必要改，只是知道原因就行。图片也没必要做处理，毕竟每个人的设置可能不一样。</b></p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://www.itechtics.com/resolution-scaling-layout/">How To Optimize resolution, scaling, and layout in Windows 10</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写上一篇文章的时候遇到一个问题，图片上传到博客后长宽都被自动拉伸到了原先的1.5倍。&lt;/p&gt;
&lt;div class=&quot;note info simple&quot;&gt;&lt;p&gt;只有部分人的电脑会出现这个问题，这和电脑的设置有关。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="问题排除" scheme="https://www.itaru.xyz/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/"/>
    
    <category term="写博客" scheme="https://www.itaru.xyz/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="问题排除" scheme="https://www.itaru.xyz/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/"/>
    
    <category term="写博客" scheme="https://www.itaru.xyz/tags/%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>打开英雄联盟客户端后耳机没声音的解决方案</title>
    <link href="https://www.itaru.xyz/blogs/a6dbf255.html"/>
    <id>https://www.itaru.xyz/blogs/a6dbf255.html</id>
    <published>2021-11-02T07:47:43.000Z</published>
    <updated>2021-11-05T13:52:02.101Z</updated>
    
    <content type="html"><![CDATA[<p>自从9月份开启无线活力以来，我已经不懂几次下了删，删了下英雄联盟了。每次都想着每天玩个几局就行，可毫无例外，每次都上头，一玩就是没个停。然后就是后悔，决定卸载游戏，可没过几天又下载。想起了我大学时的有个舍友，他也是这样英雄联盟下载卸载反反复复。</p><p>这回下载完，打开英雄联盟客户端，发现耳机没声音了，并且按耳机的按键会有 咚咚咚 的响声。顺带一提，我用的是索尼wi-1000xm2无线蓝牙耳机，电脑系统是win10。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>以前当播放设备从 Stereo 切换成 Hands-Free 时，点击耳机按键也会有 咚咚咚 的声音。只是这种情况时耳机不会没有声音，反而声音特别大。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211102210157.png" alt="20211102210157"><br>这回不是这个原因，其实一开始并不知道是英雄联盟客户端的原因。我只是在尝试各种方法，比如蓝牙重新配对；删了蓝牙驱动后重启<code>（重启电脑时，系统会自动检查缺少的驱动并重新安装）</code> 等等。以为解决了，开启英雄联盟客户端又出现同样的问题，才确定是和英雄联盟客户端有关。后来查了下，和猜测的差不多，是麦克风的问题。</p><p><code>由于我把电脑自带的麦克风禁用了，客户端自动使用耳机的麦克风，于是出现了这个问题。</code><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211102212125.png" alt="20211102212125"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>有三种方式解决这个问题。</p><h4 id="方法一：客户端中点击测试麦克风"><a href="#方法一：客户端中点击测试麦克风" class="headerlink" title="方法一：客户端中点击测试麦克风"></a>方法一：客户端中点击测试麦克风</h4><p>这个方法每次打开客户端都得重新再来一遍。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211102212216.png" alt="20211102212216"></p><h4 id="方法二：客户端语音设置中的输入设备选择电脑自带的麦克风"><a href="#方法二：客户端语音设置中的输入设备选择电脑自带的麦克风" class="headerlink" title="方法二：客户端语音设置中的输入设备选择电脑自带的麦克风"></a>方法二：客户端语音设置中的输入设备选择电脑自带的麦克风</h4><p>如果电脑自带麦克风被禁用了，得开启。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211102212740.png" alt="20211102212740"></p><h4 id="方法三：电脑设置中关闭允许应用访问你的麦克风"><a href="#方法三：电脑设置中关闭允许应用访问你的麦克风" class="headerlink" title="方法三：电脑设置中关闭允许应用访问你的麦克风"></a>方法三：电脑设置中关闭允许应用访问你的麦克风</h4><p>设置-&gt;隐私-&gt;麦克风<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211102213049.png" alt="20211102213049"></p><p><b>在客户端中禁用语音的方法没试过，游戏已卸载，没法试了。</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从9月份开启无线活力以来，我已经不懂几次下了删，删了下英雄联盟了。每次都想着每天玩个几局就行，可毫无例外，每次都上头，一玩就是没个停。然后就是后悔，决定卸载游戏，可没过几天又下载。想起了我大学时的有个舍友，他也是这样英雄联盟下载卸载反反复复。&lt;/p&gt;
&lt;p&gt;这回下载完，打</summary>
      
    
    
    
    <category term="问题排除" scheme="https://www.itaru.xyz/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/"/>
    
    <category term="耳机" scheme="https://www.itaru.xyz/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/%E8%80%B3%E6%9C%BA/"/>
    
    
    <category term="问题排除" scheme="https://www.itaru.xyz/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/"/>
    
    <category term="耳机" scheme="https://www.itaru.xyz/tags/%E8%80%B3%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何在日亚购买kindle电子书</title>
    <link href="https://www.itaru.xyz/blogs/35c8c95f.html"/>
    <id>https://www.itaru.xyz/blogs/35c8c95f.html</id>
    <published>2021-10-28T12:37:44.000Z</published>
    <updated>2021-10-30T13:59:39.709Z</updated>
    
    <content type="html"><![CDATA[<p>由于对版权保护的重视，日文原版书在互联网上特别难找。淘宝上的kindle日亚代购收费也是贵得离谱，我只问了一家晒出来的价格还行的店铺，一本折合人民币27的书，收我50。这亏怎么能吃？</p><p>说来日亚购买电子书也就几步</p><ul><li>连接日本代理</li><li>注册日亚账号</li><li>填写支付信息</li><li>购买电子书</li></ul><p>详细步骤看这边，<a href="https://www.bilibili.com/read/cv2029800/">如何使用日亚购买电子版杂志</a>。只是有几点需要注意下：</p><h3 id="支付信息"><a href="#支付信息" class="headerlink" title="支付信息"></a>支付信息</h3><h4 id="信用卡"><a href="#信用卡" class="headerlink" title="信用卡"></a>信用卡</h4><p>信用卡支付是日亚支付最通用的方法，以下几种信用卡都行。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211028213001.png" alt="20211028213001"></p><h4 id="中国银行长城跨境通国际借记卡"><a href="#中国银行长城跨境通国际借记卡" class="headerlink" title="中国银行长城跨境通国际借记卡"></a>中国银行长城跨境通国际借记卡</h4><p><code>长城跨境通国际借记卡</code>如其名，是一种借记卡，申请这种卡<a href="https://www.boc.cn/Bcservice/bc2/201704/t20170426_9329829.html#:~:text=%E5%8F%AA%E9%9C%80%E5%87%AD%E6%9C%AC%E4%BA%BA%E6%9C%89%E6%95%88%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%BB%B6">没有申请信用卡的条条框框</a>，适合由于各种原因无法或者不想申请信用卡的同学。我用的就是这种卡，直接去营业厅办理，当场就能领到卡。要注意的是，并不是所有中国银行的营业厅都能办理这种卡，往往城市分行和大学里的支行会有，去之前可以打电话询问下。另外，这卡得绑定一张中国银行的一类卡，如果没有，得一起办理。</p><h4 id="虚拟信用卡"><a href="#虚拟信用卡" class="headerlink" title="虚拟信用卡"></a>虚拟信用卡</h4><p>申请虚拟信用卡的难度会比正常信号用卡低，国内不知道还能不能申请，查了几个银行都没有，<a href="https://zhidao.baidu.com/question/495042755475833292.html">中国银行</a>，<a href="https://zhidao.baidu.com/question/1499884976872396419.html">招商银行</a>。国外的，比如<a href="https://zhuanlan.zhihu.com/p/129760347">Easypay</a>，看评论，各种坑。</p><h4 id="淘宝购买礼品卡"><a href="#淘宝购买礼品卡" class="headerlink" title="淘宝购买礼品卡"></a>淘宝购买礼品卡</h4><p>没有信用卡的同学多数是使用礼品卡支付的吧，但淘宝购买礼品卡存在一定风险。由于经常出现信用卡盗刷的情况，亚马逊对这块管得很严，如果遇到不良淘宝商家，日亚账号可能会被封，钱也不一定能退回来。</p><h3 id="日本代理"><a href="#日本代理" class="headerlink" title="日本代理"></a>日本代理</h3><p>据说代理的<code>伪装度（匿名性）</code>不够也是有被封号的风险的。</p><p>我使用的伪装度检测网站是<a href="https://whoer.net/">whoer</a>，测试了以下两种方法：</p><h4 id="V2ray打开全局代理"><a href="#V2ray打开全局代理" class="headerlink" title="V2ray打开全局代理"></a>V2ray打开全局代理</h4><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211029125013.png" alt="20211029125013"><br>将电脑时区改为东京后<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211029125043.png" alt="20211029125043"><br>语言没有尝试修改了</p><h4 id="使用AnyConnect-VPN"><a href="#使用AnyConnect-VPN" class="headerlink" title="使用AnyConnect VPN"></a>使用AnyConnect VPN</h4><p>扣了25分，总分为何是90？<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211029125459.png" alt="20211029125459"><br>将电脑时区改为东京后，总分100了。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211029125646.png" alt="20211029125646"><br><b>vpn的伪装度比代理高，感觉挺合理的。</b></p><h3 id="将电子书传输到kindle"><a href="#将电子书传输到kindle" class="headerlink" title="将电子书传输到kindle"></a>将电子书传输到kindle</h3><p>电脑上购买好电子书后<code>（第一次购买可以用0元的书做下测试）</code>，kindle切换到日亚账号。如果电子书没有自动下载到kindle，可以将电子书下载到电脑，使用数据线传输到kindle。</p><div class="note warning simple"><p>切换和退出账号，kindle会自动清空所有已下载的电子书。</p></div><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211029192901.png" alt="20211029192901"><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211029193024.png" alt="20211029193024"></p><h3 id="直接使用kindle购买日亚电子书"><a href="#直接使用kindle购买日亚电子书" class="headerlink" title="直接使用kindle购买日亚电子书"></a>直接使用kindle购买日亚电子书</h3><p>kindle连上日本代理，商城才会是日本区的。可以尝试用以下几种方式让kindle连上代理：</p><ul><li>路由器设置代理</li><li>电脑的热点功能</li><li>手机下载可以分享代理的软件</li></ul><p>路由器得有设置代理的功能才行，或者可以尝试刷机。</p><p>电脑的热点功能，我试了v2ray全局代理+热点，kindle并没有连接代理；而连anyconnect后，电脑就开不了热点了。</p><p>手机可以去Google Play商店去下载一款叫<code>VPN 热点</code>的app，这个我试过，可以让其他设备也连上代理，但需要root权限。我现在手机没有root功能，所以就没有尝试使用kindle连接了。</p><p>其实我没有成功的直接使用kindle购买日亚电子书，毕竟可以用电脑购买，没有下功夫解决这个需求的动力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于对版权保护的重视，日文原版书在互联网上特别难找。淘宝上的kindle日亚代购收费也是贵得离谱，我只问了一家晒出来的价格还行的店铺，一本折合人民币27的书，收我50。这亏怎么能吃？&lt;/p&gt;
&lt;p&gt;说来日亚购买电子书也就几步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接日本代理&lt;/li&gt;</summary>
      
    
    
    
    <category term="教程" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="kindle" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/kindle/"/>
    
    
    <category term="kindle" scheme="https://www.itaru.xyz/tags/kindle/"/>
    
    <category term="日亚" scheme="https://www.itaru.xyz/tags/%E6%97%A5%E4%BA%9A/"/>
    
  </entry>
  
  <entry>
    <title>配置评论插件Valine的邮件提醒和后台管理系统Valine Admin</title>
    <link href="https://www.itaru.xyz/blogs/bfcce7e4.html"/>
    <id>https://www.itaru.xyz/blogs/bfcce7e4.html</id>
    <published>2021-10-25T03:37:57.000Z</published>
    <updated>2021-11-02T03:43:11.854Z</updated>
    
    <content type="html"><![CDATA[<p>配置Valine Admin首先得配置好valine，我使用的是butterfly主题，所以用<a href="https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96">主题配置文档</a>中的配置方法。方法是<a href="https://valine.js.org/quickstart.html">先注册个leancloud账号<code>（如果域名未备案，请使用国际版）</code>，创建应用，将APP ID和APP Key添加到</a>主题的_config.yml配置文件中即可。不同的主题，配置方式也会有些不同。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025114940.png" alt="20211025114940"><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025145225.png" alt="20211025145225"><br>leancloud自带的后台管理功能不是很友好，是以数据库中表的形式一样展示的。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025145528.png" alt="20211025145528"><br>所以需要再架设个管理系统。Valine Admin是个带有邮件提醒功能的Valine后台管理系统<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025160109.png" alt="20211025160109"></p><h3 id="配置Valine-Admin"><a href="#配置Valine-Admin" class="headerlink" title="配置Valine Admin"></a>配置Valine Admin</h3><p><a href="https://github.com/DesertsP/Valine-Admin">Valine Admin说明文档</a>中有详细的配置说明，但对于我这个才接触leancloud的小白来说，还是看得一头雾水，踩了不少坑，所以打算写下来。<br><code>云引擎-&gt;WEB-&gt;设置</code>，以下几个参数得注意下<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025150715.png" alt="20211025150715"></p><h4 id="SITE-URL"><a href="#SITE-URL" class="headerlink" title="SITE_URL"></a>SITE_URL</h4><p>后面别加<code>/</code>，比如我这网站填<code>https://www.itaru.xyz</code>，而不是<code>https://www.itaru.xyz/</code>，这个url是用来和下图字段拼接生成评论所在的具体url的。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025151308.png" alt="20211025151308"></p><h4 id="SMTP-PASS"><a href="#SMTP-PASS" class="headerlink" title="SMTP_PASS"></a>SMTP_PASS</h4><p>如果是用的qq邮箱，填的是开启POP3/SMTP服务之后提供的授权码，而不是独立密码。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211027170624.png" alt="20211027170624"><br>说明中有一句<code>QQ邮箱需要获取独立密码</code>，我以为是填独立密码。于是报了<code>Error: Invalid login: 535 Login Fail. Please enter your authorization code to login</code>错误。文档的意思也许是，你需要开启独立密码登录功能，但这边使用SMTP登录密码登录邮箱。。</p><h4 id="ADMIN-URL"><a href="#ADMIN-URL" class="headerlink" title="ADMIN_URL"></a>ADMIN_URL</h4><p>这个是后台管理页面的url，需要先在<code>设置-&gt;域名绑定</code>中绑定域名。域名可以是<code>xxx.YourDomain</code>的形式。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025160333.png" alt="20211025160333"><br>第一次绑定时，会提示你配置DNS，即配置CNAME<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025160912.png" alt="20211025160912"><br>如果是非国际版的leancloud，则会检查域名是否备案。所以开头提前说明，域名没有备案，得用国际版。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025161129.png" alt="20211025161129"></p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>设置完参数后<code>部署</code><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025162407.png" alt="20211025162407"><br>部署成功后，域名加上/sign-up注册用户后，<code>我这是 https://leancloud.itaru.xyz/sign-up</code>，即可登录后台管理系统查看评论。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025161615.png" alt="20211025161615"><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211025221523.png" alt="20211025221523"><br>另外：体验实例有<a href="https://leancloud.cn/docs/leanengine_plan.html#:~:text=%E4%BD%93%E9%AA%8C%E5%AE%9E%E4%BE%8B%E5%9C%A8%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E7%AD%89%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C%E6%97%B6%E4%BC%9A%E6%9A%82%E5%81%9C%E6%9C%8D%E5%8A%A1%E3%80%82%20%E5%90%8C%E6%97%B6%20%E4%BD%93%E9%AA%8C%E5%AE%9E%E4%BE%8B%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%BC%91%E7%9C%A0%E7%AD%96%E7%95%A5%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%AF%B7%E6%B1%82%E6%97%B6%E4%BC%9A%E4%BC%91%E7%9C%A0%EF%BC%8C%E6%9C%89%E8%AF%B7%E6%B1%82%E6%97%B6%E5%90%AF%E5%8A%A8%EF%BC%88%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E5%8D%81%E5%87%A0%E7%A7%92%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89%EF%BC%8C%E6%AF%8F%E5%A4%A9%E6%9C%80%E5%A4%9A%E8%BF%90%E8%A1%8C%2018%20%E4%B8%AA%E5%B0%8F%E6%97%B6">休眠策略</a>，需要设置<a href="https://github.com/DesertsP/Valine-Admin#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE">定时任务</a>。</p><div class="note info simple"><p>参数配置错误，修改参数后重新部署才会生效。未收到邮件，可查看日志看是否有报错信息。</p></div> ]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;配置Valine Admin首先得配置好valine，我使用的是butterfly主题，所以用&lt;a href=&quot;https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96&quot;&gt;主题配置文档&lt;/a&gt;中的配置方法。方法是&lt;</summary>
      
    
    
    
    <category term="教程" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo/"/>
    
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用gulp和jsdelivr加快GitHub中搭建的hexo博客的访问速度</title>
    <link href="https://www.itaru.xyz/blogs/1839fcb6.html"/>
    <id>https://www.itaru.xyz/blogs/1839fcb6.html</id>
    <published>2021-10-22T06:49:18.000Z</published>
    <updated>2021-12-13T13:11:25.354Z</updated>
    
    <content type="html"><![CDATA[<p>如果域名已经备案，加快github搭建的hexo博客的访问速度的最好的方法是使用国内厂商提供的CDN。本博客使用的域名目前没有备案，所以用别的方式加速网站的访问。</p><h3 id="使用gulp压缩HTML、JS、CSS文件和图片"><a href="#使用gulp压缩HTML、JS、CSS文件和图片" class="headerlink" title="使用gulp压缩HTML、JS、CSS文件和图片"></a>使用gulp压缩HTML、JS、CSS文件和图片</h3><p>不喜欢重复造轮子，直接贴出我认为写得比较好的文章 <a href="https://blog.imzjw.cn/posts/b74f504f/#:~:text=gulp%20%E5%8E%8B%E7%BC%A9">gulp 压缩</a>。</p><p>以 css\index.css 查看其效果。</p><p>压缩前：<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211022145941.png" alt="20211022145941"><br>压缩后:<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211022150029.png" alt="20211022150029"></p><p>主页访问速度</p><div class="note simple"><p>即使有勾选清空缓存，每次刷新网页访问速度都会有差别，有时差别还特别大。这边截取的是我认为比较有代表性的两张图。总的来说，访问速度有提高，压缩率越高，访问速度提高得也越多。</p></div><p>压缩前：<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211022151514.png" alt="20211022151514"><br>压缩后：<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211022151529.png" alt="20211022151529"></p><h3 id="使用jsdelivr提供的免费CDN加速JS、CSS文件和图片"><a href="#使用jsdelivr提供的免费CDN加速JS、CSS文件和图片" class="headerlink" title="使用jsdelivr提供的免费CDN加速JS、CSS文件和图片"></a>使用jsdelivr提供的免费CDN加速JS、CSS文件和图片</h3><a href="/blogs/e7630f6f.html" title="GitHub图床被墙的解决方案">GitHub图床被墙的解决方案</a>的方案二有提到使用jsdelivr加速图床，其实jsdelivr还可以用来加速博客中的文件。<p>在主题的_config.yml的配置文件中的JS、CSS文件和图片的相对路径前添加</p><pre>https://cdn.jsdelivr.net/gh/YourGithubName/blogRepoName</pre><p>包括但不限于以下几项：<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211022152107.png" alt="20211022152107"><br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211022152124.png" alt="20211022152124"><br>这个方法加速还是挺明显的<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211022152348.png" alt="20211022152348"></p><div class="note warning simple"><p>这个方法会导致本地调试时也访问github中的相应文件。相应文件在本地有改动时，本地调试使用的还是github上的版本。</p></div><p>后来又发现了个问题，jsdelivr会在第一次访问某url时去获取github中相应的文件，然后缓存起来，之后访问会使用缓存的文件。也就是说，<a href="https://github.com/BNDong/Cnblogs-Theme-SimpleMemory/issues/42">更新的文件不会立即生效</a>，官方文档中说大概<a href="https://github.com/jsdelivr/jsdelivr#:~:text=Branches%20-%2012%20hours">12小时更新一次缓存</a>。<code>如果想要即时生效，得更改文件的名字，如将index.css改为index1.1.css，_config.yml中设置的url也得一并改。</code></p><p><a href="https://zhuanlan.zhihu.com/p/336641644#:~:text=%E6%9B%B4%E6%96%B0%E4%B8%80%E6%AC%A1%E5%B0%B1%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%8B%E7%89%88%E6%9C%AC">这里还有个常用的方法</a>，这个方法每次更新或新增都得release新版本。更改其中一个css文件就得release这一点，感觉会比上述方法麻烦。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果域名已经备案，加快github搭建的hexo博客的访问速度的最好的方法是使用国内厂商提供的CDN。本博客使用的域名目前没有备案，所以用别的方式加速网站的访问。&lt;/p&gt;
&lt;h3 id=&quot;使用gulp压缩HTML、JS、CSS文件和图片&quot;&gt;&lt;a href=&quot;#使用gulp压</summary>
      
    
    
    
    <category term="教程" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo/"/>
    
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>GitHub图床被墙的解决方案</title>
    <link href="https://www.itaru.xyz/blogs/e7630f6f.html"/>
    <id>https://www.itaru.xyz/blogs/e7630f6f.html</id>
    <published>2021-10-18T02:57:39.000Z</published>
    <updated>2021-10-30T14:09:08.430Z</updated>
    
    <content type="html"><![CDATA[<p>我是参考 <a href="https://blog.csdn.net/qq_43827595/article/details/104274769">10分钟配置 VScode插件picgo + github免费图床，实现Markdown写作高效插图</a> 这篇文章搭建图床的。教程写的很清楚，搭建得顺利。但picgo插件提供的默认域名 <code>raw<span>.</span>githubusercontent<span>.</span>com</code>被墙了，大陆无法加载图片。于是寻找解决方法。</p><div class="note info simple"><p>方法一算是我踩得一个坑，但也挺有借鉴意义的。方法二才是真正简便高效的解决方案。直接看<a href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E4%BD%BF%E7%94%A8jsdelivr">方法二</a>也无妨。</p></div><h3 id="方法一-给图床添加自定义域名"><a href="#方法一-给图床添加自定义域名" class="headerlink" title="方法一 给图床添加自定义域名"></a>方法一 给图床添加自定义域名</h3><h4 id="给图床repo添加CNAME和index-html-两个文件夹"><a href="#给图床repo添加CNAME和index-html-两个文件夹" class="headerlink" title="给图床repo添加CNAME和index.html 两个文件夹"></a>给图床repo添加CNAME和index.html 两个文件夹</h4><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/1634526849(1).png" alt="1634526849(1)"><br>CNAME中添加自定义域名，indxe.html可以为空也可以是任意内容。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211018111942.png" alt="20211018111942"></p><h4 id="DNS域名解析添加CNAME"><a href="#DNS域名解析添加CNAME" class="headerlink" title="DNS域名解析添加CNAME"></a>DNS域名解析添加CNAME</h4><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211018112439.png" alt="20211018112439"><br>不添加这个，域名会ping不通。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211019163405.png" alt="20211019163405"><br>少了这一步直接配置网站的话，github中也会提示出错。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211019162717.png" alt="20211019162717"><br>等待3、4分钟，直到域名能ping通。<br><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211019163510.png" alt="20211019163510"></p><h4 id="repo设置网站"><a href="#repo设置网站" class="headerlink" title="repo设置网站"></a>repo设置网站</h4><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/1634527597(1).png" alt="1634527597(1)"><br>配置完成后，等待几秒github布置网站。打开网站看是否生效，<code>我这是 <a href="https://ih.itaru.xyz/">https://ih.itaru.xyz/</a></code>。</p><h4 id="将vscode中picgo插件设置github的Customer-Url改为自己的域名"><a href="#将vscode中picgo插件设置github的Customer-Url改为自己的域名" class="headerlink" title="将vscode中picgo插件设置github的Customer Url改为自己的域名"></a>将vscode中picgo插件设置github的Customer Url改为自己的域名</h4><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211018113429.png" alt="20211018113429"></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>这样一来，图床可以以原先就行的<code><a href="https://raw.githubusercontent.com/simpleworldz/ImageHost/master/images/kyojin.png">https://raw.githubusercontent.com/simpleworldz/ImageHost/master/images/kyojin.png</a></code><br>和后来添加的<br><code><a href="https://ih.itaru.xyz/images/kyojin.png">https://ih.itaru.xyz/images/kyojin.png</a></code><br>两种形式访问。后者没有被墙。</p><p>为什么说是这方法是我踩得一个坑，因为虽然不被墙了，但github的服务器在海外，大陆加载图片特别慢，一张1M的图片需要加载10几秒。</p><p>提速可以使用CDN，这个被我放弃了，<a href="/blogs/859740d4.html" title="网站备案 从开始到放弃">网站备案 从开始到放弃</a> 这篇文章有说明原因。还有一种解决方案是再在coding中布置一个相同的博客网站，coding的服务器大陆访问比较快，用于大陆节点的访问，github中的网站用户海外节点的访问。</p><h3 id="方法二-使用jsdelivr"><a href="#方法二-使用jsdelivr" class="headerlink" title="方法二 使用jsdelivr"></a>方法二 使用jsdelivr</h3><p>方法一结尾提到的两种改善访问速度的方法都不是很想用，想可否用更换图床插件的方式解决。于是注意到了一开始就看到，但是被我忽略的那篇文章， <a href="https://blog.csdn.net/qq_41121080/article/details/105565405">VSCode + Github + Picgo + jsDelivr 搭建稳定快速高效图床</a> 。一开始没用这篇文章的原因是开头提到的那篇文章写得比较仔细。</p><p><b>没啥要做的，就一步，将vscode中picgo插件设置github的Customer Url改为 </b></p><pre>https://cdn.jsdelivr.net/gh/YourGithubName/RepoName</pre><p><img src="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/20211018161358.png" alt="20211018161358"></p><p>生成的url示例<br><code><a href="https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/kyojin.png">https://cdn.jsdelivr.net/gh/simpleworldz/ImageHost/images/kyojin.png</a></code></p><p>方法一和方法二不冲突，如果做了方法一只是让图床中的图片多了一种访问方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我是参考 &lt;a href=&quot;https://blog.csdn.net/qq_43827595/article/details/104274769&quot;&gt;10分钟配置 VScode插件picgo + github免费图床，实现Markdown写作高效插图&lt;/a&gt; 这篇文章搭建图</summary>
      
    
    
    
    <category term="教程" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo/"/>
    
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>网站备案 从开始到放弃</title>
    <link href="https://www.itaru.xyz/blogs/859740d4.html"/>
    <id>https://www.itaru.xyz/blogs/859740d4.html</id>
    <published>2021-10-16T08:22:19.000Z</published>
    <updated>2021-11-02T03:43:11.854Z</updated>
    
    <content type="html"><![CDATA[<p>今天想给网站做个CDN，以提高国内的访问速度。据说github搭建的网站访问速度不是很给力。我自己的访问速度倒是还行，奈何可能其他省份，其他运营商的网访问速度欠佳呢。在腾讯云的CDN中添加域名，提示域名没有备案，于是打算去备案。</p><h3 id="开始备案"><a href="#开始备案" class="headerlink" title="开始备案"></a>开始备案</h3><p>腾讯云有自带的备案系统，录入信息时又发现备案需要云服务器，而我没有购买云服务器。那么，就去寻找别的域名备案的方法。</p><p>半个小时过去了，竟是找不到代替的备案方式。渐渐烦躁，没道理啊，备案很多人做，那么网上应该有很多教程才对。我以前也有过类似的经历，一个很多人使用的工具报错了，网上却怎么也找不到解决方案。毫无例外都是我犯了如名称、格式搞错了，或者是按着教程做，却漏了一步之类的低级错误。</p><div class="note blue no-icon simple"><p>当一个你认为是很普遍的问题，却在网上怎么也找不到解决方法时，往往是你犯了特别低级的错误，或者是前提条件就是错的。</p></div><p>该不会是<code>备案域名，必须购买一台云服务器</code>？网上说是或不是的说法都有，说是的比较多，我感觉必须要有服务器的论调比较可信。说不需要的人，你倒是给个方法啊。我半天都没搜。</p><h3 id="放弃备案"><a href="#放弃备案" class="headerlink" title="放弃备案"></a>放弃备案</h3><p><b>服务器在海外的网站，本就不用备案，基于github的博客是不用备案的。</b><code>写到这边，我发现个华点，既然需不需要备案和服务器所在地址有关，那备案看来是真的需要一台服务器。</code>备案所需时间大概需要20-30天，这期间是不能使用域名的。有人通过租用短期服务器的方法给网站备案，但这也有被回收备案的风险。还有人说一台服务器有5个备案号，可以备案5个域名，可以向已有云服务器的人要。</p><p>hexo有些插件是必须域名备案后才能使用的，并且国内的一些服务，如CDN和微信小程序衔接之类的需要备案。</p><p><b>对于我这个新生不到一周的小小个人网站，还是先把备案一事放一放吧，以后再看有没有必要。</b></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天想给网站做个CDN，以提高国内的访问速度。据说github搭建的网站访问速度不是很给力。我自己的访问速度倒是还行，奈何可能其他省份，其他运营商的网访问速度欠佳呢。在腾讯云的CDN中添加域名，提示域名没有备案，于是打算去备案。&lt;/p&gt;
&lt;h3 id=&quot;开始备案&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="教程" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>本站点的搭建</title>
    <link href="https://www.itaru.xyz/blogs/2116d0e1.html"/>
    <id>https://www.itaru.xyz/blogs/2116d0e1.html</id>
    <published>2021-10-15T07:37:40.000Z</published>
    <updated>2021-10-30T13:59:39.718Z</updated>
    
    <content type="html"><![CDATA[<p>查询v2ray如何配置pac时发现了这个站点：<a href="https://www.zyskys.com/">零奇部落阁</a>。好羡慕他们拥有自己的站点。正好裸辞在家，想过段时间再去找工作，有不少闲暇时间，就开始搭建自己的站点了。</p><div class="note blue no-icon simple"><p>以前公司给我钱，我为公司工作；现在没人给我钱了，我为自己做事。</p></div><h3 id="搭建方式的选择"><a href="#搭建方式的选择" class="headerlink" title="搭建方式的选择"></a>搭建方式的选择</h3><p>我以为搭建站点需要自己购买服务器，一开始的方向是在找便宜且稳定，最好是国内访问速度也还行的服务器。腾讯云和阿里云都太贵了，1M带宽的会比较便宜，但也只是活动价。并且想想1M带宽加载文字还行，加载图片那不得太慢了吧。还是决定购买国外的vps。国外的vps带宽是1G起步的，价格是5美元起步，一年将近400块，想想还是肉疼的。vultr美国个别地区的机房有2.5美元一个月的，但只限ipv6，不懂这对网站的布置会有什么限制。</p><p><b>外国服务器有被墙的风险</b>，据说vultr和搬瓦工是重灾区。为了架设ssr，大概3年前我在vultr中购买过vps，感觉这个vps提供商还不错。并且网上查到了一些可以规避被墙的办法，想想还可以顺带布置下v2ray。于是在vultr购买了一台东京的5美元一个月的服务器，直接选用自带的wordpress。</p><p><b>这台位于东京的服务器，ping值不是很高，100左右，丢包80%左右，丢包率比以前高多了。</b>访问wordpress时快时慢，有时得转好久。由于vultr是按时间计费的，对当前vps不满，完全可以换一台服务器，不产生额外费用。但最终我没这么选择，感觉wordpress庞大笨重了点，更关键的是，没找到自己喜欢的<code>主题</code>。</p><p>于是我去了解了下<code>hexo</code>。一开始我以为hexo和wordpress是差不多的，这时才发现，他们完全不一样。布置wordpress网站，你得有独立的服务器，但是hexo网站，可以通过github或者coding布置网站。省去购买vps的钱，以及维护vps的时间。并且，<code>主题也比较好看</code>。文章开头提到的那个网站，也是用hexo的搭建的。</p><p>那还有什么好犹豫的呢，直接上hexo。</p><p>对比wordpress的傻瓜试的点几下鼠标就将能一个网站的大致框架布置好。hexo还是比较复杂点的。</p><h3 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h3><p>只需要购买域名的费用，普通的第一年几块到几十不等，续费会比较贵，但也就几十到一百几。如果是靓号，那多贵的都有。如果你选择使用github提供的<code>YourGithubName.github.io</code>形式的域名的话，那么连购买域名也省了。</p><h3 id="搭建网站"><a href="#搭建网站" class="headerlink" title="搭建网站"></a>搭建网站</h3><p>其实参考<a href="https://www.nesxc.com/post/hexo.html">nesxc的hexo安装教程</a>的第一部分就行，我参考了好几篇hexo教程，这篇是写得最好最详细的。完成了第一部分，其实网站框架就搭建成功了，你可以通过<code>http:<span>//</span>YourGithubName<span>.</span>github<span>.</span>io</code>访问你的网站。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>可以参考这个，<a href="https://www.zhihu.com/question/31377141/answer/103056861">github怎么绑定自己的域名</a>。</p><h3 id="网站更换主题、添加功能以及美化"><a href="#网站更换主题、添加功能以及美化" class="headerlink" title="网站更换主题、添加功能以及美化"></a>网站更换主题、添加功能以及美化</h3><p>如果你和我一样选择的是<code>butterfly</code>可以参考官方网站<a href="https://butterfly.js.org/">butterfly</a>。每个主题都应该有自己的官方网站，照着做就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查询v2ray如何配置pac时发现了这个站点：&lt;a href=&quot;https://www.zyskys.com/&quot;&gt;零奇部落阁&lt;/a&gt;。好羡慕他们拥有自己的站点。正好裸辞在家，想过段时间再去找工作，有不少闲暇时间，就开始搭建自己的站点了。&lt;/p&gt;
&lt;div class=&quot;no</summary>
      
    
    
    
    <category term="教程" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/"/>
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/categories/%E6%95%99%E7%A8%8B/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo/"/>
    
    
    <category term="博客搭建" scheme="https://www.itaru.xyz/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="hexo" scheme="https://www.itaru.xyz/tags/hexo/"/>
    
  </entry>
  
</feed>
