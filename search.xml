<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASP.NET Web API 学习笔记</title>
      <link href="/blogs/c0792448.html"/>
      <url>/blogs/c0792448.html</url>
      
        <content type="html"><![CDATA[<p>教程网址：<a href="https://www.tutorialsteacher.com/webapi">TutorialSteacher - ASP.NET Web API Tutorials</a></p><p>ASP.NET Web API 是用于构建可从任何客户端（包括浏览器和移动设备）访问的 HTTP 服务的框架。它是在 .NET Framework 上构建 RESTful 应用程序的理想平台。</p><p>它的工作方式或多或少与 ASP.NET MVC Web 应用程序相同，不同之处在于它将数据作为响应而不是发送 html 视图。它就像一个 webservice 或 WCF 服务，但例外是它只支持 HTTP 协议。</p><h3 id="ASP-NET-Web-API-特性"><a href="#ASP-NET-Web-API-特性" class="headerlink" title="ASP.NET Web API 特性"></a>ASP.NET Web API 特性</h3><ul><li>ASP.NET Web API 建立在 ASP.NET 之上，支持 ASP.NET 请求/响应管道</li><li>ASP.NET Web API 将 HTTP 动词映射到方法名称。</li><li>ASP.NET Web API 支持不同格式的响应数据。内置支持 JSON、XML、BSON 格式。</li><li>ASP.NET Web API 可以托管在 IIS 中、自托管或托管在其他支持 .NET 4.0+ 的 Web 服务器中。</li></ul><p><a href="https://www.tutorialsteacher.com/webapi/what-is-web-api#:~:text=ASP.NET%20Web%20API%20vs%20WCF">ASP.NET Web API vs WCF</a></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li>ASP.NET Web 应用程序 -&gt; Empty -&gt; 勾选 Web API。<br><img src="https://ih.itaru.xyz/images/20211227154117.png" alt="20211227154117"></li><li>也可以创建项目时选择 Web API，这个选项中 Web API 和 MVC 是默认无法取消勾选的。创建的项目和默认的 MVC 项目基本相同。具有两个特定的 Web API 文件，App_Start 文件夹中的 <code>WebApiConfig.cs</code> 和 Controllers 文件夹中的 <code>ValuesController.cs</code>。以及 Area 中多了 <code>HelpPage</code>（这个可以用来生成测试样例）。<br><img src="https://ih.itaru.xyz/images/20211227154028.png" alt="20211227154028"></li><li>可在 NuGet 中查看当前 WebAPI 版本。</li></ul><h3 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h3><ul><li>Fiddler</li><li>Postman</li></ul><h3 id="配置-Web-API"><a href="#配置-Web-API" class="headerlink" title="配置 Web API"></a>配置 Web API</h3><ul><li>Web API 支持基于代码的配置（在 HttpConfiguration 中配置）。它不能在 web.config 文件中配置。</li><li>我们可以配置 Web API 来自定义 Web API 托管基础架构和组件的行为，例如路由、格式化程序、过滤器、DependencyResolver、MessageHandlers、ParamterBindingRules、属性、服务等。</li><li>可用 WebApiConfig.Register(HttpConfiguration config) 中的 config 重写默认配置。<a href="https://www.tutorialsteacher.com/webapi/configure-web-api#:~:text=override%20the%20default%20behaviour%20of%20Web%20API">HttpConfiguration</a></li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li>默认形式 api/{controller}/{id}</li><li>在路由模板中使用 api 的原因只是为了避免混淆 MVC 控制器和 Web API 控制器。您可以根据您的应用程序架构使用任何模式。</li><li>WebApiConfig 的 Register 加上 config.MapHttpAttributeRoutes() （默认就有的），可以使用 <code>[Route(&quot;api/student/names&quot;)]</code> 路由特性。</li></ul><h3 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h3><ul><li>和 <a href="/blogs/cd7c564f.html#%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D">MVC</a> 区别很大</li><li>默认情况下，如果参数类型是 .NET 原始类型，例如 int、bool、double、string、GUID、DateTime、decimal 或任何其他可以从 string 类型转换的类型，那么它会从 Url 中取值。如果参数类型是复杂类型，那么 Web API 会默认尝试从<code>请求体</code>中获取值。</li><li>用 Postman 测试时，POST 请求提交数据不能用 from-data，得用 raw -&gt; JSON（或 raw -&gt; 其他 WebAPI 支持的类型）。<br><img src="https://ih.itaru.xyz/images/20211228153229.png" alt="20211228153229"></li><li>请求体中的数据只会匹配到一个复杂类型中。类型中存在的字段则赋值，不存在的则忽略。</li><li>若 Action 方法参数中有多个复杂体，请求时会抛异常。</li><li><code>[FromUri]</code> 可让复杂类型从 Url 中取值，视作简单类型。<code>[FromBody]</code> 可以让原始类型从请求体中取值，视作复杂类型。<code>注意上一条。</code></li><li>GET 请求其实也可以取请求体中的数据，参数匹配逻辑其实和 POST 一样。（不过，正常 GET 请求不会带请求体，Postman 倒是可以。）</li></ul><p><img src="https://ih.itaru.xyz/images/20211228154753.png" alt="20211228154753"></p><h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><ol><li>Void： 204 “No Content”</li><li>原始类型或复杂类型：原始类型直接返回值，复杂类型返回 Json（可以设置为其他的）。</li><li>HttpResponseMessage：Web API 控制器始终返回这个类型（意思是说 前面两种都会自动封装成这个类型吗？）。<a href="https://www.asp.net/media/4071077/aspnet-web-api-poster.pdf">aspnet-web-api-poster</a><ul><li>从 Action 返回 HttpResponseMessage 的优点是您可以按照自己的方式配置响应。您可以根据需要设置状态代码、内容或错误消息。</li><li>Request.CreateResponse(HttpStatusCode.<code>NotFound</code>, <code>id</code>)，404 Not Found 都可以返回 id。</li></ul></li><li>IHttpActionResult：可以创建自己的类来实现 IHttpActionResult 或使用 ApiController 类的<a href="https://www.tutorialsteacher.com/webapi/action-method-return-type-in-web-api#:~:text=that%20implements%20IHttpActionResult%20interface">各种方法</a>（NotFound()，Ok() 等），返回实现 IHttpActionResult 的对象。</li></ol><h3 id="请求-响应数据格式"><a href="#请求-响应数据格式" class="headerlink" title="请求/响应数据格式"></a>请求/响应数据格式</h3><ul><li>在 HTTP 请求中，使用 Accept 和 Content-Type 属性在请求头中指定 MIME 类型。</li><li>Accept 头属性指定客户端期望的响应数据格式，Content-Type 头属性指定请求正文中数据的格式，以便接收者可以将其解析为适当的格式。</li><li><code>Web API 根据请求头（报文头）的 Content-Type 解析请求体（request body 或 报文体），根据 Accept 确定返回的数据格式，</code>返回中也包括 Content-Type。Web API 默认处理 JSON 和 XML 数据。</li><li>Web API 将请求数据转换为 CLR 对象，并将 CLR 对象序列化为基于 Accept 和 Content-Type 标头的响应数据。</li><li>Web API 包括对 JSON、XML、BSON 和 form-urlencoded 数据的内置支持。</li></ul><h4 id="Media-Type-Formatters"><a href="#Media-Type-Formatters" class="headerlink" title="Media-Type Formatters"></a>Media-Type Formatters</h4><ul><li>媒体类型格式化程序是负责序列化请求/响应数据的类，以便 Web API 可以理解请求数据格式并以客户端期望的格式发送数据。</li><li>GlobalConfiguration.Configuration.Formatters</li><li>可以在 WebApiConfig 中设置返回的 json 的格式，例如将命名从 Pascal 改为 Camel 等。（xml 等格式应该也可以设置。）</li><li>WebAPI 中 JSON 使用 <code>Json.NET</code> 序列化和反序列化，xml 使用 <code>System.Runtime.DataContractSerializer</code>。</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>添加控制器时有 MVC 和 WebAPI 两种控制器可供选择，选择 WebAPI 控制器。</li><li>它可以在项目根文件夹中的任何文件夹下创建。但是，建议按照约定在 Controllers 文件夹中创建控制器类。</li><li><a href="https://www.tutorialsteacher.com/webapi/web-api-controller#:~:text=Difference%20between%20Web%20API%20and%20MVC%20controller">Difference between Web API and MVC controller</a></li></ul><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><ul><li>控制器的所有公共方法都称为行为方法（Action）。</li><li>行为名称可以与 HTTP 动词名称相同，也可以以 HTTP 动词开头（区分大小写）加后缀，或者将 Http 动词特性（ <code>[HttpPost]</code> 等）应用于行为。</li><li>动作方法的返回类型可以是任何原始类型或复杂类型。</li><li><code>同一 HTTP 动词</code>不能有多个 Action 同时具有<code>相同数量</code>的<code>相同类型</code>和<code>相同参数名</code>的参数（参数名会根据你传过来的数据的名称匹配）。即使一个控制器中有多个 GET Action，Web API 可以根据请求的参数区分到底执行哪个 Action。</li></ul><h3 id="Web-API-Filters"><a href="#Web-API-Filters" class="headerlink" title="Web API Filters"></a>Web API Filters</h3><ul><li>Web API 包括过滤器，用于在 Action 之前或之后添加额外的逻辑。过滤器可用于提供横切功能，例如日志记录、异常处理、性能检测、身份验证和授权。</li><li>过滤器实际上是可以应用于 Web API 控制器和一种或多种行为的特性。每个过滤器特性类都必须实现包含在 System.Web.Http.Filters 命名空间中的 IFilter 接口（或继承于它的接口，如 IActionFilter）。</li><li><a href="https://www.tutorialsteacher.com/webapi/web-api-filters#:~:text=lists%20important%20interfaces%20and%20classes">System.Web.Http.Filters 中内置的重要接口和类</a></li><li><code>可以继承 ActionFilterAttribute 并重写部分方法；或者继承 IActionFilter ，实现所有方法。</code><br>LogAttribute : ActionFilterAttribute 或 LogAttribute : Attribute, IActionFilter。</li></ul><h4 id="IAuthenticationFilter-和-IAuthorizationFilter-的区别"><a href="#IAuthenticationFilter-和-IAuthorizationFilter-的区别" class="headerlink" title="IAuthenticationFilter 和 IAuthorizationFilter 的区别"></a>IAuthenticationFilter 和 IAuthorizationFilter 的区别</h4><ul><li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.mvc.filters.iauthenticationfilter?view=aspnet-mvc-5.2">IAuthenticationFilter</a> 进行身份过滤。<code>Authentication 身份验证</code>。例如，Alice 使用她的用户名和密码登录，服务器使用该密码对 Alice 进行身份验证。</li><li><a href="https://docs.microsoft.com/en-us/dotnet/api/system.web.mvc.iauthorizationfilter?view=aspnet-mvc-5.2">IAuthorizationFilter</a> 进行权限过滤。<code>Authorization 授权</code>。决定是否允许用户执行某项操作，例如，Alice 有权获取资源但不能创建资源。</li></ul><p>参考：<a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/authentication-and-authorization-in-aspnet-web-api">Authentication and Authorization in ASP.NET Web API</a></p><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><ul><li>不推荐从 Web API 返回 EF 实体对象，建议用 DTO（Data Transfer Object 数据传输对象）。<ol><li>即不返回和接收 EF Models 中的类（如 SchoolDBEntities 中的 Student），而是在 Web API 的 Models 中自己创建相关类与外部对接（如 StudentViewModel）。</li><li>ViewModel 类或 DTO 类仅用于从 Web API 控制器到客户端的数据传输。您可以根据自己的选择命名。</li></ol></li><li>根据 Web API 命名约定，以单词“Get”开头（如：GetAllStudents）的 Action 将处理 HTTP GET 请求，提高可读性。</li><li>HTTP POST 请求用于在 RESTful 架构中的数据源中创建新记录。HTTP PUT 方法用于更新现有记录。</li><li>同 MVC 一样，可以用 <code>ModelState.IsValid</code> 检测数据的有效性。</li><li>删除 <code>System.Data.Entity.EntityState.Deleted</code>（记得好像也可以直接用 <code>Remove()</code> 的）。</li></ul><h3 id="HttpClient"><a href="#HttpClient" class="headerlink" title="HttpClient"></a>HttpClient</h3><p>.NET 2.0 包含 <code>WebClient</code> 类以使用 HTTP 协议与 Web 服务器通信。但是，WebClient 类有一些限制。.NET 4.5 包含 <code>HttpClient</code> 类以克服 WebClient 的限制。</p><ul><li><p>从 TOOLS -&gt; NuGet Package Manager -&gt; Package Manager Console 打开 NuGet 包管理器控制台并执行以下命令：</p><p>  <code>Install-Package Microsoft.AspNet.WebApi.Client</code></p></li><li><p>GetAsync ReadAsAsync PostAsJsonAsync 以及其他<a href="https://www.tutorialsteacher.com/webapi/consuming-web-api-in-dotnet-using-httpclient#:~:text=The%20following%20table%20lists%20all%20the%20methods%20of%20HttpClient%20to%20send%20different%20HTTP%20requests.">HttpClien的方法</a>。</p></li></ul><h3 id="访问-Web-API"><a href="#访问-Web-API" class="headerlink" title="访问 Web API"></a>访问 Web API</h3><p>Web API 可以在 .NET 的服务器端代码中访问，也可以在客户端使用 JavaScript 框架（如 jQuery、AnguarJS、KnockoutJS 等）访问。（其实只要能发送 HTTP 请求，都能访问。）</p><h3 id="Web-API-配置依赖注入"><a href="#Web-API-配置依赖注入" class="headerlink" title="Web API 配置依赖注入"></a>Web API 配置依赖注入</h3><ul><li>有很多 IoC 容器可用于依赖注入，例如 Ninject、Unity、castleWidsor、structuremap 等，这里我们将<a href="https://www.tutorialsteacher.com/webapi/configure-dependency-injection-with-web-api#:~:text=The%20following%20is%20our%20sample%20Web%20API%20that%20uses%20instance%20of%20a%20class%20that%20implements%20IRepository.">使用 Ninject 进行依赖注入</a>。</li></ul><ol><li>NuGet 安装 WebApiContrib.IoC.Ninject 和 Ninject.Extensions.ChildKernel。</li><li>创建一个实现 IDependencyResolver 接口的解析器类，如 NinjectResolver。</li><li>WebApiConfig 的 Register 方法中设置 config.DependencyResolver = new NinjectResolver()。</li></ol><h3 id="Web-API-托管"><a href="#Web-API-托管" class="headerlink" title="Web API 托管"></a>Web API 托管</h3><ol><li>IIS 托管</li><li>自托管</li></ol><h4 id="自托管"><a href="#自托管" class="headerlink" title="自托管"></a>自托管</h4><p>可以将 Web API 作为独立于 ASP.NET 的进程托管。这意味着您可以在控制台应用程序、Windows 服务、OWIN 或任何其他由 .NET 框架管理的进程中托管 Web API。</p><p>需要执行以下步骤才能自托管 Web API：</p><ol><li>使用 HttpConfiguration 配置 Web API。</li><li>创建 HttpServer 并开始监听传入的 http 请求。</li></ol><p><a href="https://www.tutorialsteacher.com/webapi/web-api-hosting#:~:text=Let's%20see%20how%20to%20host%20a%20simple%20Web%20API%20in%20console%20application.">以控制台应用程序为例</a>：</p><ol><li>创建控制台应用程序，并用 NeGet 添加 <code>Microsoft ASP.NET Web API 2.2 Self Host</code>。</li><li>在 Main() 方法中设置监听。</li></ol><h3 id="选择-Web-API-还是-MVC"><a href="#选择-Web-API-还是-MVC" class="headerlink" title="选择 Web API 还是 MVC"></a>选择 Web API 还是 MVC</h3><p>这两者差别还是挺大的，如果说只需要返回数据，选择 Web API。如果需要返回视图（页面）则选择 MVC。</p><p>如果不仅需要和浏览器交互，还需要作为 API 接口与别的程序对接，还有一种选择是 Web API + MVC。</p><p>MVC 的设计初衷是每个请求都返回一个页面，如果你想要实现页面与服务器的 ajax 交互，也可以选择 <code>ASP.NET Single Page Application</code>。</p><p><img src="https://ih.itaru.xyz/images/20220112152627.png" alt="20220112152627"></p><p><a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2013/november/asp-net-single-page-applications-build-modern-responsive-web-apps-with-asp-net#:~:text=The%20Traditional%20Page%20Lifecycle%20vs.%20the%20SPA%20Lifecycle">ASP.NET - Single-Page Applications: Build Modern, Responsive Web Apps with ASP.NET</a><br><a href="https://docs.microsoft.com/en-us/aspnet/web-forms/overview/getting-started/getting-started-with-aspnet-45-web-forms/create-the-project#:~:text=Understanding%20the%20ASP.NET%20Frameworks">Understanding the ASP.NET Frameworks</a></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> Web API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> Web API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Google SEO Mobile Usability 的问题</title>
      <link href="/blogs/2f9a9158.html"/>
      <url>/blogs/2f9a9158.html</url>
      
        <content type="html"><![CDATA[<p>最近几天网站改动了挺多，改完后 Google Search Console 提示 Mobile Usability，包括 Text too small to read、Clickable elements too close together、Content wider than screen 问题。</p><p><img src="https://ih.itaru.xyz/images/20220106152842.png" alt="20220106152842"></p><p><img src="https://ih.itaru.xyz/images/20220106154425.png" alt="20220106154425"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote><p>robots.txt 是否设置为<code>禁止爬取 js 和 css</code> 了？如果是的话，把它们设置为允许爬取即可。</p></blockquote><hr><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>试着手机访问页面，一切正常，感觉没有上述问题，至少字体还比前两天调大了。但这个问题是近两天才出现的，并且以前移动适配的网站再次检测也出了问题，应该是近两天的哪个改动带来的影响。</p><p>先是将近两天的改动一个个回退，就连字体该调多大都研究了半个小时，最终还是觉得目前的大小正好。问题没有得到解决。</p><p><strong>再次检测时注意到好多内容被 robots.txt 禁止爬取了（原先就发现了，只是一开始没有把它当做原因）。</strong></p><p><img src="https://ih.itaru.xyz/images/20220106154320.png" alt="20220106154320"></p><p>而该页面在 Google 爬虫眼里，成了这样的。</p><p><img src="https://ih.itaru.xyz/images/20220106154400.png" alt="20220106154400"></p><p>robots.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /blogs/</span><br><span class="line">Disallow: /js/</span><br><span class="line">Disallow: /css/</span><br><span class="line">Disallow: /fonts/</span><br><span class="line">Disallow: /archives/</span><br><span class="line">Disallow: /tags/</span><br><span class="line">Disallow: /categories/</span><br><span class="line">Disallow: /link/</span><br><span class="line">Disallow: /about/</span><br><span class="line">Disallow: /comments/</span><br><span class="line">Disallow: /gallery/</span><br><span class="line">Disallow: /page/</span><br></pre></td></tr></table></figure><p>改为允许爬取 js、css 和 fonts。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Allow: /</span><br><span class="line">Allow: /blogs/</span><br><span class="line">Allow: /js/</span><br><span class="line">Allow: /css/</span><br><span class="line">Allow: /fonts/</span><br><span class="line">Disallow: /archives/</span><br><span class="line">Disallow: /tags/</span><br><span class="line">Disallow: /categories/</span><br><span class="line">Disallow: /link/</span><br><span class="line">Disallow: /about/</span><br><span class="line">Disallow: /comments/</span><br><span class="line">Disallow: /gallery/</span><br><span class="line">Disallow: /page/</span><br></pre></td></tr></table></figure><p>爬取效果如下：</p><p><img src="https://ih.itaru.xyz/images/20220106154936.png" alt="20220106154936"></p><p>问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> SEO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET MVC 学习笔记</title>
      <link href="/blogs/cd7c564f.html"/>
      <url>/blogs/cd7c564f.html</url>
      
        <content type="html"><![CDATA[<p>教程网址：<a href="https://www.tutorialsteacher.com/mvc">TutorialSteacher - ASP.NET MVC Tutorials</a></p><p>ASP.NET MVC <code>5</code> 是一个基于模型-视图-控制器 (MVC) 架构的 Web 框架。开发人员可以使用 ASP.NET MVC 框架构建动态 Web 应用程序，该框架实现了关注点的清晰分离、快速开发和 TDD 友好。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ul><li>路由设置中 UrlParameter.Optional 表示可选参数。</li><li>路由可用 <code>constraints: new &#123; id = @&quot;\d+&quot; &#125;</code> 约束。</li></ul><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul><li>添加 Controller，可以根据自己的架构和编码标准使用 T4 模板开发自定义脚手架（Scaffolding）模板。</li></ul><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><ul><li>Action 方法必须得是 public，不能为 static，不能重载。（除非指定 Http动词 如：<code>[HttpPost]</code>，不然请求时会报方法不明确的错误。如果指定的了，会根据不同的 Http动词，执行不同的 Action。）</li><li>Action 方法 返回 XXXResult（如：ViewResult、JavaScriptResult 等），这些 Result 都继承于 <a href="https://www.tutorialsteacher.com/mvc/action-method-in-mvc#:~:text=MVC%20framework%20includes%20various%20Result%20classes">ActionResult</a>。故 ActionResult 其实可以放回多种结果。<code>Action 方法其实也可以将返回值设置为 string int 之类的。</code></li><li>View() 方法是继承 Controller 基类而来的，返回 ViewResult。Controler 类<a href="https://www.tutorialsteacher.com/mvc/action-method-in-mvc#:~:text=shown%20in%20the%20below%20table">还有 Content()、File()、Json() 等</a>。</li><li>行为选择器：ActionName、NonAction、ActionVerbs。<ol><li>测试的情况是 添加了 ActionVerbs（可添加多个）则只可以接受相应类型的请求。没有添加，则任何类型的请求都行。（<code>与文章中说的默认 GET 不符。</code>）</li><li>当返回使用 Json() 时，考虑到安全性，默认不能用 Get 请求。可将 JsonRequestBehavior 设置为 AllowGet。</li><li>浏览器搜索栏的 Url 请求，都是 Get 请求。</li></ol></li></ul><h4 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h4><ul><li> 默认情况下，Action 参数的值是从请求的数据集合中检索的。数据集合包括表单数据或查询字符串值或 <code>cookie 值的名称/值对</code>（这个没试过），对<code>参数名的匹配大小写不敏感</code>。可用 <code>[Bind(Include = &quot;StudentId, StudentName&quot;)]</code> 设置绑定的参数。</li><li>同名参数<a href="https://www.tutorialsteacher.com/mvc/model-binding-in-asp.net-mvc#:~:text=Default%20value%20provider%20collection%20evaluates%20values%20from%20the%20following%20sources:">匹配优先级 Form &gt; QueryString</a>。无论是 POST 请求还是 GET 请求。（Postman 中，Post 请求可以有 QueryString 数据，Get 请求也可以有 Form 数据。）</li><li>Action 非可控类型（如 int）的参数，如果没有赋值，会报错。可改用 int?。</li></ul><h3 id="Razor"><a href="#Razor" class="headerlink" title="Razor"></a>Razor</h3><ul><li>Razor  <code>@:</code> 或者 <code>&lt;text&gt;/&lt;text&gt;</code> 可在代码块中展示文本或 html 标签。文本中又可以使用 @ ，可多重嵌套。</li><li>@{} 中的内容默认当做代码，但是 <code>&lt;xxx&gt;aaa&lt;/xxx&gt;</code> 或 <code>&lt;/br&gt; 类的</code> 形式的内容会被当做 html 标签解析。</li></ul><h4 id="Html"><a href="#Html" class="headerlink" title="@Html"></a>@Html</h4><ul><li>还能这么用继承的？<code>WebViewPage&lt;TModel&gt; : WebViewPage</code>。</li><li>F12 <code>@Html</code> 去了解内部结构。</li><li>调用 HtmlHelper 方法和使用 HTML 标签之间的区别在于 HtmlHelper 方法旨在使绑定到查看数据或模型数据变得容易。</li><li>推荐使用泛型的 TextBoxFor&lt;TModel, TProperty&gt;() 方法，而不是 TextBox()。强类型，错误少，执行速度快。</li><li>@Html.<code>CheckBoxFor</code>(m =&gt; m.isActive) 会额外生成 <code>&lt;input name=&quot;isActive&quot; type=&quot;hidden&quot; value=&quot;false&quot; /&gt;</code>。当 check 未选中时，form 表单值提交 false（check 标签不提交内容）；选中时，提交 true 和 false 两个值，当有多个同名值时，Action 中的参数会<code>匹配第一个</code>。</li><li>Student 类中 <code>[Display(Name = &quot;Name&quot;)]</code> 是给 @Html.LabelFor(m =&gt; m.StudentName) 用的。生成 <code>&lt;label for=&quot;StudentName&quot;&gt;Name&lt;/label&gt;</code></li></ul><h3 id="处理异常的方式"><a href="#处理异常的方式" class="headerlink" title="处理异常的方式"></a>处理异常的方式</h3><ol><li>使用 web.config 中的 <code>&lt;customErrors&gt;</code>，加上 <code>HandleErrorAttribute</code>。<ul><li><code>&lt;customErrors&gt;</code> 有三种值 On、Off、RemoteOnly。</li><li>设置好这两步后，<code>500 错误</code>会返回 Views share 文件夹中的 Error.cshtml（默认情况）。</li><li>FilterConfig 的 RegisterGlobalFilters 中加 filters.Add(new HandleErrorAttribute())，并在 Global 的 Application_Start 中注册 FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters)，则全局都可以 HandelError。（这两步都是默认有的）</li><li>如果没加，<code>[HanderError]</code> 属性标记了的才会返回 Error.cshtml。</li><li> [HanderError] 可设置参数，如 [HandleError(ExceptionType =typeof(NullReferenceException), View =”~/Views/Error/NullReference.cshtm=l”)]。</li><li>这种设置 <code>只配置返回网页，无法将错误写入log，或执行其他逻辑。</code></li></ul></li><li>重写 <code>Controller.OnException</code> 方法，控制器级的。<ul><li>不需要设置 <code>&lt;customErrors&gt;</code>。</li><li> <code>1</code> 和 <code>2</code> 可以配合使用。设置了 <code>1</code>，filterContext.Result = Error.cshtml；如果重载了 OnException 则可替换成别的结果，或者执行一些其他操作。</li></ul></li><li>使用 HttpApplication 的 <code>Application_Error</code> 事件，在 Global 文件中，全局级别的。<ul><li>同样不需要设置 <code>&lt;customErrors&gt;</code>。</li><li>Application_Error 事件在<code>任何类型</code>的异常和错误代码上触发。</li></ul></li></ol><div class="note simple info flat"><p>暂时不知道 任何类型的异常和错误代码 和前面提到的 500 错误 有何区别。</p></div><h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><ul><li>如果都设置了，执行顺序 <code>1 -&gt; 2 -&gt; 3</code>。</li><li>建议使用全局 Application_Error 事件记录所有异常以及 web.config 中的 <code>&lt;customErrors&gt;</code> 元素以将其重定向到适当的页面。而重写 OnException 用于需要特殊处理的 Controller</li><li><code>上述异常处理技术将返回带有 200 状态码的响应。如果要返回 404 500 之类的，可以考虑用 web.config 的 &lt;httpErrors&gt;</code></li></ul><h3 id="数据有效性验证"><a href="#数据有效性验证" class="headerlink" title="数据有效性验证"></a>数据有效性验证</h3><ul><li>ModelState.IsValid</li><li>ValidationSummary ValidationMessageFor 要配合 return View(std) 使用，可添加参数使其更改为自定义提示信息。</li><li>ModelState.AddModelError 可添加自定义提示，如：ModelState.AddModelError(“StudentName”, “Student Name Already Exists.”)。添加的提示全部会显示在 ValidationSummary 中，并且会根据字段名匹配到相应字段（ValidationMessageFor）。</li></ul><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><ul><li>_layout 有两种占位符 @RenderBody()、 @RenderSection(string name)。子页面中<code>相应名称</code>的 @section 会渲染到 RenderSection 中，其余渲染到 RenderBody 中。RenderSection 可设置是否 required。</li><li>_ViewStart.cshtml 可以用于指定 layout，子文件夹中也可以创建 _ViewStart.cshtml。另外，控制器中也可以指定 layout，return View(“Test”,”_layout2”)。<code>控制器指定的 layout &gt; 当前页面中指定的 layout（cshtml 文件最上方指定的） &gt; 当前文件夹 _ViewStart.cshtml 指定的 layout &gt; 大于全局的 layout（view 文件夹下的 _ViewStart.cshtml）</code>。</li></ul><h4 id="Partial-View。"><a href="#Partial-View。" class="headerlink" title="Partial View。"></a>Partial View。</h4><ul><li>@Html.Partial() 它返回一个 HTML 字符串，因此有机会在呈现之前修改 HTML（通过重载 Partial 方法）。</li><li>@html.RenderPartial() 方法与 @html.Partial() 方法相同，只是它将指定部分视图的结果 HTML 直接写入 HTTP 响应流，也可以在渲染之前修改它的 HTML。</li><li>@html.RenderAction(“RenderMenu”, “Home”)，前提得实现并调用一个<a href="https://www.tutorialsteacher.com/mvc/partial-view-in-asp.net-mvc#:~:text=The%20@html.RenderAction()%20method">符合规范的 Action</a>。</li><li>RenderPartial() <code>方法返回void，所以后需要一个分号</code>，因此它必须包含在@{} 中。</li></ul><h3 id="ViewBag-ViewData"><a href="#ViewBag-ViewData" class="headerlink" title="ViewBag ViewData"></a>ViewBag ViewData</h3><ul><li>ViewBag 是 ControllerBase 类的字段 <code>public dynamic ViewBag &#123; get; &#125;</code>（为何是只读的？）。原始类型或复杂类型对象都可以分配给 ViewBag 属性，重复给同一个名称分配值会覆盖。</li><li>ViewBag 和 ViewData 只将数据从控制器传输到视图，反之则不然。<code>如果发生重定向，ViewBag 值将为空。</code></li><li>ViewData 值在使用之前必须被转换为适当的类型。</li><li>ViewBag 是 dynamic 类型，而 ViewData 是 Object 类型。可以这么用 <code>ViewBag.Arr.Length</code>（即使没有智能提示），但不能 ViewData.Arr.Length。</li><li>ViewBag 是 ViewData 的包装器。如果 ViewBag 属性名称与 ViewData 的键匹配，它将抛出运行时异常。<br><code>*我自己测试的情况似乎不是这样的。</code></li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MVC <span class="number">5.2</span><span class="number">.7</span> </span><br><span class="line">测试情况：</span><br><span class="line"><span class="number">1.</span> ViewBag 和 ViewData 如果有同名的赋值，会被覆盖为后一个。<span class="meta"># 说明它们内部应该是同一个容器</span></span><br><span class="line"><span class="number">2.</span> ViewBag 可以使用（也可以覆盖） ViewData 设置的值，反之亦然。</span><br><span class="line"></span><br><span class="line"><span class="meta"># ViewBag（MVC 3.0) 应该是 ViewData（MVC 1.0) 的升级版。毕竟功能差不多，ViewBag 不用类型转换。</span></span><br><span class="line"><span class="meta"># 原理还不清楚，最好被混着用。我选择 ViewBag。</span></span><br></pre></td></tr></table></figure><h3 id="TempData"><a href="#TempData" class="headerlink" title="TempData"></a>TempData</h3><ul><li>TempData 用于将数据从<code>视图传输到控制器</code>、控制器到视图，或从一个 Action 传输到相同或不同控制器的 Action。</li><li>TempData 临时存储数据并在<code>检索值后自动删除它</code>，TempData.Keep() 可使其保留待删除数据。</li></ul><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><ul><li>Filter 是一个自定义类，您可以在其中编写自定义逻辑以在 Action 执行之前或之后执行。</li><li>过滤器可以以<code>声明式</code>或<code>编程式</code>应用于行为或控制器。<code>声明式</code>是将过滤器特性应用于行为或控制器类，<code>编程式</code>是实现相应的接口。</li><li>MVC 提供了<a href="https://www.tutorialsteacher.com/mvc/filters-in-asp.net-mvc#:~:text=MVC%20provides%20different%20types%20of%20filters">四种类型</a>的过滤器：Authorization、Action、Result、Exception。</li></ul><h4 id="HandleErrorAttribute"><a href="#HandleErrorAttribute" class="headerlink" title="HandleErrorAttribute"></a>HandleErrorAttribute</h4><ul><li>HandleErrorAttribute 类是一个<code>内置</code>的异常过滤器类，它在发生未处理的异常时默认呈现 Error.cshtml。 HandleError 特性其实指的就是它。抛出一个未处理的异常时会执行它，未处理的异常是没有被 try-catch 捕捉的异常。可以设置全局，也可以给特定的 Controller 或 Action 添加特性。具体在<a href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E5%BC%8F">处理异常的方式</a>有说明。</li></ul><h4 id="自定过滤器"><a href="#自定过滤器" class="headerlink" title="自定过滤器"></a>自定过滤器</h4><ul><li>自定义异常过滤器 <code>class MyErrorHandler : FilterAttribute, IExceptionFilter</code>（没有测试是否继承其中一个就行） ，其他类型的过滤器同理（如：Action 过滤器继承 FilterAttribute、IActionFilter ）。</li><li>也可以<code>派生</code>一个内置过滤器类并<code>重写</code>适当的方法来扩展内置过滤器的功能。</li><li>它们使用方法和内置过滤器是一样的。</li></ul><h4 id="Action-Filters"><a href="#Action-Filters" class="headerlink" title="Action Filters"></a>Action Filters</h4><ul><li>OutputCache 是一个内置的 Action Filters，设置返回结果（没测试除 View 外，其他是否可以）的缓存时间。行为过滤器通常用于应用横切关注点，例如日志记录、缓存、授权<code>（不是有个专门的 Authorization 过滤器吗？）</code>等。</li><li>OnActionExecuting （Action 之前）-&gt; OnActionExecuted （Action 之后，View 渲染之前）-&gt; OnResultExecuting （View 渲染之前）-&gt; OnResultExecuted （View 渲染之后）。</li><li><a href="https://stackoverflow.com/a/20125845/8910566">OnActionExecuted 和 OnResultExecuting 却别在于他们有不同的 Context</a>。<ol><li>OnActionExecuted 有一个 <code>ActionExecutedContext</code>，可以在其中查看操作产生的结果。还可以查看操作是否遇到异常，并查看是否处理了异常。</li><li>OnResultExecuting 有一个 <code>ResultExecutingContext</code>。这个方法在 ActionResult 实例被调用之前被调用。可以用来检查方法的结果，也可以取消结果的执行，这通常会导致状态代码为 200 的空白响应。（没法在 OnActionExecuted 方法中执行此操作）。</li></ol></li></ul><h3 id="Bundling-and-Minification"><a href="#Bundling-and-Minification" class="headerlink" title="Bundling and Minification"></a>Bundling and Minification</h3><ul><li>捆绑允许我们在单个 HTTP 请求中从服务器加载一堆静态文件。缩小技术通过删除不必要的空格和注释<code>并将变量名称缩短为一个字符</code>来优化脚本或 CSS 文件大小。</li><li>ScriptBundle、StyleBundle、DynamicFolderBundle</li><li>BundleConfig 的 RegisterBundles 方法中设置 ScriptBundle、StyleBundle，View 使用 @Scripts.Render(“”) 或  @Styles.Render(“”)。需要在 Global 中注册 BundleConfig.RegisterBundles(BundleTable.Bundles) 。</li><li>生成的绑定文件在另一个文件夹中，那么类似于 <code>background:url(../images/border_btm.png)</code> 这样的包含相对路径的引用将会 404，<a href="https://www.tutorialsteacher.com/articles/how-to-set-image-path-in-style-bundle">可以用 CssRewriteUrlTransform 解决</a>。</li><li>其他设置<ol><li>IncludeDirectory 可绑定文件夹下的所有文件。</li><li>{version} 可自动匹配可用版本。</li><li>还可以设置 CDN。</li></ol></li></ul><h3 id="Area"><a href="#Area" class="headerlink" title="Area"></a>Area</h3><ol><li> Area 允许我们将大型应用程序划分为更小的单元，其中每个单元包含一个单独的 MVC 文件夹结构，与默认的 MVC 文件夹结构相同。</li><li> Area 中 AdminAreaRegistration (Admin为Area名）重写路由 ，<code>/Admin/profile</code> 请求会被映射到 Areas/Admin/controller/ProfileController。需要在 Global 中注册 AreaRegistration.RegisterAllAreas()。 </li><li> 如果项目中找不到添加 Area 的选项：添加 -&gt; 搭建基架的项目（New Scaffolded Item…） -&gt; MVC 中的 Area。</li></ol><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>C# 程序中比较，无论是 linq 还是其他，默认是区分大小写的。如果 linq 转换为 sql 语句，在数据库中查询，是否区分大小写得看数据库的设置（默认是不区分的）。</code> </li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> MVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> MVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 font-spider 踩的各种坑</title>
      <link href="/blogs/ad93c862.html"/>
      <url>/blogs/ad93c862.html</url>
      
        <content type="html"><![CDATA[<p>前几天看到 <a href="https://hin.cool/">LonelyGod</a> 的博客，字体太漂亮了，偷偷拿来用了。可是 5M 大小的字体，加载会比较慢。今天刚好看到 <a href="https://github.com/aui/font-spider">font-spider</a>，字蛛是一个智能 WebFont 压缩工具，它能自动分析出页面使用的 WebFont 并进行按需压缩。你的网站用了什么字，它给你从字体包里挑出来打包成另一个字体文件。</p><p>font-spider 的说明文档言简意赅，恕我不是很看得懂。GitHub 中的好多项目说明文档都很简洁，每当遇到看了说明文档，还不知道怎么用时，我都会搜一搜有没有谁写了更详细的使用说明。如没有，往往会陷入自我怀疑，难道大家都懂得怎么使用，就我看不懂说明文档？<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2471/Very-concise-O(log(min(MN)))-iterative-solution-with-detailed-explanation/170358">I don’t understand,I am foolish ,I hate myself。</a></p><p>这个项目已经几年没更新了，这个我是后面才发现的，或许是因为太久没更新才会出现各种各样的问题。</p><pre><code>StackOverflow 先看赞数，GitBub 先看更新时间。</code></pre><h3 id="web-font-not-found"><a href="#web-font-not-found" class="headerlink" title="web font not found"></a>web font not found</h3><p>按照说明文档，先给博客添加了个 <code>font.css</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*声明 WebFont*/</span></span><br><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;hytmr55&#x27;</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;/fonts/hytmr55.eot&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">src</span>:</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;/fonts/hytmr55.eot?#font-spider&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;/fonts/hytmr55.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>),</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;/fonts/hytmr55.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>),</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">url</span>(<span class="string">&#x27;/fonts/hytmr55.svg&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">font-style</span>: normal;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后直接就在根目录运行 <code>font-spider *.html</code>，报错：<code>&lt;web font not found&gt;</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:\Data\Blog&gt;font-spider *.html</span><br><span class="line">&lt;web font not found&gt;</span><br></pre></td></tr></table></figure><p>原因是该文件夹中没有 html 文件，没找到 <code>font-family</code> 标记。</p><h3 id="Error-does-not-support-remote-path"><a href="#Error-does-not-support-remote-path" class="headerlink" title="Error: does not support remote path"></a>Error: does not support remote path</h3><p>进入 <code>public</code> 文件夹，执行<code>font-spider index.html</code>，先输入一个文件吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:\Data\Blog&gt;cd public</span><br><span class="line">c:\Data\Blog\public&gt;font-spider index.html</span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102174823.png" alt="20220102174823"></p><p>既然不支持远程文件，那就用 <code>--ignore</code> 吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --ignore <span class="string">&quot;^https://&quot;</span> index.html</span></span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102175256.png" alt="20220102175256"></p><p>好的，进入下一个错误。</p><h3 id="Error-“xxx”-did-not-find-truetype-or-opentype-fonts"><a href="#Error-“xxx”-did-not-find-truetype-or-opentype-fonts" class="headerlink" title="Error: “xxx” did not find truetype or opentype fonts"></a>Error: “xxx” did not find truetype or opentype fonts</h3><p>这一步我花了好长时间，最终知道了找错应给配合 <code>--info</code> 和 <code>--debug</code>。</p><p>也知道了 <code>font-spider --ignore &quot;^https://&quot; index.html</code> 这一步其实没有意义。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider index.html --debug</span></span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102175754.png" alt="20220102175754"></p><p>进入下一个错误。</p><h3 id="Error-ENOENT-load-“c-css-index-css”-failed"><a href="#Error-ENOENT-load-“c-css-index-css”-failed" class="headerlink" title="Error: : ENOENT, load “c:\css\index.css” failed"></a>Error: : ENOENT, load “c:\css\index.css” failed</h3><p><code>Error: : ENOENT, load &quot;c:\css\index.css&quot; failed: ENOENT: no such file or directory, open &#39;c:\css\index.css&#39;</code></p><p>博客添加 <code>fonts.css</code> 时用的是相对于博客主目录的路径 <code>\css\index.css</code>，而 font-spider 把它当成了相对C盘根目录的路径。</p><p>经 <a href="https://github.com/aui/font-spider/issues/40">font-spider 加载css报错</a> 启发，可以用 <code>--map</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css&quot;</span>  index.html</span></span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102184432.png" alt="20220102184432"></p><p>又是 <code>Error: does not support remote path</code>，有经验了，上 <code>--debug</code>。干脆没有成功之前，都 <code>--debug</code> 吧。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css&quot;</span>  index.html --debug</span></span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102184828.png" alt="20220102184828"></p><p>进入下一个错误。</p><h3 id="load-“https-xxx-css-quot-failed-Not-Found"><a href="#load-“https-xxx-css-quot-failed-Not-Found" class="headerlink" title="load “https://xxx.css&quot; failed: Not Found"></a>load “<a href="https://xxx.css&quot;/">https://xxx.css&quot;</a> failed: Not Found</h3><p><code>Error: : ENOENT, load &quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-freecss/all.min.css&quot; failed: Not Found</code></p><p>用 <code>--info</code> 看看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css&quot;</span>  index.html --info</span></span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102185403.png" alt="20220102185403"></p><p>折腾了那么久，也差不多明白了 font-spider 是怎样工作的。</p><blockquote><p>扫描输入文件（如 index.html）以及该文件引用的 css 文件，检查这些文件是否有 <code>font-family</code>，有则编入 <code>--info</code>，然后根据设置找到相应的字体文件（必须是 ttf 格式的），生成筛选后的字体文件。</p></blockquote><p>先试试把这个 Not Found 的文件 <code>--ignore</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css&quot;</span>  --ignore <span class="string">&quot;^https://&quot;</span>  index.html  --debug</span></span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102190413.png" alt="20220102190413"></p><h3 id="Error-“Poem”-did-not-find-truetype-or-opentype-fonts"><a href="#Error-“Poem”-did-not-find-truetype-or-opentype-fonts" class="headerlink" title="Error: “Poem” did not find truetype or opentype fonts"></a>Error: “Poem” did not find truetype or opentype fonts</h3><p>写到这里，我又再次体会到了几个小时前，不断尝试时的 厌烦、无力和不甘 交织在一起的感觉。不想看源码，感觉那会花很长的时间，但现在可能花了更长的时间。</p><p>font-family Poem 是一个插件中的，Google F12 查看到底是哪里引入了它。</p><p><img src="https://ih.itaru.xyz/images/20220102191459.png" alt="20220102191459"></p><p>那些导致错误的 css 都在这里了，用 <code>--ignore</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css&quot;</span>  --ignore <span class="string">&quot;icon\.css$,tag_plugins\.min\.css$,\.min\.css$&quot;</span>  index.html  --debug</span></span><br></pre></td></tr></table></figure><div class="note info flat"><p>\.min\.css$ 本该匹配到 <a href="https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css">https://cdn.jsdelivr.net/npm/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.min.css</a> 的，然而却没有，只能再加个 tag_plugins\.min\.css$。<br>好像 \ 得用两个 \\，但试了还是没用。</p></div><p><img src="https://ih.itaru.xyz/images/20220102191956.png" alt="20220102191956"></p><h3 id="File-not-found-with-singular-glob"><a href="#File-not-found-with-singular-glob" class="headerlink" title="File not found with singular glob"></a>File not found with singular glob</h3><p>依据上图可知，其实是字体文件也用了相对网站根目录的路径，而被解析成了相对C盘根目录的路径。</p><p>用 <code>--map</code> 将 <code>c:/fonts/hytmr55.ttf</code> 替换为 <code>fonts/hytmr55.ttf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css,c:/fonts/hytmr55.ttf,fonts/hytmr55.ttf&quot;</span> --ignore <span class="string">&quot;icon\.css$,tag_plugins\.min\.css$,\.min\.css$&quot;</span> index.html --debug</span></span><br></pre></td></tr></table></figure><p><img src="https://ih.itaru.xyz/images/20220102194534.png" alt="20220102194534"></p><p>成功了，但是部分文件生成到 <code>c:/fonts</code> 里去了。</p><p><code>c:/fonts/</code> 改为 <code>fonts/</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css,c:/fonts/,fonts/&quot;</span> --ignore <span class="string">&quot;icon[.]css$,tag_plugins\.min\.css,all\.min\.css&quot;</span> index.html --debug</span></span><br></pre></td></tr></table></figure><p>都生成到 public 的 <code>fonts/</code> 文件夹了。</p><p><img src="https://ih.itaru.xyz/images/20220102194828.png" alt="20220102194828"></p><h3 id="最终成果"><a href="#最终成果" class="headerlink" title="最终成果"></a>最终成果</h3><ol><li>改为输入 public 目录下的所有 html。</li><li>将需要用到的字体文件复制到 source 文件夹，部署的时候用。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> font-spider --map <span class="string">&quot;/css/(.*).css,css/<span class="variable">$1</span>.css,c:/fonts/,fonts/&quot;</span> --ignore <span class="string">&quot;icon\.css$,tag_plugins\.min\.css$,\.min\.css$&quot;</span> *.html **/*.html</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> copy C:\Data\Blog\public\fonts\hytmr55.woff C:\Data\Blog\<span class="built_in">source</span>\fonts\hytmr55.woff /y</span></span><br></pre></td></tr></table></figure><pre><code>每次部署博客又得多执行几个语句了。。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valine 无法评论的解决方案</title>
      <link href="/blogs/28b3acdd.html"/>
      <url>/blogs/28b3acdd.html</url>
      
        <content type="html"><![CDATA[<p>本站使用的是 LeanCloud 国际版的开发版，hexo 主题是 butterfly。配置详情请见：<a href="/blogs/bfcce7e4.html" title="配置评论插件 Valine 的邮件提醒和后台管理系统 Valine Admin">配置评论插件 Valine 的邮件提醒和后台管理系统 Valine Admin</a>。</p><h3 id="问题原因和解决方案"><a href="#问题原因和解决方案" class="headerlink" title="问题原因和解决方案"></a>问题原因和解决方案</h3><ol><li>问题原因：LeanCloud 存储服务数据已归档。<ul><li>解决方案：登录 LeanCloud，点击激活。</li></ul></li><li>问题原因：请求的域名不正确。<ul><li>解决方法：主题配置文件的 valine 项<a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">填上 serverURLs</a>。</li></ul></li></ol><hr><h3 id="LeanCloud-存储服务数据已归档"><a href="#LeanCloud-存储服务数据已归档" class="headerlink" title="LeanCloud 存储服务数据已归档"></a>LeanCloud 存储服务数据已归档</h3><p>30天没有访问，LeanCloud 会为你的数据做归档处理以节省服务器资源，<a href="https://www.tangruiping.com/post/hexo-valine-admin.html#:~:text=%E6%89%93%E5%BC%80LeanCloud%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%BB%E9%A1%B5%E6%BF%80%E6%B4%BB%E5%8D%B3%E5%8F%AF">打开 LeanCloud 控制台主页激活即可</a>。</p><h3 id="请求的域名不正确"><a href="#请求的域名不正确" class="headerlink" title="请求的域名不正确"></a>请求的域名不正确</h3><p>我此次遇到的问题，报错是：</p><p><code>https://us.leancloud.cn/1.1/classes/Comment?where=%7B%22%24or%22%3A%5B%7B%22rid%22%3A%7B%22%24exists%22%3Afalse%7D%7D%2C%7B%22rid%22%3A%22%22%7D%5D%2C%22url%22%3A%22%2Fcomments%2F%22%7D&amp;order=-createdAt%2C-insertedAt&amp;limit=0&amp;count=1</code> <mark class="hl-label red">Failed to load resource: net::ERR_NAME_NOT_RESOLVED</mark> </p><p>错在这个 <code>https://us.leancloud.cn</code> 域名不正确。</p><p>butterfly 有两个文件对 leancloud 进行请求</p><ul><li><a href="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js">https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js</a></li></ul><p><img src="https://ih.itaru.xyz/images/20220102082309.png" alt="20220102082309"></p><p>这个文件默认请求的域名是 <code>https://r+leancloud.cn</code></p><ul><li>themes\butterfly\layout\includes\third-party\newest-comments\valine.pug</li></ul><p><img src="https://ih.itaru.xyz/images/20220102082850.png" alt="20220102082850"></p><p>这个文件默认请求的域名是  <code>https://$&#123;theme.valine.appId.substring(0,8)&#125;.api.lncldglobal.com</code></p><pre><code>valine.pug 请求的域名是正确的，但是却走了 Valine.min.js 的请求。</code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>我们可以在主题配置文件的 valine 项的 serverURLs 填上，https:// + appId的前8个字符 + .api.lncldglobal.com。</code></p><p>这个其实就是 leancloud 为我们提供的 REST API 服务器地址。</p><p><img src="https://ih.itaru.xyz/images/20220102083805.png" alt="20220102083805"></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> Valine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动漫资源汇总</title>
      <link href="/blogs/9bec54e6.html"/>
      <url>/blogs/9bec54e6.html</url>
      
        <content type="html"><![CDATA[<p>一些值得推荐的在线观看、下载以及获取动漫资讯的网站、APP。</p><blockquote><p><code>*</code> 标记的需要代理。</p></blockquote><h3 id="在线观看"><a href="#在线观看" class="headerlink" title="在线观看"></a>在线观看</h3><ul><li><a href="https://www.bilibili.com/">哔哩哔哩</a> 虽然近年来老是被削，永远支持小破站。</li><li><a href="https://space.bilibili.com/11783021/">哔哩哔哩番剧出差*</a> 哔哩哔哩港澳台地区的动漫都是在这里发布的，近年大陆禁播番越来越多，港澳台地区新番要比大陆多不少，而且没有修图。</li><li><a href="http://m.yinghuacd.com/">樱花动漫</a>、<a href="http://www.nicotv.me/">妮可动漫</a>、<a href="http://www.zzzfun.com/">zzzfun</a> 资源挺多的，就是视频清晰度不够</li><li><a href="https://ani.gamer.com.tw/">巴哈姆特動畫瘋*</a> 台湾地区的动画平台，没会员的话每集之前有30秒广告，并且要会员才能看高清。据说万能的淘宝有卖会员。</li><li><a href="https://www.nicovideo.jp/">ニコニコ*</a>、<a href="https://anime.dmkt-sp.jp/animestore/">dアニメストア*</a>、<a href="https://site.nicovideo.jp/danime/">dアニメストア ニコニコ支店*</a> 日本动画平台。<br>注：dアニメストア ニコニコ支店 的会员和 dアニメストア 的会员是不能互用的。</li></ul><h3 id="APP（Android）"><a href="#APP（Android）" class="headerlink" title="APP（Android）"></a>APP（Android）</h3><ul><li>哔哩哔哩<br>注：哔哩哔哩中番剧的搜索结果会随 IP 所在地区变化。并且哔哩哔哩在 Google Play 上架的版本和国内的有些不同，比如新番表显示的是港澳台地区的。</li><li><a href="http://dddh.pub/">嘀嘀动漫</a> 挺全的，并且有超清资源。目前永久会员66元（我开通的时候是18，后来涨价了），开个会员手机上看番需求基本可以满足，除了一些绅士番（本来表番也挺多的，不少被人举报下架了）。还有就是没有弹幕，少了部分乐趣。</li></ul><h3 id="BT-PT-站点"><a href="#BT-PT-站点" class="headerlink" title="BT/PT 站点"></a>BT/PT 站点</h3><h4 id="BT站点"><a href="#BT站点" class="headerlink" title="BT站点"></a>BT站点</h4><ul><li><a href="https://share.dmhy.org/">動漫花園*</a> 国内应该有不少 BT 站点搬运该网站的内容。</li><li><a href="https://nyaa.si/">nyaa*</a> 这个站点有个 18R 的姊妹站。</li><li><a href="https://www.tokyotosho.info/">Tokyo Toshokan*</a> 東京図書館。</li></ul><h4 id="PT站点"><a href="#PT站点" class="headerlink" title="PT站点"></a>PT站点</h4><ul><li><a href="https://www.skyey2.com/forum.php?mod=torrents">Skyey Snow</a> 天雪，动漫特色PT站点，入站无门槛。但得注意分享率，太低了会被封号。</li><li><a href="https://u2.dmhy.org/portal.php">U2*</a> 幼儿园，动漫花园内站。大佬聚集地，一号难求（我没账号，无法进去一观）。据说里面应有尽有。动辄上百G的资源也不是我这低宽带和小硬盘消受得起的。</li></ul><h4 id="字幕说明"><a href="#字幕说明" class="headerlink" title="字幕说明"></a>字幕说明</h4><ul><li>内封字幕：视频和字幕封装在同一个文件中，一般包含多种语言的字幕（但不一定有中文），可以切换或关闭字幕。多为 <a href="https://baike.baidu.com/item/mkv/1658908?fr=aladdin">MKV</a> 格式。</li><li>内嵌字幕：字幕与视频嵌在一起，无法分离。多压制成 MP4 格式，质量会有损失，但影响不大。</li><li>外挂字幕：无字幕的视频和字幕文件封在同一个资源中。和内封的区别在于，字幕是单独的文件。</li></ul><p>找无字幕的视频最好是找 MKV 资源。如果用中文名搜不到，用英文名搜一般是可以找到无字幕版的。可以先用中文名搜，资源一般都会附带英文名的。</p><h3 id="字幕"><a href="#字幕" class="headerlink" title="字幕"></a>字幕</h3><ul><li><a href="https://assrt.net/">射手网(伪)</a></li><li><a href="https://www.skyey2.com/forum.php?mod=torrents&cat=16#:~:text=%E5%AD%97%E5%B9%95">Skyey Snow</a> PT站往往也会有字幕。</li><li><a href="https://github.com/Nekomoekissaten-SUB/Nekomoekissaten-Subs">喵萌奶茶屋</a> 以及其他一些字幕组自己的资源库。</li></ul><h3 id="百科"><a href="#百科" class="headerlink" title="百科"></a>百科</h3><ul><li><a href="https://zh.moegirl.org.cn/Mainpage">萌娘百科</a> 这边有个新番列表想推荐下：<a href="https://zh.moegirl.org.cn/Template:%E6%97%A5%E6%9C%AC2022%E5%B9%B4%E5%8A%A8%E7%94%BB">日本2022年动画</a> -&gt; <a href="https://zh.moegirl.org.cn/%E6%97%A5%E6%9C%AC2022%E5%B9%B4%E5%86%AC%E5%AD%A3%E5%8A%A8%E7%94%BB">日本2022年冬季动画</a> -&gt; <a href="https://zh.moegirl.org.cn/%E6%97%A5%E6%9C%AC2022%E5%B9%B4%E5%86%AC%E5%AD%A3%E5%8A%A8%E7%94%BB#%E5%8F%82%E8%A7%81">日本2022年冬季动画播出时间</a></li><li><a href="https://dic.nicovideo.jp/">ニコニコ大百科*</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动漫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动漫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Butterfly主题 Markdown 语法显示效果</title>
      <link href="/blogs/32ead7ca.html"/>
      <url>/blogs/32ead7ca.html</url>
      
        <content type="html"><![CDATA[<p>Butterfly主题开启頁面美化后的一些效果，以及其他一些 Markdown 语法的汇总。</p><blockquote><p>得开启<a href="https://butterfly.js.org/posts/ceeb73f/#%E9%A0%81%E9%9D%A2%E7%BE%8E%E5%8C%96">頁面美化</a></p></blockquote><p>参考文章：<a href="https://whatsid.me/2019/08/21/hexo-markdown-syntax/">Hexo博客的Markdown语法</a><br><a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 安裝文檔(三) 主題配置-1</a></p><h2 id="美化了的（部分）"><a href="#美化了的（部分）" class="headerlink" title="美化了的（部分）"></a>美化了的（部分）</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># h1   //一级标题 对应 <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="section">## h2   //二级标题 对应 <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="section">### h3  //三级标题 对应 <span class="xml"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span></span><br><span class="line"><span class="section">#### h4  //四级标题 对应 <span class="xml"><span class="tag">&lt;<span class="name">h4</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span></span><br><span class="line"><span class="section">##### h5  //五级标题 对应 <span class="xml"><span class="tag">&lt;<span class="name">h5</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span></span><br><span class="line"><span class="section">###### h6  //六级标题 对应 <span class="xml"><span class="tag">&lt;<span class="name">h6</span>&gt;</span></span> <span class="xml"><span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><h1 id="h1"><a href="#h1" class="headerlink" title="h1"></a>h1</h1><h2 id="h2"><a href="#h2" class="headerlink" title="h2"></a>h2</h2><h3 id="h3"><a href="#h3" class="headerlink" title="h3"></a>h3</h3><h4 id="h4"><a href="#h4" class="headerlink" title="h4"></a>h4</h4><h5 id="h5"><a href="#h5" class="headerlink" title="h5"></a>h5</h5><h6 id="h6"><a href="#h6" class="headerlink" title="h6"></a>h6</h6><h3 id="段落及区块引用"><a href="#段落及区块引用" class="headerlink" title="段落及区块引用"></a>段落及区块引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这段文字将会被高亮显示</span></span><br></pre></td></tr></table></figure><blockquote><p>这段文字将会被高亮显示</p></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 无序列表1 // <span class="emphasis">* 和 + 也行</span></span><br><span class="line"><span class="emphasis">- 无序列表2</span></span><br><span class="line"><span class="emphasis">- 无序列表3</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">1. 有序列表1</span></span><br><span class="line"><span class="emphasis">2. 有序列表2</span></span><br><span class="line"><span class="emphasis">3. 有序列表3</span></span><br></pre></td></tr></table></figure><ul><li>无序列表1</li><li>无序列表2</li><li>无序列表3</li></ul><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol><h3 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--- //或 ***</span><br></pre></td></tr></table></figure><hr><h3 id="嵌套引用"><a href="#嵌套引用" class="headerlink" title="嵌套引用"></a>嵌套引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 动物</span></span><br><span class="line">&gt;&gt; 水生动物</span><br><span class="line">&gt;&gt; 陆生动物</span><br><span class="line">&gt;&gt;&gt; 猴子</span><br><span class="line">&gt;&gt;&gt; 人</span><br><span class="line">&gt;&gt;&gt;&gt; 程序猿</span><br><span class="line">&gt;&gt;&gt;&gt; 攻城狮</span><br><span class="line">&gt;&gt;产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记</span><br><span class="line">射鸡虱   //这里需要注意，没有空行间隔，忽略降级引用标记</span><br><span class="line"></span><br><span class="line">&gt;&gt; 两栖类动物</span><br><span class="line">&gt;&gt;&gt; 大鳄鱼</span><br><span class="line">唐老鸭</span><br></pre></td></tr></table></figure><blockquote><p>动物</p><blockquote><p>水生动物<br>陆生动物</p><blockquote><p>猴子<br>人</p><blockquote><p>程序猿<br>攻城狮<br>产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记<br>射鸡虱   //这里需要注意，没有空行间隔，忽略降级引用标记</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><p>两栖类动物</p><blockquote><p>大鳄鱼<br>唐老鸭</p></blockquote></blockquote></blockquote><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote 作者, 出处 %&#125;</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">&#123;% endblockquote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% blockquote @作者 网络地址 %&#125;</span><br><span class="line">xxxxxxxxxxxxxxxxxxxxxxxxxx</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>xxxxxxxxxxxxxxxxxxxxxxxxxxxx</p><footer><strong>作者</strong><cite>出处</cite></footer></blockquote><blockquote><p>xxxxxxxxxxxxxxxxxxxxxxxxxx</p><footer><strong>@作者 网络地址</strong></footer></blockquote><h3 id="lable标签"><a href="#lable标签" class="headerlink" title="lable标签"></a>lable标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">臣亮言：&#123;% label 先帝 %&#125;創業未半，而&#123;% label 中道崩殂 blue %&#125;。今天下三分，&#123;% label 益州疲敝 pink %&#125;，此誠&#123;% label 危急存亡之秋 red %&#125;也！然侍衞之臣，不懈於內；&#123;% label 忠志之士 purple %&#125;，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。</span><br><span class="line">宮中、府中，俱為一體；陟罰臧否，不宜異同。若有&#123;% label 作奸 orange %&#125;、&#123;% label 犯科 green %&#125;，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。</span><br></pre></td></tr></table></figure><p>臣亮言：<mark class="hl-label default">先帝</mark> 創業未半，而<mark class="hl-label blue">中道崩殂</mark> 。今天下三分，<mark class="hl-label pink">益州疲敝</mark> ，此誠<mark class="hl-label red">危急存亡之秋</mark> 也！然侍衞之臣，不懈於內；<mark class="hl-label purple">忠志之士</mark> ，忘身於外者，蓋追先帝之殊遇，欲報之於陛下也。誠宜開張聖聽，以光先帝遺德，恢弘志士之氣；不宜妄自菲薄，引喻失義，以塞忠諫之路也。<br>宮中、府中，俱為一體；陟罰臧否，不宜異同。若有<mark class="hl-label orange">作奸</mark> 、<mark class="hl-label green">犯科</mark> ，及為忠善者，宜付有司，論其刑賞，以昭陛下平明之治；不宜偏私，使內外異法也。</p><h3 id="双-Tab"><a href="#双-Tab" class="headerlink" title="双 Tab"></a>双 Tab</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个 Tab 键</span><br></pre></td></tr></table></figure><pre><code>两个 Tab 键</code></pre><h2 id="解析错误的"><a href="#解析错误的" class="headerlink" title="解析错误的"></a>解析错误的</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [ ] content </span><br><span class="line"><span class="bullet">-</span> [x] content</span><br></pre></td></tr></table></figure><ul><li><input disabled="" type="checkbox"> content </li><li><input checked="" disabled="" type="checkbox"> content</li></ul><h2 id="未改变的"><a href="#未改变的" class="headerlink" title="未改变的"></a>未改变的</h2><h3 id="内容强调"><a href="#内容强调" class="headerlink" title="内容强调"></a>内容强调</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*这里是斜体*</span></span><br><span class="line"><span class="emphasis">_这里是斜体_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**这里是加粗**</span></span><br><span class="line"><span class="strong">__这里是加粗__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**<span class="emphasis">*这里是加粗并斜体<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_这里是加粗并斜体<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure><p><em>这里是斜体</em><br><em>这里是斜体</em></p><p><strong>这里是加粗</strong><br><strong>这里是加粗</strong></p><p><em><strong>这里是加粗并斜体</strong></em><br><em><strong>这里是加粗并斜体</strong></em></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>这样来<del>删除一段文本</del></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐    |  右对齐 | 居中 |</span><br><span class="line">| :-------- | -------:| :--: |</span><br><span class="line">| Computer  | 5000 元 |  1台 |</span><br><span class="line">| Phone     | 1999 元 |  1部 |</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中</th></tr></thead><tbody><tr><td align="left">Computer</td><td align="right">5000 元</td><td align="center">1台</td></tr><tr><td align="left">Phone</td><td align="right">1999 元</td><td align="center">1部</td></tr></tbody></table><h3 id="tab-标签"><a href="#tab-标签" class="headerlink" title="tab 标签"></a>tab 标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Tab标签列表 %&#125;</span><br><span class="line">  &lt;!-- tab 标签页1 --&gt;</span><br><span class="line"><span class="code">    标签页1文本内容</span></span><br><span class="line"><span class="code">  &lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="code">  &lt;!-- tab 标签页2 --&gt;</span></span><br><span class="line"><span class="code">    标签页2文本内容</span></span><br><span class="line"><span class="code">  &lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="code">  &lt;!-- tab 标签页3 --&gt;</span></span><br><span class="line"><span class="code">    标签页3文本内容</span></span><br><span class="line"><span class="code">  &lt;!-- endtab --&gt;</span></span><br><span class="line"><span class="code">&#123;% endtabs %&#125;</span></span><br></pre></td></tr></table></figure><div class="tabs" id="tab标签列表"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#tab标签列表-1">标签页1</button></li><li class="tab"><button type="button" data-href="#tab标签列表-2">标签页2</button></li><li class="tab"><button type="button" data-href="#tab标签列表-3">标签页3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="tab标签列表-1"><p>  标签页1文本内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab标签列表-2"><p>  标签页2文本内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="tab标签列表-3"><p>  标签页3文本内容</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p><a href="http://markdown.p2hp.com/extended-syntax/index.html#footnotes">Markdown扩展语法中的脚注</a> 试了，没效果。</p><p>但可以用以下方式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内容<span class="xml"><span class="tag">&lt;<span class="name">sup</span>&gt;</span></span>[<span class="string">[1</span>]](#1)<span class="xml"><span class="tag">&lt;/<span class="name">sup</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span>[1]<span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> 说明</span><br></pre></td></tr></table></figure><p>内容<sup><a href="#1">[1]</a></sup></p><p><a id="1">[1]</a> 说明</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> butterfly </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET面试题 - 数据库基础</title>
      <link href="/blogs/6a7cd97a.html"/>
      <url>/blogs/6a7cd97a.html</url>
      
        <content type="html"><![CDATA[<p>.NET面试题中一些数据库的知识，问题来源于网络以及我自己的总结。与其说是面试题，这更像是数据库基础知识的部分汇总。</p><p>本文多数问题基于：<a href="https://zhuanlan.zhihu.com/p/355271573">.NET 面试题 - 数据库基础</a></p><h3 id="数据库（Database）和-数据库管理系统（DBMS）"><a href="#数据库（Database）和-数据库管理系统（DBMS）" class="headerlink" title="数据库（Database）和 数据库管理系统（DBMS）"></a>数据库（Database）和 数据库管理系统（DBMS）</h3><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><p>数据库，又称为<code>数据</code>管理系统，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的资料执行新增、截取、更新、删除等操作。</p><p>所谓“数据库”是以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。</p><h4 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h4><p><code>数据库</code>管理系统（Database Management System，DBMS）是为管理数据库而设计的电脑软件系统，一般具有存储、截取、安全保障、备份等基础功能。</p><p>例如：Microsoft SQL Server 软件是数据库管理系统，里面有很多数据库。</p><p>详情：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F">数据库 - wiki</a></p><h3 id="什么是-关系数据库？"><a href="#什么是-关系数据库？" class="headerlink" title="什么是 关系数据库？"></a>什么是 关系数据库？</h3><p>关系数据库是创建在关系模型基础上，数据项之间具有预定义关系的数据项的集合。这些项被组织为一组具有列和行的表。表用于保存要在数据库中表示的对象的信息。表中的每列都保存着特定类型的数据，字段存储着属性的实际值。表中的行表示一个对象或实体的相关值的集合。表中的每一行可标有一个称为主键的唯一标识符，并且可使用外键在多个表中的行之间建立关联。可以通过许多不同的方式访问此数据，而无需重新组织数据库表本身。</p><p>大多数主流数据库都属于关系数据库，例如 Oracle、MySQL、SQL Server 以及 PostgreSQL 等。另外，数据库领域还存在一些非关系模型的数据库（NoSQL），例如 Mongodb、Redis、Cassandra 等。</p><p>参考：<a href="https://aws.amazon.com/cn/relational-database/">什么是关系数据库？</a></p><h3 id="什么是-SQL？"><a href="#什么是-SQL？" class="headerlink" title="什么是 SQL？"></a>什么是 SQL？</h3><p>SQL（结构化查询语言）是用于与关系数据库通信的主要接口。SQL 可用于添加、更新或删除数据行，检索事务处理和分析应用程序的数据子集，以及管理数据库的所有方面。</p><p>SQL 包含四个部分：</p><ol><li>资料定义语言（Data Manipulation Language, DML）：SQL语言集中负责数据结构定义与数据库对象定义的语言，由 CREATE、ALTER 和 DROP 组成。</li><li>数据操纵语言（Data Manipulation Language, DML）：用于数据库操作，INSERT、UPDATE、DELETE 加上 SELECT（也有人把它单独归为 数据查询语言 DQL）。称为 CRUD（Create, Retrieve, Update, Delete）。</li><li>数据控制语言（Data Control Language, DCL）：是一种可对资料访问权进行控制的指令，它可以控制特定用户账户对资料表、查看表、存储程序、用户自定义函数等数据库对象的控制权。由 GRANT 和 REVOKE 两个指令组成。</li><li>事务控制语言（Transaction Control Language TCL）：用于编写事务。SET TRANSACTION、COMMIT、ROLLBACK 和 SAVEPOINT。</li></ol><p>参考：<a href="https://zh.wikipedia.org/wiki/SQL">SQL - Wiki</a></p><h3 id="什么是-数据完整性约束？"><a href="#什么是-数据完整性约束？" class="headerlink" title="什么是 数据完整性约束？"></a>什么是 数据完整性约束？</h3><p>关系的完整性约束通常包括<code>域完整性</code>、<code>实体完整性</code>、<code>参照完整性</code>和<code>用户定义完整性</code>。</p><ol><li><p>域完整性：是保证数据库字段取值的合理性，是最简单、最基本的约束。在当今的关系 DBMS 中，一般都有域完整性约束检查功能。</p></li><li><p>实体完整性：作用是在传输、存储信息或数据的过程中，确保信息或数据不被未授权的篡改或在篡改后能够被迅速发现。按实体完整性规则要求，主属性不得取空值，如主关键字是多个属性的组合，则所有这些属性均不得取空值。</p></li><li><p>参照完整性：作用是定义建立关系之间联系的主关键字与外部关键字引用的约束条件。关系数据库中通常都包含多个存在相互联系的关系，关系与关系之间的联系是通过公共属性来实现的。根据实体完整性要求，主关键字不得取空值。</p></li><li><p>用户定义完整性：作用是根据应用环境的要求和实际的需要，对某一具体应用所涉及的数据提出约束性条件。这一约束机制一般不应由应用程序提供，而应由关系模型提供定义并检验，用户定义完整性主要包括字段有效性约束和记录有效性。</p></li></ol><p>参考：<a href="https://zhuanlan.zhihu.com/p/122950702">关系数据库中的完整性约束</a><br><a href="https://en.wikipedia.org/wiki/Data_integrity#Types_of_integrity_constraints">Data integrity - Wiki</a></p><h3 id="SQL-Server-中的六种约束"><a href="#SQL-Server-中的六种约束" class="headerlink" title="SQL Server 中的六种约束"></a>SQL Server 中的六种约束</h3><ol><li>主键约束（PRIMARY KEY）</li><li>外键约束（FOREIGN KEY）</li><li>唯一约束（UNIQUE）</li><li>非空约束（NOT NULL）</li><li>检查约束（CHECK）</li><li>默认值约束（DEFAULT ）</li></ol><p>这些属于 用户定义完整性 约束。</p><p>详情：<a href="https://blog.csdn.net/a_lllll/article/details/87865407">SQL Server中的六种约束：主键约束，外键约束，唯一约束，非空约束，检查约束，默认约束</a></p><h3 id="数据库常见对象有哪些？"><a href="#数据库常见对象有哪些？" class="headerlink" title="数据库常见对象有哪些？"></a>数据库常见对象有哪些？</h3><p>表（Table）、视图（View）、序列（Sequence）、索引（Index）、存储过程（Stored Procedure）、触发器（Trigger）、用户（User）以及同义词（Synonym）等等。其中，表是关系数据库中存储数据的主要形式。</p><h3 id="CHAR-和-VARCHAR-类型的区别？"><a href="#CHAR-和-VARCHAR-类型的区别？" class="headerlink" title="CHAR 和 VARCHAR 类型的区别？"></a>CHAR 和 VARCHAR 类型的区别？</h3><ul><li>CAHR 是固定长度的字符串，如果输入的内容长度不够，则使用空格进行填充，通常用于存储固定长度的编码。</li><li>VARCHAR 是可变长度的字符串，通常用于存储姓名等长度不一致的数据。</li></ul><h3 id="数据库三范式"><a href="#数据库三范式" class="headerlink" title="数据库三范式"></a>数据库三范式</h3><ol><li><p>第一范式（1NF）：原子性</p><p>第一范式是为了要排除 重复组 的出现，要求数据库的每个列的论域都是由不可分割的原子值组成；每个字段的值都只能是单一值。</p></li><li><p>第二范式（2NF）：完全依赖关系</p><p>规则是要求资料表里的所有资料都要和该资料表的键（主键与候选键）有完全依赖关系：每个非键属性必须独立于任意一个候选键的任意一部分属性。如果有哪些资料只和一个键的一部分有关的话，就得把它们独立出来变成另一个资料表。如果一个资料表的键只有单个字段的话，它就一定符合第二范式。</p></li><li><p>第三范式（3NF）：消除传递依赖</p><p>要求所有非主键属性都只和候选键有相关性，也就是说非主键属性之间应该是独立无关的。</p></li></ol><p>其实不止三范式</p><p>参考：<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96#:~:text=%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%E3%80%81%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%E5%92%8C%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F">数据库规范化 - Wiki</a></p><h3 id="视图-View"><a href="#视图-View" class="headerlink" title="视图(View)"></a>视图(View)</h3><p>视图是一个虚拟表，其内容由查询定义。同表一样，视图包含一系列带有名称的列和行数据。视图在数据库中并不是以数据值存储集形式存在，除非是索引视图。行和列的数据来自定义视图的查询所引用的表，并且在引用视图时动态生成。</p><p>对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其他数据库的一个或多个表，或者其他视图。</p><p>优点：</p><ul><li>替代复杂查询，减少复杂性；</li><li>提供一致性接口，实现业务规则；</li><li>控制对于表的访问，提高安全性。</li></ul><p>视图<code>按它们允许的操作</code>可分为:</p><ul><li>可删除视图</li><li>可更新视图</li><li>可插入视图</li><li>只读视图</li></ul><p>参考：<a href="https://docs.microsoft.com/zh-cn/sql/relational-databases/views/views?view=sql-server-ver15">视图 - Microsoft SQL 文档</a><br><a href="https://www.ibm.com/docs/zh/db2/11.1?topic=views-designing">设计视图</a></p><h3 id="触发器（Trigger）"><a href="#触发器（Trigger）" class="headerlink" title="触发器（Trigger）"></a>触发器（Trigger）</h3><p>触发器（Trigger）是 SQL Server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>触发器是自动的。当对表中的数据做了修改之后立即被激活。</li><li>触发器可以通过数据库中的相关表进行层叠修改。</li><li>触发器可以强制限制。这些限制比用 CHECK 约束所定义的更复杂。与 CHECK 约束不同的是，触发器可以引用其他表中的列。</li></ol><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>触发器的主要作用就是其能够实现由主键和外键所不能保证的复杂参照完整性和数据的一致性，它能够对数据库中的相关表进行级联修改，提高比 CHECK 约束更复杂的的数据完整性，并自定义错误消息。触发器的主要作用主要有以下接个方面：</p><ol><li>强制数据库间的引用完整性。</li><li>级联修改数据库中所有相关的表，自动触发其它与之相关的操作。</li><li>跟踪变化，撤销或回滚违法操作，防止非法修改数据。</li><li>返回自定义的错误消息。约束无法返回信息，而触发器可以。</li><li>触发器可以调用更多的存储过程。</li></ol><p>详情：<a href="https://www.cnblogs.com/wangprince2017/p/7827091.html">SqlServer基础之(触发器)</a></p><h3 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h3><p>关系数据库所有的关系运算其实是集合与集合的运算，它的输入是集合，输出同样是集合。有时需要对结果集逐行进行处理，这时就需要用到游标。</p><h4 id="游标的使用（五步法）"><a href="#游标的使用（五步法）" class="headerlink" title="游标的使用（五步法）"></a>游标的使用（五步法）</h4><ol><li>声明游标</li><li>打开游标</li><li>读取数据</li><li>关闭游标</li><li>删除游标</li></ol><p>详情：<a href="https://www.cnblogs.com/myboke/p/3738912.html">SQLServer游标详解</a></p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>加快数据的检索速度。（注：不仅是 select。update 和 delete 也会使用索引。）</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>需要占用额外的存储空间。</li><li>索引会进行动态维护，这对新增、修改和删除等数据维护的速度有影响。（新增速度会减慢，修改和删除不一定。因为修改和删除包括两步：找数据和改（删）数据。）</li></ul><h4 id="索引按数据结构分类"><a href="#索引按数据结构分类" class="headerlink" title="索引按数据结构分类"></a>索引按数据结构分类</h4><ul><li>B树索引（B-Tree、B+Tree）</li><li>Hash索引</li><li>Full-Text索引</li><li>R-Tree索引</li></ul><h4 id="索引种类"><a href="#索引种类" class="headerlink" title="索引种类"></a>索引种类</h4><ul><li>聚集索引：聚集索引根据聚集索引键对表或视图的数据行进行排序和存储。聚集索引以 B树 索引结构实现。<br>注：<code>没有聚集索引的表，数据以堆的形式存储；有则以 B树 的结构存储。</code>一个表中只能有一个聚集索引。</li><li>非聚集索引：非聚集索引中的每个索引行都包含非聚集键值和行定位符。此定位符指向聚集索引或堆中具有键值的数据行。</li><li>唯一索引：唯一索引确保索引键不包含重复值。</li><li>计算列索引：从一个或多个其他列的值或某些确定性输入派生的列上的索引。</li><li>全文索引：支持全文搜索，它为字符串数据中的复杂单词搜索提供了有效的支持。</li></ul><p>还有其他索引。</p><p>参考：<a href="https://docs.microsoft.com/en-us/sql/relational-databases/indexes/indexes?view=sql-server-ver15">Indexes - Microsoft SQL Docs</a></p><h3 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h3><p>事务是单个工作单元。如果事务成功，则事务期间所做的所有数据修改都将被提交并成为数据库的永久部分。如果事务遇到错误并且必须取消或回滚，则所有数据修改都会被删除。</p><h4 id="事务具有-ACID-特性"><a href="#事务具有-ACID-特性" class="headerlink" title="事务具有 ACID 特性"></a>事务具有 ACID 特性</h4><ol><li>原子性（Atomicity）：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：事务前后数据的完整性必须保持一致。<br>例：在存款取款的例子中，钱是不能凭空产生或销毁的，对于每个（收支）条目必须有一个相应的抵衡条目产生，以保证账户是平的。</li><li>隔离性（Isolation）：多个用户并发访问数据库时，数据库为每一个用户开启的事务，多个并发事务之间要相互隔离，不能被其他事务的操作数据所干扰。<br><code>隔离性一般是通过加锁的机制来实现的。</code></li><li>持续性（Durability）：一个事务一旦被提交，它对数据库中数据的修改就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。</li></ol><h4 id="T-SQL事务语句"><a href="#T-SQL事务语句" class="headerlink" title="T-SQL事务语句"></a>T-SQL事务语句</h4><ul><li>开始事务：BEGIN TRANSACTION</li><li>提交事务：COMMIT TRANSACTION</li><li>回滚（撤销）事务：ROLLBACK TRANSACTION</li><li>存储点语句：SAVE TRANSACTION</li></ul><h3 id="维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？"><a href="#维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？" class="headerlink" title="维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？"></a>维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑？为什么？</h3><ol><li>尽可能使用约束，如 CHECK、主键、外键、非空字段等来约束，这样做效率最高，也最方便。</li><li>其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保持数据的完整性和一致性。</li><li>最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。</li></ol><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入（SQL injection）是发生于应用程序与数据库层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了字符检查，那么这些注入进去的恶意指令就会被数据库服务器误认为是正常的 SQL 指令而执行，因此遭到破坏或是入侵。</p><h4 id="导致的原因"><a href="#导致的原因" class="headerlink" title="导致的原因"></a>导致的原因</h4><p>在应用程序中若有下列状况，则可能应用程序正暴露在 SQL注入 的高风险情况下：</p><ul><li>在应用程序中使用字符串联结方式或联合查询方式组合 SQL 指令。</li><li>在应用程序链接数据库时使用权限过大的账户（例如很多开发人员都喜欢用最高权限的系统管理员账户（如常见的root，sa等）连接数据库）。</li><li>在数据库中开放了不必要但权力过大的功能（例如在Microsoft SQL Server数据库中的 xp_cmdshell 延伸存储程序或是 OLE Automation 存储程序等）。</li><li>太过于信任用户所输入的资料，未限制输入的特殊字符，以及未对用户输入的资料做潜在指令的检查。</li></ul><h4 id="作用原理"><a href="#作用原理" class="headerlink" title="作用原理"></a>作用原理</h4><ul><li>SQL命令可进行查询、插入、更新、删除等命令的串接。以分号字符为不同命令的区别。（原本的作用是用于 SubQuery 或作为查询、插入、更新、删除……等的条件式。）</li><li>SQL命令对于传入的字符串参数是用单引号字符所包起来的。（但连续2个单引号字符，在SQL数据库中，则视为字符串中的一个单引号字符。）</li><li>SQL命令中，可以注入注释。（连续2个减号字符 – 后的文字为注解，或“/*”与“*/”所包起来的文字为注释。）</li><li>因此，如果在组合SQL的命令字符串时，未针对单引号字符作转义处理的话，将导致该字符变量在填入命令字符串时，原本的SQL语法被恶意窜改。</li></ul><h4 id="避免的方法"><a href="#避免的方法" class="headerlink" title="避免的方法"></a>避免的方法</h4><ol><li>在设计应用程序时，完全使用参数化查询（Parameterized Query）来设计资料访问功能。</li><li>在组合SQL字符串时，先针对所传入的参数加入其他字符（将单引号字符前加上转义字符）。</li><li>使用其他更安全的方式连接SQL数据库。例如已修正过SQL注入问题的数据库连接组件，例如 ASP.NET 的 SqlDataSource 对象或是 LINQ to SQL。</li><li>增强WAF的防御力</li></ol><p>参考：<a href="https://zh.wikipedia.org/wiki/SQL%E6%B3%A8%E5%85%A5">SQL注入 - Wiki</a> （这篇绝对是机翻文，语句太不通顺了，很多句子都不懂他在表达什么。）</p><h3 id="WHERE子句与HAVING子句有何不同"><a href="#WHERE子句与HAVING子句有何不同" class="headerlink" title="WHERE子句与HAVING子句有何不同?"></a>WHERE子句与HAVING子句有何不同?</h3><ul><li>Where 是一个约束声明，是在查询结果集返回之前 约束来自数据库的数据，且 Where 中不能使用聚合函数。</li><li>Having 是一个过滤声明，是在查询结果集返回以后 对查询结果进行的过滤操作，在 Having 中可以使用聚合函数。</li></ul><h3 id="什么是子查询？子查询有哪些类型？"><a href="#什么是子查询？子查询有哪些类型？" class="headerlink" title="什么是子查询？子查询有哪些类型？"></a>什么是子查询？子查询有哪些类型？</h3><p>子查询（subquery）是将一个查询语句嵌套在另一个查询语句中。</p><p>在特定情况下，一个查询语句的条件需要另一个查询语句来获取，内层查询（inner query）语句的查询结果，可以为外层查询（outer query）语句提供查询条件。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>标量子查询(scalar subquery)：返回 1 行 1 列一个值。</li><li>行子查询(row subquery)：返回的结果集是 1 行 N 列。</li><li>列子查询(column subquery)：返回的结果集是 N 行 1 列。</li><li>表子查询(table subquery)：返回的结果集是 N 行 N 列。</li></ul><p>基于子查询和外部查询的关系，也可以分为关联子查询（correlated subqueries）和非关联子查询（non-correlated subqueries）。关联子查询会引用外部查询中的列，因而与外部查询产生关联；非关联子查询与外部查询没有关联。</p><p>详情：<a href="https://www.cnblogs.com/geaozhang/p/6756825.html">SELECT中常用的子查询操作</a></p><h3 id="使用-EXISTS-关键字引入的子查询与使用-IN-关键字引入的子查询在语法上有哪些不同？"><a href="#使用-EXISTS-关键字引入的子查询与使用-IN-关键字引入的子查询在语法上有哪些不同？" class="headerlink" title="使用 EXISTS 关键字引入的子查询与使用 IN 关键字引入的子查询在语法上有哪些不同？"></a>使用 EXISTS 关键字引入的子查询与使用 IN 关键字引入的子查询在语法上有哪些不同？</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">WHERE</span> B.Name<span class="operator">=</span>A.Name);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> Name <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Name <span class="keyword">FROM</span> B);</span><br></pre></td></tr></table></figure><p>对语句字面上的理解是：</p><ul><li>EXISTS 语句：外部表的每一行套入子查询语句中，若有与子查询匹配的行（找到一行即可），则返回True。</li><li>IN 语句：先求出子查询的结果，对外部查询进行过滤。</li></ul><div class="note warning simple"><p>只是对语句字面上的解释不同，但这两个语句在逻辑上是等价的（至少上面的例子是），那么查询优化器可能会产生相同的执行计划。Sql 是声明性语言，即你只是描述你需要什么，至于怎么获取，查询优化器会自己决定。查询优化器挺聪明的，它会在多种解决方案中择优（大多数情况是这样的，但有时也会显得很蠢）。<br>如果换成 NOT EXISTS 和 NOT IN 两个查询就不等价了，因为这两者对 NULL 的处理逻辑不同。</p></div>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> .NET面试题 </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET面试题 - 编程基础知识</title>
      <link href="/blogs/a2a26768.html"/>
      <url>/blogs/a2a26768.html</url>
      
        <content type="html"><![CDATA[<p>.NET面试题中一些关于编程的基础知识，问题来源于网络以及我自己的总结。与其说是面试题，这更像是编程基础知识的部分汇总。本文知识不仅仅适用于 C# 程序员。</p><h3 id="面向过程、面向对象和面向切面"><a href="#面向过程、面向对象和面向切面" class="headerlink" title="面向过程、面向对象和面向切面"></a>面向过程、面向对象和面向切面</h3><ul><li>面向过程（PO）：一种源自结构编程，并基于调用过程的概念的编程方式。它遵循循序渐进的方式，通过一系列指令将任务分解为一组变量和例程。</li><li>面向对象（OO）：围绕<code>数据或对象</code>而不是<code>功能和逻辑</code>来进行软件设计的计算机编程设计理念或方法。</li><li>面向切面（AO）：在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想。</li></ul><p>参考：<a href="https://www.javatpoint.com/procedural-programming-vs-object-oriented-programming">Difference between procedural programming and object-oriented programming</a><br><a href="https://www.zhihu.com/question/24863332/answer/48376158">什么是面向切面编程AOP</a></p><h3 id="面向对象三大基本特性"><a href="#面向对象三大基本特性" class="headerlink" title="面向对象三大基本特性"></a>面向对象三大基本特性</h3><ol><li>封装：就是将客观事物抽象为逻辑实体，实体的属性和功能相结合，形成一个有机的整体。并对实体的属性和功能实现进行访问控制，向信任的实体开放，对不信任的实体隐藏。通过开放的外部接口即可访问，无需知道功能如何实现。</li><li>继承：在继承机制下形成有层级的类，使得低层级的类可以延用高层级类的特征和方法。继承的实现方式有两种：实现继承、接口继承。</li><li>多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用基类的引用指向子类的对象。</li></ol><p>详情：<a href="https://segmentfault.com/a/1190000021898422">面向对象的三大基本特征和五大基本原则</a><br><a href="https://www.cnblogs.com/baichunyu/p/11006229.html">面试小问题——什么是多态？</a></p><h3 id="面向对象五大基本原则"><a href="#面向对象五大基本原则" class="headerlink" title="面向对象五大基本原则"></a>面向对象五大基本原则</h3><ol><li>单一职责原则 SRP(Single Responsibility Principle)：一个类应该有且只有一个去改变它的理由，这意味着一个类应该只有一项工作。</li><li>开放封闭原则 OCP(Open－Close Principle)：对象或实体应该对扩展开放，对修改封闭。</li><li>里式替换原则 LSP(the Liskov Substitution Principle LSP)：在对象 x 为类型 T 时 q(x) 成立，那么当 S 是 T 的子类时，对象 y 为类型 S 时 q(y) 也应成立。（即对父类的调用同样适用于子类）</li><li>接口分离原则 ISP(the Interface Segregation Principle ISP)：不应强迫客户端实现一个它用不上的接口，或是说客户端不应该被迫依赖它们不使用的方法。</li><li>依赖倒置原则 DIP(the Dependency Inversion Principle DIP)：实体必须依靠抽象而不是具体实现。它表示高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象。</li></ol><p>详情：<a href="https://www.jianshu.com/p/b56e098575db">S.O.L.I.D：面向对象设计的头 5 大原则</a></p><h3 id="高内聚-低耦合"><a href="#高内聚-低耦合" class="headerlink" title="高内聚 低耦合"></a>高内聚 低耦合</h3><ul><li><p>高内聚：内聚度是指<code>一个模块/类</code>的元素之间的归属程度，建议相关联的代码应该彼此靠近，所以我们应该争取高内聚度，尽可能地将所有相关联的代码绑定在一起。它与模块/类中的元素有关。 </p></li><li><p>低耦合：耦合度是指<code>不同模块/类</code>相互依赖的程度，建议所有模块尽可能独立，这就是争取低耦合的原因。它与不同模块/类之间的元素有关。</p></li></ul><p>参考：<a href="https://stackoverflow.com/a/14000957/8910566">What does ‘low in coupling and high in cohesion’ mean</a></p><h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>序列化：序列化是将对象转化为可以写入流的形式的过程。它是将对象转换为一种形式以便将其存储在文件、数据库或内存中的过程，并且它可以通过网络传输。它的主要目的是保存对象的状态，以便在需要时可以重新创建。</p><p>反序列化：反序列化是序列化的逆过程。它是取回序列化对象以便将其加载到内存中的过程。它通过设置属性、字段等来恢复对象的状态。</p><p>参考：<a href="https://www.c-sharpcorner.com/article/serialization-and-deserialization-in-c-sharp/">Serialization and Deserialization in C#</a></p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>线程同步是一种机制，可确保两个或多个并发进程或线程不同时执行程序的某些特定部分，尤其是临界区。在这种技术中，一个线程执行程序的临界区，另一个线程等待第一个线程完成执行。如果不应用适当的同步机制，则会发生竞态条件。</p><p>实现方式：</p><ul><li>阻塞</li><li>加互斥锁</li><li>信号和句柄</li><li>非阻塞同步</li></ul><p>详情：<a href="https://www.c-sharpcorner.com/UploadFile/1c8574/thread-synchronization/">Thread Synchronization - C#Corner</a></p><h3 id="内存溢出-和-内存泄露"><a href="#内存溢出-和-内存泄露" class="headerlink" title="内存溢出 和 内存泄露"></a>内存溢出 和 内存泄露</h3><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>指程序在运行的过程中，程序对内存的需求超过了计算机分配给程序的内存，从而造成“Out of memory”之类的错误，使程序不能正常运行。</p><p>造成内存溢出有几种情况： </p><ol><li>计算机本身的内存小。当同时运行多个软件时，计算机的内存不够用从而造成内存溢出。对于这种情况，只能增加计算机内存来解决。 </li><li>软件程序的问题。程序在运行时没能及时释放不用的内存，造成使用的内存越来越大从而造成内存溢出。对于这种情况，可以修改程序的代码来解决。</li></ol><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>内存泄漏指由于疏忽或错误造成程序不能释放或不能及时释放已经不再使用的内存的情况，是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存不能回收或不能及时回收。当程序不能释放的内存越来越多时就会造成程序的性能下降或出现内存溢出的错误。</p><p>参考：<a href="https://www.cnblogs.com/bile/p/4966796.html">浅析c#内存泄漏</a></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .NET面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET面试题 - C#与网站</title>
      <link href="/blogs/eb0f2435.html"/>
      <url>/blogs/eb0f2435.html</url>
      
        <content type="html"><![CDATA[<p>.NET面试题中一些关于网站的知识，问题来源于网络以及我自己的总结。与其说是面试题，这更像是 C# 与网站相关知识的部分汇总。</p><h3 id="NET、ASP-NET、ASP-NET-MVC-和-C"><a href="#NET、ASP-NET、ASP-NET-MVC-和-C" class="headerlink" title=".NET、ASP.NET、ASP.NET MVC 和 C#"></a>.NET、ASP.NET、ASP.NET MVC 和 C#</h3><h4 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h4><p>.NET 是一个开发人员平台，由工具、编程语言、库组成，用于构建许多不同类型的应用程序。</p><p>基础平台提供适用于所有不同类型的应用的组件。附件框架（如 ASP.NET）通过 用于构建特定类型应用的组件 来扩展 .NET。</p><h4 id="ASP-NET"><a href="#ASP-NET" class="headerlink" title="ASP.NET"></a>ASP.NET</h4><p>ASP.NET 是 .NET 的扩展平台，拥有专门用于构建 Web 应用程序的工具和库。</p><h4 id="ASP-NET-MVC"><a href="#ASP-NET-MVC" class="headerlink" title="ASP.NET MVC"></a>ASP.NET MVC</h4><p>ASP.NET MVC 是用于清晰实现<code>关注点分离</code>的设计模式。</p><p>MVC 是一种设计模式，用于解耦用户界面（view 视图）、数据（model 模型）和应用程序逻辑（controller 控制器）。此模式有助于实现关注点分离。</p><h4 id="C"><a href="#C" class="headerlink" title="C#"></a>C#</h4><p>C# 是一种编程语言，而 .NET 是构建该语言的框架。</p><p>事实上，.NET 支持许多编程语言，并定义了这些语言使用的规则和相关库。它还为应用程序提供了一个运行时环境，公共语言运行时 (CLR)。C# 编写的应用程序可以在任何支持 .NET 的平台上运行。</p><p>参考：<a href="https://dotnet.microsoft.com/en-us/learn/aspnet/what-is-aspnet">What is ASP.NET?</a><br><a href="https://dotnet.microsoft.com/en-us/apps/aspnet/mvc">ASP.NET MVC Pattern</a><br><a href="https://www.capitaitresourcing.co.uk/blogs/whats-the-difference-between-c-and-net-81122210121">What’s the difference between C# and .NET?</a></p><h3 id="NET-Framework、-NET-Core-和-Xamarin"><a href="#NET-Framework、-NET-Core-和-Xamarin" class="headerlink" title=".NET Framework、.NET Core 和 Xamarin"></a>.NET Framework、.NET Core 和 Xamarin</h3><ul><li>.NET Standard 是 .NET 生态系统的标准（换言之，规范）。</li><li>.NET Framework 是一个基于 .NET 的框架，它支持 Windows 和 Web 应用程序。</li><li>.NET Core 也是一个基于 .NET 的框架。.NET Core 是新的开源和跨平台框​​架，用于为所有操作系统（包括 Windows、Mac 和 Linux）构建应用程序（网站属于 Web 应用程序）。</li><li>Xamarin 是一个使用 C# 开发跨平台移动应用程序（iOS、Android 和 Windows Mobile）的框架。</li></ul><p>参考：<a href="https://stackoverflow.com/a/54943555/8910566">What’s the difference between .NET Core, .NET Framework, and Xamarin?</a></p><h3 id="MVC-和-三层框架-的区别"><a href="#MVC-和-三层框架-的区别" class="headerlink" title="MVC 和 三层框架 的区别"></a>MVC 和 三层框架 的区别</h3><ul><li>三层架构：表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）。</li><li>MVC 设计模式：Model（模型），View（视图），Controller（控制器）。</li></ul><p>乍一看，三层似乎类似于 MVC，然而，在拓扑上它们是不同的。三层架构中的一个基本规则是客户端层从不直接与数据层通信，在三层模型中，所有通信都必须通过中间层。从概念上讲，三层架构是<code>线性</code>的。然而，MVC 是<code>三角形</code>的：视图向控制器发送更新，控制器更新模型，视图直接从模型更新。</p><p>参考；<a href="https://stackoverflow.com/a/10740045/8910566">what is the difference between 3 tier architecture and a mvc?</a></p><h3 id="Web-Service、WCF、WCF-Rest-和-Web-API-的区别"><a href="#Web-Service、WCF、WCF-Rest-和-Web-API-的区别" class="headerlink" title="Web Service、WCF、WCF Rest 和 Web API 的区别"></a>Web Service、WCF、WCF Rest 和 Web API 的区别</h3><h4 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h4><ul><li>它基于 SOAP 并以 XML 形式返回数据。</li><li>它仅支持 HTTP 协议。</li><li>它不是开源的，但可以被任何理解 xml 的客户端使用。</li><li>它只能托管在 IIS 上。</li></ul><h4 id="WCF"><a href="#WCF" class="headerlink" title="WCF"></a>WCF</h4><ul><li>它也是基于 SOAP 并以 XML 形式返回数据。</li><li>它是 Web 服务 (ASMX) 的演变，支持各种协议，如 TCP、HTTP、HTTPS、命名管道、MSMQ。</li><li>WCF 的主要问题是其繁琐而广泛的配置。</li><li>它不是开源的，但可以被任何理解 XML 的客户端使用。</li><li>它可以托管在应用程序中或在 IIS 上或使用窗口服务。</li></ul><h4 id="WCF-Rest"><a href="#WCF-Rest" class="headerlink" title="WCF Rest"></a>WCF Rest</h4><ul><li>要将 WCF 用作 WCF Rest 服务，您必须启用 webHttpBindings。</li><li>它分别通过 [WebGet] 和 [WebInvoke] 属性支持 HTTP GET 和 POST verbs。</li><li>要启用其他 HTTP verbs（应该指的是 <a href="#HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">HTTP 请求方法</a>），您必须在 IIS 中进行一些配置以接受该特定 verbs 对 .svc 文件的请求。</li><li>使用 WebGet 通过参数传递数据需要配置，必须指定 UriTemplate。</li><li>它支持 XML、JSON 和 ATOM 数据格式。</li></ul><h4 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h4><ul><li>这是一种以简单的方式构建 HTTP 服务的框架。</li><li>Web API 是开源的，是在 .NET Framework 上构建 REST-ful 服务的理想平台。</li><li>与 WCF Rest 服务不同，它使用 HTTP 的全部特性（如 URI、请求/响应标头、缓存、版本控制、各种内容格式）。</li><li>它还支持 MVC 特性，例如路由、控制器、行为（Action）、过滤器、模型绑定器、IOC 容器或依赖注入、单元测试，使其更加简单和健壮。</li><li>它可以托管在应用程序中或 IIS 上。</li><li>它是轻量级架构，适用于智能手机等带宽有限的设备。</li><li>响应由 Web API 的 MediaTypeFormatter 格式化为 JSON、XML 或任何您想要添加为 MediaTypeFormatter 的格式。</li></ul><h4 id="WCF-或-WEB-API-如何选择"><a href="#WCF-或-WEB-API-如何选择" class="headerlink" title="WCF 或 WEB API 如何选择"></a>WCF 或 WEB API 如何选择</h4><ul><li>如果要创建应支持特殊场景（例如单向消息传递、消息队列、双工通信等）的服务，请选择 WCF。 </li><li>当你想创建一个服务，可以用更快速的传输通道时，像TCP、NamedPipes或者甚至是UDP（在WCF4.5中）。在其他传输通道不可用的时候也可以支持HTTP。</li><li>当你想创建一个基于HTTP的面向资源的服务并且可以使用HTTP的全部特征时（比如URIs、request/response头，缓存，版本控制，多种内容格式），你应该选择WebAPI</li><li>当您希望将您的服务公开给各种客户端（包括浏览器、手机、iPhone 和平板电脑）时，请选择 Web API。</li></ul><p>参考：<a href="https://www.dotnettricks.com/learn/webapi/difference-between-wcf-and-web-api-and-wcf-rest-and-web-service">Difference between WCF and Web API and WCF REST and Web Service</a></p><h3 id="ASP-NET-MVC-和-ASP-NET-Web-API-的区别"><a href="#ASP-NET-MVC-和-ASP-NET-Web-API-的区别" class="headerlink" title="ASP.NET MVC 和 ASP.NET Web API 的区别"></a>ASP.NET MVC 和 ASP.NET Web API 的区别</h3><ul><li>Asp.Net MVC 用于创建同时返回视图和数据的 Web 应用程序。Asp.Net Web API 用 只返回数据，不返回视图 的简易的方式创建完整的 HTTP 服务。</li><li>Web API 有助于在 .NET Framework 上构建 REST-ful 服务，它还支持内容协商（确定客户端可接受的最佳响应格式化数据，可以是 JSON、XML、ATOM 或其他格式化数据）。</li><li>Web API 还负责根据请求中的 Accept 标头以特定格式（如 JSON、XML 或任何其他格式）返回数据。MVC 仅使用 JsonResult 以 JSON 格式返回数据。</li><li>在 Web API 中，请求被映射到基于 HTTP verbs（<a href="#HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">HTTP 请求方法</a>） 的动作，但在 MVC 中它被映射到行为（Action）名称。</li><li>Web API 中的模型绑定、过滤器、路由和其他 MVC 拥有的功能，存在于新的程序集 System.Web.Http 中。而在 MVC 中，这些特性存在于 System.Web.Mvc 中。因此 Web API 也可以与 Asp.Net 一起使用并作为独立的服务层。</li><li>您可以在单个项目中混合使用 Web API 和 MVC 控制器来处理高级 AJAX 请求，这些请求可能以 JSON、XML 或任何其他格式返回数据并构建完整的 HTTP 服务。通常，这将称为 Web API 自托管。</li><li>当您混合使用 MVC 和 Web API 控制器并且想要实现授权时，您必须创建两个过滤器，一个用于 MVC，另一个用于 Web API，因为两者是不同的。</li><li>此外，Web API 是轻量级架构，除了 Web 应用程序外，它还可以与智能手机应用程序一起使用。</li></ul><p>参考：<a href="https://www.dotnettricks.com/learn/webapi/difference-between-aspnet-mvc-and-aspnet-web-api">Difference between ASP.NET MVC and ASP.NET Web API</a></p><h3 id="SOAP、REST-和-RESTful-Webservice"><a href="#SOAP、REST-和-RESTful-Webservice" class="headerlink" title="SOAP、REST 和 RESTful Webservice"></a>SOAP、REST 和 RESTful Webservice</h3><ul><li>SOAP（Simple Object Access Protocol 简单对象访问协议）是一种基于 XML 的协议，与 REST 不同，它严格定义了请求和响应的结构。</li><li>REST（REpresentational State Transfer 表述性状态传递）摆脱了请求和响应的僵化结构。它不仅限于 XML 格式，消息可以以多种格式发送，例如 JSON 或 CSV 等。</li><li>RESTful Webservice  实现了 REST 架构风格的 Web 服务。</li></ul><p>参考：<a href="https://wkrzywiec.medium.com/rest-restful-web-service-api-soap-whats-the-difference-4f101953d0bd">REST, RESTful web service, API, SOAP…what’s the difference?</a></p><h3 id="ASP-NET页面之间传值方式？"><a href="#ASP-NET页面之间传值方式？" class="headerlink" title="ASP.NET页面之间传值方式？"></a>ASP.NET页面之间传值方式？</h3><ol><li>Request.QueryString</li><li>Request.Form</li><li>Session</li><li>Cookie</li><li>HttpContext.Items</li><li>Application</li><li>Cache</li><li>ViewState</li><li>config文件</li><li>static（静态全局变量）</li></ol><p>详情：<a href="https://www.cnblogs.com/wangjiming/p/6275854.html">浅谈ASP.NET 页面之间传值的几种方式</a></p><h3 id="什么是ABP框架？"><a href="#什么是ABP框架？" class="headerlink" title="什么是ABP框架？"></a>什么是ABP框架？</h3><p>ABP 是 ASP.NET Boilerplate（ASP.NET样板项目）的简称，ABP 是一个开源且文档友好的应用程序框架。ABP 不仅仅是一个框架，它还提供了一个最徍实践的基于领域驱动设计（DDD）的体系结构模型。</p><p>ABP 诞生的主要目的就是为了让 .NET 程序员“秒变”架构师，将 .NET 企业级项目的主流开发技术、最先进的架构整合起来，让 .NET 工程师能够更快的开发出更好的项目。</p><p>详情：<a href="https://www.cnblogs.com/wuhuacong/p/10919020.html">ABP开发框架前后端开发系列—（1）框架的总体介绍</a></p><h3 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h3><ol><li>GET</li><li>HEAD</li><li>POST</li><li>PUT</li><li>DELETE</li><li>CONNECT</li><li>OPTIONS</li><li>TRACE</li><li>PATCH</li></ol><p>参考: <a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods">HTTP 請求方法 - MDN</a></p><h3 id="POST-和-GET"><a href="#POST-和-GET" class="headerlink" title="POST 和 GET"></a>POST 和 GET</h3><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。(注：网站可能会限制)</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。<br><br>在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><p><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTML 请求方法 - w3school</a></p><h3 id="跨域-和-同源策略（Same-origin-policy）"><a href="#跨域-和-同源策略（Same-origin-policy）" class="headerlink" title="跨域 和 同源策略（Same-origin policy）"></a>跨域 和 同源策略（Same-origin policy）</h3><h4 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h4><p>同源策略是一种关键的安全机制，它限制一个源加载的文档或脚本如何与来自另一个源的资源交互。如果两个 URL 的协议、端口（如果指定）和主机相同，则两个 URL 同源。</p><p>参考：<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">Same-origin policy</a></p><h4 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h4><ul><li>document.domain</li><li>跨文档通信 API：window.postMessage()</li><li>JSONP</li><li>CORS</li><li>webpack本地代理</li><li>websocket</li><li>Nginx反向代理</li></ul><p>详情：<a href="https://blog.csdn.net/qq_38128179/article/details/84956552">什么是跨域？跨域解决方法</a></p><h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><p>前后端分离是 Web 应用的一种架构模式。在开发阶段，前后端工程师约定好数据交互接口，实现并行开发和测试；在运行阶段前后端分离模式需要对 Web 应用进行分离部署，前后端之间使用 HTTP 或者其他协议进行交互请求。</p><p>参考：<a href="https://cloud.tencent.com/developer/article/1162258">大家都在说的前后端分离到底是什么？</a></p><h3 id="什么是自托管？"><a href="#什么是自托管？" class="headerlink" title="什么是自托管？"></a>什么是自托管？</h3><p>有两种解释：</p><ol><li>Web 应用程序不需要托管在网站管理服务程序中。例如：WebApi 不在 IIS 中托管运行，而是寄宿在 .NET控制台、WinForms 等程序中。</li><li>使用私有网络服务器运行和维护网站，而不是使用外部托管的网站。例如：本站就托管在 GitHub 中，不属于自托管。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .NET面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET面试题 - C#与数据库</title>
      <link href="/blogs/d8b002a3.html"/>
      <url>/blogs/d8b002a3.html</url>
      
        <content type="html"><![CDATA[<p>.NET面试题中一些关于C#与数据库交互的知识，问题来源于网络以及我自己的总结。与其说是面试题，这更像是 C# 与数据库相关知识的部分汇总。</p><h3 id="数据库操作的相关类"><a href="#数据库操作的相关类" class="headerlink" title="数据库操作的相关类"></a>数据库操作的相关类</h3><ul><li><p>特定类：Connection，Command，CommandBuilder，DataAdapter，DataReader，Parameter，Transaction 等</p></li><li><p>共享类：DataSet，DataTable，DataRow，DataColumn，DataRealtion，Constraint，DataColumnMapping，DataTableMapping 等</p></li></ul><p>参考：<a href="https://www.cnblogs.com/AlinaL/p/12852153.html">C#学习笔记之——数据库操作的相关类</a><br><a href="https://www.c-sharpcorner.com/UploadFile/puranindia/ado-net-objects-part-i/">ADO.NET Objects: Part I - C#Corner</a></p><h3 id="ADO-NET-五大对象"><a href="#ADO-NET-五大对象" class="headerlink" title="ADO.NET 五大对象"></a>ADO.NET 五大对象</h3><ul><li><p>Connection(连接对象)：与数据源建立连接。Close以后还可以Open，Dispose以后则不能再用。</p></li><li><p>DataAdapter(适配器对象)：对数据源执行操作并返回结果，在DataSet与数据源之间建立通信，将数据源中的数据写入DataSet中，或根据DataSet中的数据绑定数据源。</p></li><li><p>DataSet(数据集对象)：内存中的数据库，是数据表的集合，它可以包含任意多个数据表。</p></li><li><p>Command(命令对象)：对数据源执行SQL命令并返回结果。</p></li><li><p>DataReader(数据流对象)：取数据源的数据，只允许对将数据源以只读、顺向的方式查看其中所存储的数据。其常用于检索大量数据，DataReader对象还是一种非常节省资源的数据对象。</p></li></ul><p>DataReader时刻与远程数据库服务器保持连接，将远程的数据通过“流”的形式单向传输给客户端，它是“只读”的。由于是直接访问数据库，所以效率较高，但使用起来不方便。</p><p>DataSet一次性从数据源获取数据到本地，并在本地建立一个微型数据库（包含表、行、列、规则、表之间的关系等），期间可以断开与服务器的连接，使用DataAdapter对象操作“本地微型数据库”，结束后通过DataAdapter一次性更新到远程数据库服务器。这种方式使用起来更方便，便简单。但性能较第一种稍微差一点。（在一般的情况下两者的性能差异可以忽略不计。）</p><p>参考：<a href="https://www.cnblogs.com/igqx/archive/2020/06/22/13175824.html">C# 连接SQL数据库以及操作数据库</a><br><a href="https://www.cnblogs.com/qi123/p/9217010.html">C# 连接SQL数据库以及操作数据库</a><br><a href="https://stackoverflow.com/a/17553377/8910566">C# Data Connections Best Practice? - D Stanley</a></p><h3 id="DataTable和DataSet"><a href="#DataTable和DataSet" class="headerlink" title="DataTable和DataSet"></a>DataTable和DataSet</h3><p>DataSet是数据集（可以比作一个内存中的数据库），DataTable是数据表，DataSet中存储多个DataTable。DataSet和DataTable像是专门存储数据的一个容器，你查询数据库得到的一些结果可以存在里面。</p><p>DataSet功能强大有浏览、排序、搜索、过滤、处理分级数据、缓存更改等功能，还可以与XML数据互换。</p><p>参考：<a href="https://www.cnblogs.com/vaevvaev/p/6815384.html">C# DataSet与DataTable的区别和用法</a></p><h3 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM"></a>什么是 ORM</h3><p>ORM（对象关系映射 Object–relational mapping）是一种使用面向对象的编程语言在不兼容的类型系统之间转换数据的编程技术。它可以说是创建了一个可以在编程语言中使用的“虚拟对象数据库”。</p><p>说白了就是表映射成类，外键映射成指向另一个类的属性，索引、字段长度约束等等都可以映射。</p><p>参考：<a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">Object–relational mapping</a></p><h3 id="EF-Entity-Framework-与-ADO-Net"><a href="#EF-Entity-Framework-与-ADO-Net" class="headerlink" title="EF(Entity Framework) 与 ADO.Net"></a>EF(Entity Framework) 与 ADO.Net</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/#:~:text=ADO.NET%20is%20a%20set%20of%20classes%20that%20expose%20data%20access%20services%20for%20.NET%20Framework%20programmers.">ADO.NET</a> 是为 .NET Framework 程序员提供的一组用于公开数据访问服务的类。</p><p><a href="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/overview#:~:text=The%20Entity%20Framework%20is%20a%20set%20of%20technologies%20in%20ADO.NET%20that%20support%20the%20development%20of%20data-oriented%20software%20applications.">实体框架（Entity Framework）</a>是 ADO.NET 中的一组技术，用于支持面向数据的软件应用程序的开发。</p><p><a href="https://en.wikipedia.org/wiki/Entity_Framework#:~:text=Entity%20Framework%20(EF)%20is%20an%20open%20source[3]%20object%E2%80%93relational%20mapping%20(ORM)%20framework%20for%20ADO.NET.">Wiki</a> 上也说：Entity Framework 是 ADO.NET 的开源对象关系映射 (ORM) 框架。</p><p>所以说 Entity Framework 其实是包括在 ADO.Net 里的，是个 ORM 模型。但其实 ADO.Net 不止与数据库对接，还包括许多其他和数据访问相关的组件。但业界普遍喜欢将（SQLCommand, SQLDataReader, SQLConnection 和 SQLDataAdapter）的一套组件 代指 ADO.NET 。如果是以这种区分方式，EF 就是基于 ADO.Net 的。</p><p>封装的组件往往更易用，但性能<code>可能</code>稍有不如底层组件。</p><h3 id="EF-的三种编程方式"><a href="#EF-的三种编程方式" class="headerlink" title="EF 的三种编程方式"></a>EF 的三种编程方式</h3><ul><li>Model First （ADO.NET Entity Data Model）</li><li>Database First</li><li>Code First</li></ul><h3 id="Entity-Framework（或者ORM）中的-延迟加载（Lazy-Loading）、直接加载（Eager-Loading）、显式加载（Explicit-Loading）"><a href="#Entity-Framework（或者ORM）中的-延迟加载（Lazy-Loading）、直接加载（Eager-Loading）、显式加载（Explicit-Loading）" class="headerlink" title="Entity Framework（或者ORM）中的 延迟加载（Lazy Loading）、直接加载（Eager Loading）、显式加载（Explicit Loading）"></a>Entity Framework（或者ORM）中的 延迟加载（Lazy Loading）、直接加载（Eager Loading）、显式加载（Explicit Loading）</h3><h4 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h4><p>延迟加载又叫惰性加载：即在需要或者使用的时候加载数据。默认情况下，EF会使用延迟加载方式加载数据，即数据库上下文的属性：Configuration.LazyLoadingEnabled = true。</p><ul><li>非常宽容，因为只在需要的时候加载数据，不需要预先计划</li><li>可能会因为数据访问的延迟而降低性能，考虑到每次访问父实体的子实体时，就需要访问数据库。</li></ul><h4 id="直接加载（预加载）"><a href="#直接加载（预加载）" class="headerlink" title="直接加载（预加载）"></a>直接加载（预加载）</h4><p>直接加载可一次性加载所有需要的实体。即相关对象（子对象）与其父对象一起自动加载。</p><ul><li>减少数据访问的延迟，在一次数据库的访问中返回所有的数据。</li><li>减少与数据库的交互次数</li></ul><h4 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h4><p>显式加载和延迟加载非常类似，不同的是显式加载要手动关闭 EF 的延迟加载属性，通过代码 Configuration.LazyLoadingEnabled = false 来完成。</p><h4 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h4><ul><li>当关系不是太多时，使用直接加载。因为，直接加载是减少服务器上进一步查询的好方法。</li><li>当您确定每当使用主实体时都会用到相关实体，请使用直接加载。</li><li>当您使用 一对多 集合时，请使用延迟加载。</li><li>当您确定不会立即使用相关实体时，请使用延迟加载。</li><li>当您关闭延迟加载时，如果您事先不确定是否会使用相关实体​​，请使用显式加载。</li></ul><p>参考：<a href="https://blog.csdn.net/u010028869/article/details/48531863">EF学习和使用（五）Lazy Loading and Eager Loading</a><br><a href="https://blog.csdn.net/u010028869/article/details/48791983">EF学习和使用（六）显式加载、按需加载</a><br><a href="https://www.c-sharpcorner.com/article/eager-loading-lazy-loading-and-explicit-loading-in-entity-framework/">Eager Loading, Lazy Loading And Explicit Loading In Entity Framework - C#Corner</a></p><h3 id="如何解决数据并发问题"><a href="#如何解决数据并发问题" class="headerlink" title="如何解决数据并发问题?"></a>如何解决数据并发问题?</h3><ul><li>加锁</li><li>数据库乐观锁（即：添加版本号字段）</li><li>使用消息队列</li></ul><p>处理并发的最终原理其实就是：将用户的<code>并行操作转换成串行操作</code>。</p><p>参考：<a href="https://blog.csdn.net/love1793912554/article/details/92437035">如何有效处理数据并发操作问题</a></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .NET面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git/GitHub 实例汇总</title>
      <link href="/blogs/7402d6ca.html"/>
      <url>/blogs/7402d6ca.html</url>
      
        <content type="html"><![CDATA[<p>这是我进行过的一些和 Git/GitHub 有关的值得记录下来的操作。</p><h3 id="GitHub-两种类型的-URL-地址"><a href="#GitHub-两种类型的-URL-地址" class="headerlink" title="GitHub 两种类型的 URL 地址"></a>GitHub 两种类型的 URL 地址</h3><p>以前将更改提交到 GitHub 老是报错：<code>SSL certificate problem: self signed certificate</code></p><p>也有尝试使用 <code>git config --global http.sslVerify false</code></p><p>但过段时间又报相同的错误，而且这个语句时灵时不灵，有时得执行好几次才能提交成功。就跟玄学一样。</p><p>后来发现了根源，<a href="https://docs.github.com/en/get-started/getting-started-with-git/about-remote-repositories">原来 GitHub 有两种中 Url</a>：</p><ul><li>HTTPS URL 如： <code>https://github.com/user/repo.git</code></li><li>SSH URL 如： <code>git@github.com:user/repo.git</code></li></ul><p>我原先一直使用的是 https 类型的 Url，改为 ssh 类型的后，就没有再报错了。</p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p>本地有一个 master 分支，GitHub 上有一个 main 分支。将 main 分支合并到 master 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull //将 main 分支拉到本地。或者用 git fetch</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a //查看所有分支</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch //查看当前分支。</span></span><br><span class="line"></span><br><span class="line">//若当前分支不是 master，则切换成 master：</span><br><span class="line"><span class="meta">$</span><span class="bash"> git chechout master</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/main //合并分支</span></span><br><span class="line"></span><br><span class="line">//若提示 fatal: refusing to merge unrelated histories。请加上 --allow-unrelated-histories</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/main --allow-unrelated-histories</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push //将更改推送至GitHub</span></span><br><span class="line"></span><br><span class="line">//检查更新无误后，删除 main 分支。</span><br><span class="line">//git branch -d origin/main 会报：error: branch &#x27;origin/main&#x27; not found. 因为它是</span><br><span class="line">//删除本地分支的语句</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete main //或者简化的语句 git push origin :main</span></span><br><span class="line">//若报错：! [remote rejected] main (refusing to delete the current branch: refs/heads/main)</span><br><span class="line">//GitHub页面 -&gt; Settings -&gt; Branchs -&gt; 将默认分区从 main 切换成 master。重新尝试命令。</span><br></pre></td></tr></table></figure><p>另外：<a href="https://www.cnblogs.com/runnerjack/p/9342362.html">git pull = git fetch + git merge</a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C# 中的托管与非托管（堆、资源、类型、代码）</title>
      <link href="/blogs/15902c4f.html"/>
      <url>/blogs/15902c4f.html</url>
      
        <content type="html"><![CDATA[<h3 id="托管堆（Managed-Heap）"><a href="#托管堆（Managed-Heap）" class="headerlink" title="托管堆（Managed Heap）"></a>托管堆（Managed Heap）</h3><p>一个进程中，每个线程都有自己的栈（线程堆栈 Thread Stack)，而堆<sup><a href="#1">[1]</a></sup>（Heap）是整个进程共享的。进程初始化时，CLR 划出了一个地址空间区域作为托管堆。要求所有的引用类型的对象从托管堆中分配，并由 GC (垃圾回收器 Garbage Collection) 管理。</p><p><a id="1">[1]</a> <a href="https://stackoverflow.com/a/11199154/8910566">不止有托管堆，还有好多其他类型堆。</a></p><div class="note info simple"><p>当引用类型的对象中包含值类型的成员时，这个值类型的数据也是分配在托管堆中的。即：引用类型的对象的数据（无论是值类型还是引用类型）都被打包存在托管堆中，线程堆栈中只保留一个引用。</p></div><h3 id="非托管类型（Unmanaged-Type）"><a href="#非托管类型（Unmanaged-Type）" class="headerlink" title="非托管类型（Unmanaged Type）"></a>非托管类型（Unmanaged Type）</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/unmanaged-types">非托管类型</a>：非指针，不可为 null。不包含指向托管堆中的引用<sup><a href="#2">[2]</a></sup>，不归 GC 管的类型。</p><p>包含：</p><ul><li>sbyte、byte、short、ushort、int、uint、long、ulong、char、float、double、decimal 或 bool</li><li>任何枚举类型</li><li>任何<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/unsafe-code#pointer-types">指针类型</a></li><li>只包含非托管类型的字段的非泛型结构</li><li>从 C# 8.0 开始，指定的类型也是非托管类型的泛型结构也算。</li></ul><p><a id="2">[2]</a> 注意和值类型的区别，一个包含引用类型字段的结构内部是会有指向托管堆的指针的。</p><h3 id="非托管资源（Unmanaged-Resource）-与-托管资源-（Managed-Resource）"><a href="#非托管资源（Unmanaged-Resource）-与-托管资源-（Managed-Resource）" class="headerlink" title="非托管资源（Unmanaged Resource） 与 托管资源 （Managed Resource）"></a>非托管资源（Unmanaged Resource） 与 托管资源 （Managed Resource）</h3><h4 id="非托管资源"><a href="#非托管资源" class="headerlink" title="非托管资源"></a>非托管资源</h4><p>对于应用创建的大多数对象，可以依赖 GC 来进行内存管理。但是，如果创建包含非托管资源的对象，则当你使用完非托管资源后，必须显式释放这些资源。最常用的非托管资源类型是包装操作系统资源的对象，如文件、窗口、网络连接或数据库连接。虽然垃圾回收器可以跟踪<code>封装非托管资源的对象</code>的生命周期，但无法了解如何释放和清理这些非托管资源。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/unmanaged">Cleaning up unmanaged resources</a></p><h4 id="托管资源"><a href="#托管资源" class="headerlink" title="托管资源"></a>托管资源</h4><p>并没有在 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/">C# 文档</a> 找到托管资源的定义。托管资源应该是相对于非托管资源的。一般认为：托管资源是那些纯 .NET 代码并由运行时管理并受其直接控制的资源。</p><p>参考：<a href="https://stackoverflow.com/a/3607223/8910566">What is meant by “managed” vs “unmanaged” resources in .NET? - Oded</a></p><h3 id="托管代码（Managed-Code）-和-非托管代码（Unmanaged-Code）"><a href="#托管代码（Managed-Code）-和-非托管代码（Unmanaged-Code）" class="headerlink" title="托管代码（Managed Code） 和 非托管代码（Unmanaged Code）"></a>托管代码（Managed Code） 和 非托管代码（Unmanaged Code）</h3><h4 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h4><p>托管代码就是执行过程交由运行时管理的代码。</p><p>不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+）。在这里，相关的运行时是公共语言运行时 (CLR)。CLR 负责获取托管代码、将其编译成机器代码，然后执行它。除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。</p><h4 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h4><p>将托管代码与运行 C/C++ 程序（也称为“非托管代码”）的方式形成对比。在非托管环境中，程序员需要亲自负责处理相当多的事情。程序本质上是一个二进制文件，操作系统 (OS) 将其加载到内存中并启动。其他任何工作，从内存管理到安全因素都是程序员的负担。（我的理解是，你的程序（代码）不由运行时管理，而是直接由操作系统加载并启动。而操作系统只负责运行你的程序，其他的一概都得你自己负责。）</p><p>以上只是对非托管代码的通俗解释，对于 .NET 来说，非托管代码就是 执行过程不由 CLR 管理的代码。比如调用了不属于 .NET 共享代码库中的某个 DLL，而这里面的代码就是非托管代码。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/standard/managed-code">What is “managed code”? - microsoft</a></p><h3 id="举一个例子便于理解（System-IO-FileStream）"><a href="#举一个例子便于理解（System-IO-FileStream）" class="headerlink" title="举一个例子便于理解（System.IO.FileStream）"></a>举一个例子便于理解（System.IO.FileStream）</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=net-6.0">FileStream</a>（<code>托管类型</code>，因为它包含指向<code>托管堆</code>中的引用）对象会调用 Win32 <a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.win32.safehandles.safefilehandle?view=net-6.0#:~:text=the%20unmanaged%20CreateFile%20function">CreateFile</a> 函数（<code>非托管代码</code>，因为其执行过程不由 CLR 管理），函数返回的句柄（<a href="https://docs.microsoft.com/en-us/dotnet/api/system.intptr?view=net-6.0">IntPtr</a>  它指向<code>非托管资源</code>）保存到 SafeFileHandle 对象中，然后通过 FileStream 对象的一个私有字段来维护该对象的引用。</p><p>以下几点得注意下：</p><ol><li>不能说 FileStream 的对象是非托管资源，它只是包含非托管资源。SafeFileHandle 同理。</li><li>并不是忘记调用 Dispose()（FileStream 的 Close 也会调用 Dispose()） 非托管资源就不会得到清理了。<code>垃圾回收时，系统会自动调用析构函数，而析构函数会调用 Dispose()</code>（若之前没调用过）。但垃圾回收是滞后的，非托管资源最好用完就释放。</li><li>第 2 条只是针对内置的包含非托管资源的类，若是用户自定义的包含非托管资源的类，得自己实现 IDispose 接口，并且实现析构函数。析构函数中得判断非托管资源是否释放，若没有，则调用 Dispose()。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>.NET面试题 - C#基础知识</title>
      <link href="/blogs/67f81ba6.html"/>
      <url>/blogs/67f81ba6.html</url>
      
        <content type="html"><![CDATA[<p>.NET面试题中的一些 C# 基础知识，问题来源于网络以及我自己的总结。与其说是面试题，这更像是 C# 基础知识的部分汇总。</p><p>本文多数问题基于：<a href="https://zhuanlan.zhihu.com/p/355257871">.NET 面试题 - C#基础</a></p><h3 id="如何理解装箱和拆箱？"><a href="#如何理解装箱和拆箱？" class="headerlink" title="如何理解装箱和拆箱？"></a>如何理解装箱和拆箱？</h3><ul><li>装箱：将值类型转换成引用类型。  </li><li>拆箱：将引用类型转换成值类型。</li></ul><p>详情：<a href="https://blog.csdn.net/qiaoquan3/article/details/51439726">C#装箱和拆箱（Boxing 和 UnBoxing）</a></p><h3 id="C-中什么是值类型与引用类型？"><a href="#C-中什么是值类型与引用类型？" class="headerlink" title="C# 中什么是值类型与引用类型？"></a>C# 中什么是值类型与引用类型？</h3><ul><li>值类型：在线程栈分配空间。</li><li>引用类型：在托管堆分配空间，并在线程栈中留有引用。</li></ul><p>详情：<a href="https://www.cnblogs.com/yinrq/p/5588330.html">C# 值类型和引用类型</a></p><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><p>默认情况下所有对象都通过值传递而不是引用传递，不管是值类型还是引用类型。</p><ul><li>值传递：传递的是变量在线程栈（Thread Stack 又称线程堆栈）中的值的<code>副本</code>（即拷贝一份传入）。值类型则传递值，引用类型则传递引用。</li><li>引用传递：ref 关键字让形参（parameter）成为实参（argument）的别名（注意别名和拷贝副本的区别）。</li></ul><p>注意：</p><p>不要混淆通过引用传递与引用类型的概念。这两种概念是不同的。无论方法参数是值类型还是引用类型，均可由 ref 修改。当通过引用传递时，不会对值类型装箱。</p><p>参考：<a href="https://www.c-sharpcorner.com/UploadFile/f1047f/story-of-pass-by-value-and-pass-by-reference-in-C-Sharp/">Story Of Pass By Value And Pass By Reference In C# - C#Corner</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/ref#passing-an-argument-by-reference">ref（C# 参考）- microsoft</a></p><h3 id="关键字：ref-out-（以及-in）"><a href="#关键字：ref-out-（以及-in）" class="headerlink" title="关键字：ref out （以及 in）"></a>关键字：ref out （以及 in）</h3><h4 id="ref-与-out"><a href="#ref-与-out" class="headerlink" title="ref 与 out"></a>ref 与 out</h4><table><thead><tr><th>ref</th><th>out</th></tr></thead><tbody><tr><td>参数在传递给 ref 之前必须先初始化。</td><td>参数传递给 out 之前，不需要对其进行初始化。</td></tr><tr><td>在返回<code>被调用方法</code>之前，不需要分配或初始化参数的值。</td><td>需要在返回被调用方法之前分配或初始化参数的值。</td></tr><tr><td><code>当被调用的方法还需要修改传递参数时，可选择 ref 。</code></td><td><code>当需要从函数或方法返回多个值时，可选择 out 。</code></td></tr><tr><td>在被调用方法中使用参数值之前，不必对其进行初始化。</td><td>参数值在使用前必须在被调用方法中初始化。</td></tr><tr><td>当我们使用 ref 时，数据可以双向传递。</td><td>当我们使用 out 时，数据仅以单向方式传递（从被调用的方法到调用者的方法） <tr><td colspan=2> ref 和 out 在运行时的处理方式不同，在编译时的处理方式相同。<tr><td colspan=2> 属性不是变量，因此不能作为 ref 或 out 参数传递。</td></tr></tbody></table><h4 id="ref-out-和-方法重载"><a href="#ref-out-和-方法重载" class="headerlink" title="ref/out 和 方法重载"></a>ref/out 和 方法重载</h4><p>ref 和 out 在运行时的处理方式不同，在编译时的处理方式相同，因此如果一个方法将参数作为 ref 而另一个方法将参数作为 out，则方法不能重载。</p><p>但是，当一个方法采用 ref 或 out 参数而另一个采用相同的参数而没有 ref 或 out 时，方法重载是可能的。</p><p>参考：<a href="https://www.c-sharpcorner.com/UploadFile/ff2f08/ref-vs-out-keywords-in-C-Sharp/">ref vs out in C# - C#Corner</a></p><h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4><p>in 关键字会导致按引用传递参数，但确保不会修改参数。它让形参成为实参的别名，这必须是变量。换而言之，对形参执行的任何操作都是对实参执行的。它类似于 ref 或 out 关键字，不同之处在于 in 参数<code>无法通过调用的方法进行修改</code>。而ref 参数是可以修改的，out 参数则必须由调用的方法进行修改，这些修改在调用上下文中是可观察的。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/in-parameter-modifier">in parameter modifier (C# Reference) - microsoft</a></p><h3 id="请详述在-C-中类-class-与结构-struct-的异同。"><a href="#请详述在-C-中类-class-与结构-struct-的异同。" class="headerlink" title="请详述在 C# 中类(class)与结构(struct)的异同。"></a>请详述在 C# 中类(class)与结构(struct)的异同。</h3><p>共同点：</p><ul><li>都可以用来封装字段、属性、方法、构造器等。</li><li>都可以实现接口。</li></ul><p>区别：</p><ul><li>class：可以作为基类和继承其他类。引用类型，存储在托管堆中。</li><li>struct：可以不通过new创建实例。值类型，存储在线程栈中。是不可变（immutable)类型。</li></ul><h3 id="C-中-托管堆-和-线程堆栈-的区别？"><a href="#C-中-托管堆-和-线程堆栈-的区别？" class="headerlink" title="C#中 托管堆 和 线程堆栈 的区别？"></a>C#中 托管堆 和 线程堆栈 的区别？</h3><ul><li>托管堆（Managed Heap）：动态分配内存，可改变大小；区域无序内存，可以任何顺序存储和删除；访问速度慢；存放引用类型，通过GC（Garbage Collector）监视清理内存。</li><li>线程堆栈（Thread Stack）：静态分配内存，不能改变大小；数组有序内存，后进先出；访问速度快；存放值类型数据，离开作用域自动释放内存。</li></ul><p>参考：<a href="https://www.c-sharpcorner.com/article/stack-vs-heap-memory-c-sharp/">Stack Vs Heap Memory - C#</a></p><h3 id="托管代码-和-非托管代码"><a href="#托管代码-和-非托管代码" class="headerlink" title="托管代码 和 非托管代码"></a>托管代码 和 非托管代码</h3><h4 id="托管代码"><a href="#托管代码" class="headerlink" title="托管代码"></a>托管代码</h4><p>托管代码就是执行过程交由运行时管理的代码。</p><p>不管使用的是哪种实现（例如 Mono、.NET Framework 或 .NET Core/.NET 5+），在这里，相关的运行时是公共语言运行时 (CLR)。CLR 负责获取托管代码、将其编译成机器代码，然后执行它。除此之外，运行时还提供多个重要服务，例如自动内存管理、安全边界、类型安全，等等。</p><h4 id="非托管代码"><a href="#非托管代码" class="headerlink" title="非托管代码"></a>非托管代码</h4><p>将托管代码与运行 C/C++ 程序（也称为“非托管代码”）的方式作对比。在非托管环境中，程序员需要亲自负责处理相当多的事情。程序本质上是一个二进制文件，操作系统 (OS) 将其加载到内存中并启动。其他任何工作，从内存管理到安全因素都由程序员负担。（我的理解是，你的程序（代码）不由运行时管理，而是直接由操作系统加载并启动。而操作系统只负责运行你的程序，其他的一概都得你自己负责。）</p><p>以上只是对非托管代码的通俗解释，对于 .NET 来说，非托管代码就是 执行过程不由 CLR 管理的代码。比如调用了不属于 .NET 共享代码库中的某个 DLL，而这里面的代码就是非托管代码。</p><h3 id="托管资源-和-非托管资源"><a href="#托管资源-和-非托管资源" class="headerlink" title="托管资源 和 非托管资源"></a>托管资源 和 非托管资源</h3><ul><li>托管资源是那些纯 .NET 代码并由运行时管理并受其直接控制的资源。</li><li>其他则是非托管资源。包括文件句柄、固定存储、COM 对象、数据库连接等。</li></ul><p>详情：<a href="/blogs/15902c4f.html" title="C# 中的托管与非托管（堆、资源、类型、代码）">C# 中的托管与非托管（堆、资源、类型、代码）</a> </p><h3 id="GC（Garbage-Collection）"><a href="#GC（Garbage-Collection）" class="headerlink" title="GC（Garbage Collection）"></a>GC（Garbage Collection）</h3><p>垃圾回收器。当程序需要更多的堆空间时，由 GC 进行垃圾清理工作，暂停所有线程，找出托管堆中没有被引用的对象，进行清理，并通知栈中的指针重新指向<code>地址排序后的对象</code>。</p><p>GC 只对<code>托管资源</code>进行回收。对于<code>非托管资源</code>则不能使用 GC 进行回收，必须由程序员手动回收。</p><p>例如 FileStream 或 SqlConnection 需要调用 Dispose 进行资源的回收。</p><p>精简：</p><p>GC：垃圾回收器，用于自动回收托管堆中无效对象的内存，释放内存空间。</p><h3 id="CLR（Common-Language-Runtime）"><a href="#CLR（Common-Language-Runtime）" class="headerlink" title="CLR（Common Language Runtime）"></a>CLR（Common Language Runtime）</h3><p>Microsoft .NET Framework的虚拟机组件，管理.NET程序的执行。即时编译将托管代码（编译后的中间语言代码）转换为机器指令，然后在计算机的CPU上执行。CLR提供额外的服务，包括内存管理、类型安全、异常处理、垃圾收集、安全和线程管理。为.NET Framework编写的所有程序，无论使用何种编程语言，都由CLR执行。</p><p>参考：<a href="https://en.wikipedia.org/wiki/Common_Language_Runtime">Common Language Runtime - wiki</a></p><h3 id="简述6中可访问性级别"><a href="#简述6中可访问性级别" class="headerlink" title="简述6中可访问性级别"></a>简述6中可访问性级别</h3><ol><li>public 公有访问，不受任何限制。</li><li>private 私有访问，仅限当前类。</li><li>protected 保护访问，当前类及其子类。</li><li>internal 内部访问，当前程序集。</li><li>protected internal 当前程序集 及 其他程序集中<code>当前类</code>的子类。</li><li>private protected 子类且得是在当前程序集中。</li></ol><p>详情：<a href="/blogs/9f8c60c3.html" title="C#中的protected internal 和 private protected可访问级别">C#中的protected internal 和 private protected可访问级别</a></p><h3 id="virtual-vs-abstract"><a href="#virtual-vs-abstract" class="headerlink" title="virtual vs abstract"></a>virtual vs abstract</h3><p>共同点：</p><ul><li>都是为了实现多态。</li><li>子类重写的时候都得加override描述。</li></ul><p>区别：</p><ul><li>virtual意思是虚拟，abstract意思是抽象。</li><li>virtual只修饰方法，abstract修饰方法和类。</li><li>virtual方法必须有实现，abstract方法不能有实现。</li><li>virtual方法可以在普通类里，也可以在抽象类里，而abstract方法必须在抽象类中。（abstract class，抽象类只能被继承，不能实例化）</li><li>virtual方法可以被重写，abstract方法必须被重写。</li></ul><p>参考：<a href="https://www.cnblogs.com/woostundy/p/3424213.html">C#中virtual和abstract的区别</a></p><h3 id="C-中abstract-class和interface有什么区别"><a href="#C-中abstract-class和interface有什么区别" class="headerlink" title="C#中abstract class和interface有什么区别?"></a>C#中abstract class和interface有什么区别?</h3><p>共同点：</p><ul><li>都不能被实例化</li></ul><p>区别：</p><ul><li>abstract class可以拥有字段；interface不能。</li><li>abstract class可以对成员进行实现；interface不能。</li><li>abstract class成员可以拥有访问修饰符，成员默认私有，可以更改；interface不能拥有访问修饰符，成员默认公有，且不能修改。</li><li>abstract class可以继承类和接口；interface只能继承接口。</li><li>一个类只能继承一个抽象类，但可以继承多个接口。</li></ul><p>参考：<a href="https://www.c-sharpcorner.com/article/abstract-class-vs-interface-c-sharp/">Abstract Class Vs Interface - C#</a></p><h3 id="new关键字的几种用法"><a href="#new关键字的几种用法" class="headerlink" title="new关键字的几种用法"></a>new关键字的几种用法</h3><ul><li>运算符：创建对象和调用构造函数。</li><li>修饰符：隐藏从基类继承的成员。</li><li>约束：它指定泛型类型必须具有公共无参数构造函数。</li></ul><p>参考：<a href="https://www.c-sharpcorner.com/UploadFile/g_arora/discussing-new-keyword-of-C-Sharp/">“new” Keyword of C#</a></p><h3 id="using关键字的几种用法"><a href="#using关键字的几种用法" class="headerlink" title="using关键字的几种用法"></a>using关键字的几种用法</h3><ul><li>作为指令：用于导入其他命名空间中定义的类型或为命名空间创建别名。（引用命名空间）</li><li>作为语句：用于定义一个范围，在此范围的末尾将释放对象。（定义一个代码块）</li></ul><h3 id="重载-overload-与重写-override-的区别"><a href="#重载-overload-与重写-override-的区别" class="headerlink" title="重载(overload)与重写(override)的区别"></a>重载(overload)与重写(override)的区别</h3><table><thead><tr><th>方法重载</th><th>方法重写</th></tr></thead><tbody><tr><td>在同一个类中创建多个具有相同名称但不同签名或参数的方法称为方法重载。</td><td>在派生类中创建与基类中的方法具有相同签名的方法称为方法覆盖</td></tr><tr><td>它被称为编译时多态性</td><td>它被称为运行时多态性</td></tr><tr><td>它具有相同的方法名称，但具有不同的签名或参数</td><td>它必须具有相同的方法名称以及签名或参数。</td></tr><tr><td>方法重载不需要继承</td><td>方法覆盖需要继承</td></tr><tr><td>可以是任何访问修饰符</td><td>只能是public（特地测试了下，internal、protected 也行啊，只是重写的与被重写的得相同。）</td></tr></tbody></table><p>参考：<a href="https://www.c-sharpcorner.com/blogs/difference-between-method-overloading-and-method-overriding">Difference Between Method Overloading And Method Overriding</a></p><h3 id="new-与-override"><a href="#new-与-override" class="headerlink" title="new 与 override"></a>new 与 override</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p>在用作声明修饰符时，new 关键字可以显式隐藏从基类继承的成员。隐藏继承的成员时，该成员的派生版本将替换基类版本。（不改变执行逻辑，只是编译时不警告）</p><p>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/new-modifier">new 修饰符（C# 参考）- microsoft</a></p><h4 id="override"><a href="#override" class="headerlink" title="override"></a>override</h4><p>扩展或修改继承的方法、属性、索引器或事件的抽象或虚拟实现需要 override 修饰符。</p><p>override 方法提供从基类继承的方法的新实现。不能重写非虚方法或静态方法。重写基方法必须是 virtual、abstract 或 override 修饰的。override 方法和 virtual 方法必须具有相同级别访问修饰符。</p><p>参考；<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/override">override（C# 参考）- microsoft</a></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BaseClass bcdc = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">bcdc.Method();</span><br></pre></td></tr></table></figure><p>默认情况（未加修饰符）：执行BaseClass中的Method。<br>new：执行BaseClass中的Method。<br>override：执行DerivedClass中的Method。</p><p>另外：new 可以用来修饰字段，Override 不能。</p><p>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords">了解何时使用 Override 和 New 关键字（C# 编程指南）- microsoft</a></p><h3 id="字段（Field）和属性（Property）的关系"><a href="#字段（Field）和属性（Property）的关系" class="headerlink" title="字段（Field）和属性（Property）的关系"></a>字段（Field）和属性（Property）的关系</h3><p>字段是一个类的普通成员变量或成员实例。</p><p>属性也称为访问器，它是获取和设置字段的值的抽象。</p><p>属性是基于字段的，如果没有声明字段，编译器会自动声明字段，这属于隐式声明字段。</p><p>通常，应该将成员变量声明为私有，然后为它们声明或定义属性。</p><h3 id="属性与方法的关系"><a href="#属性与方法的关系" class="headerlink" title="属性与方法的关系"></a>属性与方法的关系</h3><p>属性是被称为<code>访问器</code>的一种特殊方法。</p><p>一般来说，方法代表行为，属性代表数据。属性旨在像字段一样使用，这意味着属性不应在计算上复杂或产生副作用。</p><p>如果不违反以下准则，请考虑使用属性而不是方法，因为经验不足的开发人员会发现属性更易于使用。</p><p>详情：<a href="https://docs.microsoft.com/en-us/previous-versions/dotnet/netframework-4.0/ms229054(v=vs.100)?redirectedfrom=MSDN">Choosing Between Properties and Methods</a></p><h3 id="类（Class）和实例（Instance）"><a href="#类（Class）和实例（Instance）" class="headerlink" title="类（Class）和实例（Instance）"></a>类（Class）和实例（Instance）</h3><p>类是<code>抽象的模板</code>，实例是根据类创建出来的一个个<code>具体的对象</code>，每个对象都拥有相同的方法，但各自的数据可能不同。</p><p>参考：<a href="https://blog.csdn.net/ym01213/article/details/86698455">python 类（Class）和实例（Instance）</a></p><h3 id="const-vs-readonly"><a href="#const-vs-readonly" class="headerlink" title="const vs readonly"></a>const vs readonly</h3><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>const 关键字用来声明某个常量字段或常量局部变量。常量字段和常量局部变量不是变量并且不能修改。常量可以为数字、布尔值、字符串或 null 引用。</p><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>在字段声明中，readonly 指示只能在声明期间或在同一个类的构造函数中向字段赋值。可以在字段声明和构造函数中多次分配和重新分配只读字段。</p><p>构造函数退出后，不能分配 readonly 字段。<code>此规则对于值类型和引用类型具有不同的含义：</code></p><p>由于值类型直接包含数据，因此属于 readonly 值类型的字段不可变。<br>由于引用类型包含对其数据的引用，因此属于 readonly 引用类型的字段必须始终引用同一对象。该对象是可变的。 readonly 修饰符可防止字段替换为其他实例，但不会阻止修改该字段中的数据。</p><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>readonly 关键字不同于 const 关键字。 const 字段只能在该字段的声明中初始化。readonly 字段可以在字段声明和任何构造函数中多次分配。因此，根据所使用的构造函数，readonly 字段可能具有不同的值。另外，const 字段是编译时常量，而 readonly 字段可用作运行时常量。const 常量既可以声明在类中也可以在函数体内，但是 readonly 常量只能声明在类中。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static">static (C# Reference) - microsoft</a><br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly">readonly (C# Reference) - microsoft</a></p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>使用 static 修饰符声明静态成员，该成员属于类型本身而不是特定对象。static 修饰符可用于声明静态类。在类、接口和结构中，您可以向字段、方法、属性、运算符、事件和构造函数添加静态修饰符。static 修饰符不能与索引器或终结器一起使用。</p><p>静态类不能被实例化，不能包含实例构造函数，无法被继承，静态类中只能有静态成员。（非静态成员需要其类的实例才能访问，故静态类只有静态成员；或者反过来说，因为静态类只有静态成员，实例化也没意义。）</p><p>使用建议：</p><p>静态类可以用作只对输入参数进行操作而不必获取或设置任何内部实例字段的方法集的方便容器。例如，在 .NET 类库中，静态 System.Math 类包含执行数学运算的方法，无需存储或检索特定于 Math 类实例的数据。</p><p>更典型的做法是声明具有一些静态成员的非静态类（而不是将整个类都声明为静态）。 静态字段的两个常见用途是保留已实例化的对象数的计数，或是存储必须在所有实例间共享的值。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/static">static (C# Reference) - microsoft</a><br><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-classes-and-static-class-members">Static Classes and Static Class Members (C# Programming Guide) - microsoft</a></p><p>注: 静态字段在内存中只有一个拷贝，非静态字段则是在每个实例对象中拥有一个拷贝。而方法无论是否为静态，在内存中只会有一份拷贝，区别只是通过类名来访问还是通过实例名来访问。</p><h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>静态构造函数用于初始化任何静态数据，或执行只需要执行一次的特定操作。在创建第一个实例或引用任何静态成员之前会被自动调用。</p><ul><li><p>静态构造函数不接受访问修饰符或参数。</p></li><li><p>一个类或结构只能有一个静态构造函数。</p></li><li><p>静态构造函数不能被继承或重载。</p></li><li><p>静态构造函数不能直接调用，只能由公共语言运行时 (CLR) 调用。它是自动调用的。</p><p>  等等。</p></li></ul><p>详情：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/static-constructors">Static Constructors - microsoft</a></p><h3 id="委托（delegate）与事件（event）"><a href="#委托（delegate）与事件（event）" class="headerlink" title="委托（delegate）与事件（event）"></a>委托（delegate）与事件（event）</h3><ul><li>委托：通常，我们将委托称为函数指针，这意味着委托对象存储方法的引用。</li><li>事件：事件是由一个对象引发的通知，用于通知其他对象发生了某些操作。</li></ul><p>事件是一种特殊的多播委托，仅可以从声明事件的类或结构（the publisher class   发布类）中对其进行调用。 如果其他类或结构订阅该事件，则在发布类引发该事件时，将调用其事件处理程序方法。</p><p>在基于事件的通信中，一个对象引发事件，另一个对象捕获并处理该事件并对其做出响应。因此处理程序方法（handler method）只不过是一种通过委托调用的方法。委托帮助我们将事件与其处理程序方法（handler method）连接起来，并帮助我们识别提供事件响应的方法。</p><p>比如：OnClick事件中的参数就是一种方法。</p><p>参考：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/event">event (C# 参考) - microsoft</a><br><a href="https://www.c-sharpcorner.com/article/how-events-and-delegates-are-releated/">    How Events And Delegates Are Related</a></p><h3 id="简述Func与Action的区别"><a href="#简述Func与Action的区别" class="headerlink" title="简述Func与Action的区别"></a>简述Func与Action的区别</h3><p>Func是有返回值的委托，Action是没有返回值的委托。</p><h3 id="finally和return的执行顺序"><a href="#finally和return的执行顺序" class="headerlink" title="finally和return的执行顺序"></a>finally和return的执行顺序</h3><ol><li>执行return语句前的代码 </li><li>计算return语句中的表达式 </li><li>finally块被执行 </li><li>返回在步骤2中得到的结果</li></ol><p>当返回值类型时，finally中给返回的变量修改值，不会影响返回值；<br>当返回值为引用类型时，返回的其实是指向该引用的指针，如果finally中更改该指针指向的数据的值，是会影响返回值的。（注意区分，更改<code>指针指向的数据的值</code>和<code>更改指针</code>的区别，更改指针不会影响返回值。）</p><p>finally中不能有return。</p><p>参考：<a href="https://stackoverflow.com/a/421827/8910566">What really happens in a try { return x; } finally { x = null; } statement? - Jon Skeet</a></p><h3 id="反射Reflection"><a href="#反射Reflection" class="headerlink" title="反射Reflection"></a>反射Reflection</h3><p>程序运行时获取程序集信息，动态创建实例。反射的命名空间位于System.Reflection</p><p>反射可用于：</p><ul><li>根据条件，动态创建实例，动态调用函数，或者是调用不同版本的程序集。</li><li>不明确程序集信息，只能运行时获取程序集信息的情况。</li><li>延迟绑定，调用第三方插件（程序发布后，允许用户写插件，然后程序自行调用的情况）。</li><li>绕开一些安全机制，比如循环引用、可访问级别。</li></ul><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>“泛型” 意味着编写的代码可以被不同类型的对象所重用。泛型的提出是为了编写重用性更好的代码。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p>引入泛型的目标：</p><ul><li>类型安全</li><li>消除强制类型转换（装箱拆箱）</li><li>潜在的性能收益</li></ul><p>当编译器对带有泛型的java代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这被称为 类型擦除（type erasure）。（ C# 同样适用，以泛型方法为例，编译器会根据你对该方法的使用情况，生成<code>多个相应类型的非泛型方法</code>。编译时的开销，不会影响程序运行速度。）</p><p>参考：<a href="http://m.php.cn/article/411947.html?tdsourcetag=s_pctim_aiomsg">深入理解什么是Java泛型？泛型怎么使用？</a></p><h3 id="什么是扩展方法"><a href="#什么是扩展方法" class="headerlink" title="什么是扩展方法"></a>什么是扩展方法</h3><ul><li>扩展方法允许扩展现有类，而无需依赖继承或更改类的源代码。</li><li>密封类也可以扩展。</li><li>必须定义在非嵌套非泛型的静态类中（<code>原文是顶级静态类</code> 查了下，貌似对顶级类的定义有争议，类名是否要等于文件名）。</li><li>第一个参数的类型是要扩展的类型，并且需要添加this关键字以标识其为扩展方法。</li><li>扩展方法不能用于覆盖现有方法，与实例方法具有相同签名的扩展方法将不会被调用。</li><li>扩展方法的概念不能应用于字段、属性或事件。</li><li><code>过度使用扩展方法不是一种好的编程风格。</code></li></ul><p>参考：<a href="https://www.c-sharpcorner.com/uploadfile/puranindia/extension-methods-in-C-Sharp-3-0/">Extension Methods in C#</a></p><h3 id="C-可否对内存直接操作"><a href="#C-可否对内存直接操作" class="headerlink" title="C#可否对内存直接操作"></a>C#可否对内存直接操作</h3><p>C#在 unsafe 模式下可以使用指针对内存进行操作，但在托管模式下不可以使用指针。</p><p>C#默认不允许操作指针，需要设置下，选择项目右键-&gt;属性-&gt;选择生成-&gt;“允许不安全代码”打勾-&gt;保存。</p><h3 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和 &amp;&amp; 的区别"></a>&amp; 和 &amp;&amp; 的区别</h3><ul><li>&amp; 是位运算，返回结果是int类型 </li><li>&amp;&amp; 是逻辑运算，返回结果是bool类型。</li></ul><p>注： C# 中 &amp;&amp; 和 || 具有短路的功能。</p><h3 id="as-和-is-的区别"><a href="#as-和-is-的区别" class="headerlink" title="as 和 is 的区别"></a>as 和 is 的区别</h3><ul><li>is: 检查表达式的运行时类型是否与给定类型兼容。</li><li>as: 将表达式显式转换为给定类型（如果其运行时类型与该类型兼容）。如果无法进行转换，则 as 运算符返回 null。与强制转换表达式 不同，as 运算符永远不会引发异常。</li><li>cast expression（强制转换表达式）：形式为 (T)E 的强制转换表达式将表达式 E 的结果显式转换为类型 T。如果不存在从类型 E 到类型 T 的显式转换，则发生编译时错误。在运行时，显式转换可能不会成功，强制转换表达式可能会引发异常。</li></ul><p>参考（详情）：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/type-testing-and-cast">Type-testing operators and cast expression (C# reference)</a></p><h3 id="什么是匿名类型，有什么好处？"><a href="#什么是匿名类型，有什么好处？" class="headerlink" title="什么是匿名类型，有什么好处？"></a>什么是匿名类型，有什么好处？</h3><p>匿名类型（Anonymous Types）提供了一种方便的方法，可以将一组<code>只读属性</code>封装到单个对象中，而无需先显式定义类型。类型名称由编译器生成，在源代码级别不可用。每个属性的类型由编译器推断。</p><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> &#123; Amount = <span class="number">108</span>, Message = <span class="string">&quot;Hello&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><p>使用方便。Linq 常用。无法修改。虽然可以当做 dynamic 类型的参数和返回值，但建议别这么用。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types">Anonymous Types - microsoft</a><br><a href="https://stackoverflow.com/questions/6624811/how-to-pass-anonymous-types-as-parameters">How to pass anonymous types as parameters?</a></p><h3 id="动态类型（dynamic）"><a href="#动态类型（dynamic）" class="headerlink" title="动态类型（dynamic）"></a>动态类型（dynamic）</h3><p>在编译时，假定动态类型的元素支持任何操作。但是，如果代码无效，会在程序运行时报错。</p><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/using-type-dynamic">Using type dynamic (C# Programming Guide)</a></p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul><li>可以使用 lambda 表达式来创建匿名函数。使用 lambda 声明运算符 <code>=&gt;</code> 将 lambda 的参数列表与其主体分开。</li><li>lambda 表达是可以指派给委托类型的变量，也可以转换为表达式树类型（Expression Trees）。</li><li>可以在任何需要<code>委托类型</code>或<code>表达式树类型</code>实例的代码中使用 lambda 表达式。如（Task.Run(Action)、Linq)</li></ul><p>参考：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/operators/lambda-expressions">Lambda expressions (C# reference)</a></p><h3 id="如何提高-NET的性能"><a href="#如何提高-NET的性能" class="headerlink" title="如何提高.NET的性能"></a>如何提高.NET的性能</h3><p>这个得具体问题具体分型，随便列举几个：</p><ul><li>优化代码（废话）。</li><li>高效管理内存。合理利用缓存，及时释放资源。</li><li>尝试使用异步。</li><li>正确处理异常。</li><li>正确选择 string 和 StringBuilder</li><li>选择正确的数据类型。避免装箱拆箱。</li><li><code>测试多种方法</code>，择最优。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> .NET面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器实用小技巧</title>
      <link href="/blogs/6b4f6d08.html"/>
      <url>/blogs/6b4f6d08.html</url>
      
        <content type="html"><![CDATA[<p>一些值得推荐的实用或有趣的 Chrome 插件、语法、工具等。</p><h3 id="text"><a href="#text" class="headerlink" title="#:~:text="></a>#:~:text=</h3><p>Url + #:~:text= + text 可定位并高亮显示text。</p><p>点击以下链接测试效果：</p><p><a href="https://www.itaru.xyz/blogs/6b4f6d08.html#:~:text=%E7%82%B9%E5%87%BB%E4%BB%A5%E4%B8%8B%E9%93%BE%E6%8E%A5%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C">https://www.itaru.xyz/blogs/6b4f6d08.html#:~:text=点击以下链接测试效果</a></p><h3 id="Programmable-Search-Engine"><a href="#Programmable-Search-Engine" class="headerlink" title="Programmable Search Engine"></a>Programmable Search Engine</h3><p><a href="https://programmablesearchengine.google.com/about/">Programmable Search Engine</a> 可以看做是 site:domain 的升级版。</p><p>添加几个网站，点击创建。<br><img src="https://ih.itaru.xyz/images/20211203220642.png" alt="20211203220642"></p><p>效果：</p><script async src="https://cse.google.com/cse.js?cx=172f19e93bd715f48"></script><div class="gcse-search"></div><p>或者也可以这么用：<a href="https://cse.google.com/cse?cx=172f19e93bd715f48">编程网址</a></p><p>如果你自己的网站能被谷歌很好的收录，也可以使用 Programmable Search Engine 创建自己的站点的搜索引擎。效果类似于本站顶部的搜索，但本站使用的是专门用于hexo的 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a>。</p><h3 id="MEMEX"><a href="#MEMEX" class="headerlink" title="MEMEX"></a>MEMEX</h3><p><a href="https://memex.garden/">WorldBrain’s Memex</a> 是一个浏览器扩展，<a href="https://github.com/WorldBrain/Memex#:~:text=full-text%20search%20your%20browsing%20history%20&%20bookmarks">可以全文检索你的浏览历史记录和书签</a>。</p><p>Chrome书签管理器中的搜索框只能根据书签的标题进行检索，而这个Google插件可以对书签进行全文检索。</p><p>效果：</p><p><img src="https://ih.itaru.xyz/images/20211203222740.png" alt="20211203222740"></p>]]></content>
      
      
      <categories>
          
          <category> Tips </category>
          
          <category> Chrome </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tips </tag>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#中的protected internal 和 private protected可访问级别</title>
      <link href="/blogs/9f8c60c3.html"/>
      <url>/blogs/9f8c60c3.html</url>
      
        <content type="html"><![CDATA[<p>C# 可访问级别 <code>protected internal</code> 的排疑，以及对 C# 7.2 版本后新增的可访问级别 <code>private protected</code> 的理解。</p><h3 id="protected-internal"><a href="#protected-internal" class="headerlink" title="protected internal"></a>protected internal</h3><p><a href="https://stackoverflow.com/questions/585859/what-is-the-difference-between-protected-and-protected-internal/64951530#64951530#:~:text=Everyone%20inside%20the%20city%20(internal)%20and%20everyone%20outside%20of%20city%20that%20their%20parents%20live%20here%20(protected)%20are%20allowed%20to%20visit%20the%20museum%20(protected%20internal).">What is the difference between ‘protected’ and ‘protected internal’ - Hassan Monjezi</a><br>这个答案有一句描述是：</p><div class="note simple"><p>Everyone inside the city (internal) and everyone outside of city that their parents live here (protected) are allowed to visit the museum (protected internal).</p></div><p>我对这句话的理解是，该程序集中的所有类 以及 该程序集中<code>任一</code>类的派生类 可访问。（不懂是不是我的蹩脚英语理解错了他的意思。）而我记得应该是<code>该成员所在类</code>的派生类。</p><p>而这个官方文档中的 <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal#:~:text=containing%20class">containing class</a>也不懂什么意思。（谷歌翻译是 包含类）。</p><p>平时压根就没用过protected internal这个访问修饰符，还真不确定哪个是对的。于是自己测试了下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassLibrary1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">internal</span> <span class="built_in">int</span> myValue = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestAccess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassLibrary2</span></span><br><span class="line"><span class="comment">// 引用ClassLibrary1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">        derivedObject.myValue = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass2</span> : <span class="title">TestAccess</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">        derivedObject.myValue = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能提示的结果：<br><img src="https://ih.itaru.xyz/images/20211130213600.png" alt="20211130213600"></p><p>于是乎我突然发现这个答案是0赞的。。并且高赞答案 <a href="https://stackoverflow.com/questions/585859/what-is-the-difference-between-protected-and-protected-internal/585869#585869#:~:text=Access%20from%20another%20assembly%20must%20take%20place%20within%20a%20class%20declaration%20that%20derives%20from%20the%20class%20in%20which%20the%20protected%20internal%20element%20is%20declared,%20and%20it%20must%20take%20place%20through%20an%20instance%20of%20the%20derived%20class%20type.">What is the difference between ‘protected’ and ‘protected internal’ - M4N</a> 的描述是：</p><div class="note simple"><p>Access from another assembly must take place within a class declaration that derives from the class in which the protected internal element is declared, and it must take place through an instance of the derived class type.</p></div><p>其实早就注意到这个答案，只是一开始没有理解是什么意思，测试后算是理解了：</p><p>在别的程序集中，<code>不能通过父类的实例访问。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">baseObject.myValue = <span class="number">5</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p><code>得通过该派生类本身的实例访问。</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">derivedObject.myValue = <span class="number">10</span>;<span class="comment">//不报错</span></span><br></pre></td></tr></table></figure><p>另外：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/protected-internal#:~:text=containing%20class">containing class</a> 可以理解为容器类。</p><h3 id="private-protected"><a href="#private-protected" class="headerlink" title="private protected"></a>private protected</h3><p><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/private-protected#:~:text=A%20private%20protected%20member%20is%20accessible%20by%20types%20derived%20from%20the%20containing%20class,%20but%20only%20within%20its%20containing%20assembly.">官方文档</a>中的描述是：</p><div class="note simple"><p>A private protected member is accessible by types derived from the containing class, but only within its containing assembly.</p></div><p>即 <code>不仅得是该成员所在类的派生类，还的是在同一程序集中。</code></p><p>将上文中的 protected internal 改为 private protected。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BaseClass</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">//protected internal int myValue = 0;</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">protected</span> <span class="built_in">int</span> myValue = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>并在 ClassLibrary1 再添加一个派生类</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">BaseClass</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Access</span>(<span class="params"></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">          <span class="keyword">var</span> derivedObject = <span class="keyword">new</span> DerivedClass();</span><br><span class="line">          derivedObject.myValue = <span class="number">10</span>;</span><br><span class="line">          <span class="keyword">var</span> baseObject = <span class="keyword">new</span> BaseClass();</span><br><span class="line">          baseObject.myValue = <span class="number">5</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>智能提示的结果：<br><img src="https://ih.itaru.xyz/images/20211130214037.png" alt="20211130214037"><br><img src="https://ih.itaru.xyz/images/20211130213621.png" alt="20211130213621"></p><p>只有一处有权限。显然这个也有和protected internal一样的限制：<code>不能通过父类的实例访问，得通过自己（派生类）的实例访问。</code></p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图片上传到博客后被自动拉伸的原因</title>
      <link href="/blogs/eda0a079.html"/>
      <url>/blogs/eda0a079.html</url>
      
        <content type="html"><![CDATA[<p>写上一篇文章的时候遇到一个问题，图片上传到博客后长宽都被自动拉伸到了原先的1.5倍。</p><div class="note info simple"><p>只有部分人的电脑会出现这个问题，这和电脑的设置有关。</p></div><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用微信截图工具截一个 300 x 200 的图片。<br>上传到博客后，这图占据的大小成了 450 x 300，但其实图片的像素还是 300 x 200。</p><img src="https://ih.itaru.xyz/images/小电视.png" align='left' /><p><img src="https://ih.itaru.xyz/images/1636119728(1).png" alt="1636119728(1)"><br><b>另外：</b><br>不仅是自己的博客，其他网页也会出现图片占用大小比实际像素多的情况。<br>将图片放入OneNote中，图片也会被放大。<br>用ImageClass或电脑自带的画图软件打开图片，图片则没有被放大。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p><code>显示-&gt;缩放与布局-&gt;更改文本、应用等项目的大小 默认设置为了150%。</code><br><img src="https://ih.itaru.xyz/images/20211105214515.png" alt="20211105214515"><br><b>推荐值和屏幕的大小以及分辨率有关，设置成自己感觉最舒服的值即可，这个值往往就是推荐值。所以这个没必要改，只是知道原因就行。图片也没必要做处理，毕竟每个人的设置可能不一样。</b></p><h3 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h3><p><a href="https://www.itechtics.com/resolution-scaling-layout/">How To Optimize resolution, scaling, and layout in Windows 10</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> 美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打开英雄联盟客户端后耳机没声音的解决方案</title>
      <link href="/blogs/a6dbf255.html"/>
      <url>/blogs/a6dbf255.html</url>
      
        <content type="html"><![CDATA[<p>自从9月份开启无线活力以来，我已经不懂几次下了删，删了下英雄联盟了。每次都想着每天玩个几局就行，可毫无例外，每次都上头，一玩就是没个停。然后就是后悔，决定卸载游戏，可没过几天又下载。想起了我大学时的有个舍友，他也是这样英雄联盟下载卸载反反复复。</p><p>这回下载完，打开英雄联盟客户端，发现耳机没声音了，并且按耳机的按键会有 咚咚咚 的响声。顺带一提，我用的是索尼wi-1000xm2无线蓝牙耳机，电脑系统是win10。</p><h3 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h3><p>以前当播放设备从 Stereo 切换成 Hands-Free 时，点击耳机按键也会有 咚咚咚 的声音。只是这种情况时耳机不会没有声音，反而声音特别大。<br><img src="https://ih.itaru.xyz/images/20211102210157.png" alt="20211102210157"><br>这回不是这个原因，其实一开始并不知道是英雄联盟客户端的原因。我只是在尝试各种方法，比如蓝牙重新配对；删了蓝牙驱动后重启<code>（重启电脑时，系统会自动检查缺少的驱动并重新安装）</code> 等等。以为解决了，开启英雄联盟客户端又出现同样的问题，才确定是和英雄联盟客户端有关。后来查了下，和猜测的差不多，是麦克风的问题。</p><p><code>由于我把电脑自带的麦克风禁用了，客户端自动使用耳机的麦克风，于是出现了这个问题。</code><br><img src="https://ih.itaru.xyz/images/20211102212125.png" alt="20211102212125"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>有三种方式解决这个问题。</p><h4 id="方法一：客户端中点击测试麦克风"><a href="#方法一：客户端中点击测试麦克风" class="headerlink" title="方法一：客户端中点击测试麦克风"></a>方法一：客户端中点击测试麦克风</h4><p>这个方法每次打开客户端都得重新再来一遍。<br><img src="https://ih.itaru.xyz/images/20211102212216.png" alt="20211102212216"></p><h4 id="方法二：客户端语音设置中的输入设备选择电脑自带的麦克风"><a href="#方法二：客户端语音设置中的输入设备选择电脑自带的麦克风" class="headerlink" title="方法二：客户端语音设置中的输入设备选择电脑自带的麦克风"></a>方法二：客户端语音设置中的输入设备选择电脑自带的麦克风</h4><p>如果电脑自带麦克风被禁用了，得开启。<br><img src="https://ih.itaru.xyz/images/20211102212740.png" alt="20211102212740"></p><h4 id="方法三：电脑设置中关闭允许应用访问你的麦克风"><a href="#方法三：电脑设置中关闭允许应用访问你的麦克风" class="headerlink" title="方法三：电脑设置中关闭允许应用访问你的麦克风"></a>方法三：电脑设置中关闭允许应用访问你的麦克风</h4><p>设置-&gt;隐私-&gt;麦克风<br><img src="https://ih.itaru.xyz/images/20211102213049.png" alt="20211102213049"></p><p><b>在客户端中禁用语音的方法没试过，游戏已卸载，没法试了。</b></p>]]></content>
      
      
      <categories>
          
          <category> 问题排除 </category>
          
          <category> 耳机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题排除 </tag>
            
            <tag> 耳机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在日亚购买 kindle 电子书</title>
      <link href="/blogs/35c8c95f.html"/>
      <url>/blogs/35c8c95f.html</url>
      
        <content type="html"><![CDATA[<p>由于对版权保护的重视，日文原版书在互联网上特别难找。淘宝上的kindle日亚代购收费也是贵得离谱，我只问了一家晒出来的价格还行的店铺，一本折合人民币27的书，收我50。这亏怎么能吃？一次还好，多次就受不了了。</p><p>说来日亚购买电子书也就几步</p><ul><li>连接日本代理</li><li>注册日亚账号</li><li>填写支付信息</li><li>购买电子书</li></ul><p>详细步骤看这边，<a href="https://www.bilibili.com/read/cv2029800/">如何使用日亚购买电子版杂志</a>。只是有几点需要注意下：</p><h3 id="支付信息"><a href="#支付信息" class="headerlink" title="支付信息"></a>支付信息</h3><h4 id="信用卡"><a href="#信用卡" class="headerlink" title="信用卡"></a>信用卡</h4><p>信用卡支付是日亚支付最通用的方法，以下几种信用卡都行。<br><img src="https://ih.itaru.xyz/images/20211028213001.png" alt="20211028213001"></p><h4 id="中国银行长城跨境通国际借记卡"><a href="#中国银行长城跨境通国际借记卡" class="headerlink" title="中国银行长城跨境通国际借记卡"></a>中国银行长城跨境通国际借记卡</h4><p><code>长城跨境通国际借记卡</code>如其名，是一种借记卡，申请这种卡<a href="https://www.boc.cn/Bcservice/bc2/201704/t20170426_9329829.html#:~:text=%E5%8F%AA%E9%9C%80%E5%87%AD%E6%9C%AC%E4%BA%BA%E6%9C%89%E6%95%88%E8%BA%AB%E4%BB%BD%E8%AF%81%E4%BB%B6">没有申请信用卡的条条框框</a>，适合由于各种原因无法或者不想申请信用卡的同学。我用的就是这种卡，直接去营业厅办理，当场就能领到卡。要注意的是，并不是所有中国银行的营业厅都能办理这种卡，往往城市分行和大学里的支行会有，去之前可以打电话询问下。另外，这卡得绑定一张中国银行的一类卡，如果没有，得一起办理。</p><h4 id="虚拟信用卡"><a href="#虚拟信用卡" class="headerlink" title="虚拟信用卡"></a>虚拟信用卡</h4><p>申请虚拟信用卡的难度会比正常信号用卡低，国内不知道还能不能申请，查了几个银行都没有，<a href="https://zhidao.baidu.com/question/495042755475833292.html">中国银行</a>，<a href="https://zhidao.baidu.com/question/1499884976872396419.html">招商银行</a>。国外的，比如<a href="https://zhuanlan.zhihu.com/p/129760347">Easypay</a>，看评论，各种坑。</p><h4 id="淘宝购买礼品卡"><a href="#淘宝购买礼品卡" class="headerlink" title="淘宝购买礼品卡"></a>淘宝购买礼品卡</h4><p>没有信用卡的同学多数是使用礼品卡支付的吧，但淘宝购买礼品卡存在一定风险。由于经常出现信用卡盗刷的情况，亚马逊对这块管得很严，如果遇到不良淘宝商家，日亚账号可能会被封，钱也不一定能退回来。</p><h3 id="日本代理"><a href="#日本代理" class="headerlink" title="日本代理"></a>日本代理</h3><p>据说代理的<code>伪装度（匿名性）</code>不够也是有被封号的风险的。</p><p>我使用的伪装度检测网站是<a href="https://whoer.net/">whoer</a>，测试了以下两种方法：</p><h4 id="V2ray打开全局代理"><a href="#V2ray打开全局代理" class="headerlink" title="V2ray打开全局代理"></a>V2ray打开全局代理</h4><p><img src="https://ih.itaru.xyz/images/20211029125013.png" alt="20211029125013"><br>将电脑时区改为东京后<br><img src="https://ih.itaru.xyz/images/20211029125043.png" alt="20211029125043"><br>语言没有尝试修改了</p><h4 id="使用AnyConnect-VPN"><a href="#使用AnyConnect-VPN" class="headerlink" title="使用AnyConnect VPN"></a>使用AnyConnect VPN</h4><p>扣了25分，总分为何是90？<br><img src="https://ih.itaru.xyz/images/20211029125459.png" alt="20211029125459"><br>将电脑时区改为东京后，总分100了。<br><img src="https://ih.itaru.xyz/images/20211029125646.png" alt="20211029125646"><br><b>vpn的伪装度比代理高，感觉挺合理的。</b></p><h3 id="将电子书传输到kindle"><a href="#将电子书传输到kindle" class="headerlink" title="将电子书传输到kindle"></a>将电子书传输到kindle</h3><p>电脑上购买好电子书后<code>（第一次购买可以用0元的书做下测试）</code>，kindle切换到日亚账号。如果电子书没有自动下载到kindle，可以将电子书下载到电脑，使用数据线传输到kindle。</p><div class="note warning simple"><p>切换和退出账号，kindle会自动清空所有已下载的电子书。</p></div><p><img src="https://ih.itaru.xyz/images/20211029192901.png" alt="20211029192901"><br><img src="https://ih.itaru.xyz/images/20211029193024.png" alt="20211029193024"></p><h3 id="直接使用kindle购买日亚电子书"><a href="#直接使用kindle购买日亚电子书" class="headerlink" title="直接使用kindle购买日亚电子书"></a>直接使用kindle购买日亚电子书</h3><p>kindle连上日本代理，商城才会是日本区的。可以尝试用以下几种方式让kindle连上代理：</p><ul><li>路由器设置代理</li><li>电脑的热点功能</li><li>手机下载可以分享代理的软件</li></ul><p>路由器得有设置代理的功能才行，或者可以尝试刷机。</p><p>电脑的热点功能，我试了v2ray全局代理+热点，kindle并没有连接代理；而连anyconnect后，电脑就开不了热点了。</p><p>手机可以去Google Play商店去下载一款叫<code>VPN 热点</code>的app，这个我试过，可以让其他设备也连上代理，但需要root权限。我现在手机没有root功能，所以就没有尝试使用kindle连接了。</p><p>其实我没有成功的直接使用kindle购买日亚电子书，毕竟可以用电脑购买，没有下功夫解决这个需求的动力。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
          <category> kindle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kindle </tag>
            
            <tag> 日亚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置评论插件 Valine 的邮件提醒和后台管理系统 Valine Admin</title>
      <link href="/blogs/bfcce7e4.html"/>
      <url>/blogs/bfcce7e4.html</url>
      
        <content type="html"><![CDATA[<p>配置Valine Admin首先得配置好valine，我使用的是butterfly主题，所以用<a href="https://butterfly.js.org/posts/ceeb73f/#%E8%A9%95%E8%AB%96">主题配置文档</a>中的配置方法。方法是<a href="https://valine.js.org/quickstart.html">先注册个leancloud账号<code>（如果域名未备案，请使用国际版）</code>，创建应用，将APP ID和APP Key添加到</a>主题的_config.yml配置文件中即可。不同的主题，配置方式也会有些不同。<br><img src="https://ih.itaru.xyz/images/20211025114940.png" alt="20211025114940"><br><img src="https://ih.itaru.xyz/images/20211025145225.png" alt="20211025145225"><br>leancloud自带的后台管理功能不是很友好，是以数据库中表的形式一样展示的。<br><img src="https://ih.itaru.xyz/images/20211025145528.png" alt="20211025145528"><br>所以需要再架设个管理系统。Valine Admin是个带有邮件提醒功能的Valine后台管理系统。<br><img src="https://ih.itaru.xyz/images/20211025160109.png" alt="20211025160109"></p><h3 id="配置Valine-Admin"><a href="#配置Valine-Admin" class="headerlink" title="配置Valine Admin"></a>配置Valine Admin</h3><p><a href="https://github.com/DesertsP/Valine-Admin">Valine Admin说明文档</a>中有详细的配置说明，但对于我这个才接触leancloud的小白来说，还是看得一头雾水，踩了不少坑，所以打算写下来。<br><code>云引擎-&gt;WEB-&gt;设置</code>，以下几个参数得注意下<br><img src="https://ih.itaru.xyz/images/20211025150715.png" alt="20211025150715"></p><h4 id="SITE-URL"><a href="#SITE-URL" class="headerlink" title="SITE_URL"></a>SITE_URL</h4><p>后面别加<code>/</code>，比如我这网站填<code>https://www.itaru.xyz</code>，而不是<code>https://www.itaru.xyz/</code>，这个url是用来和下图字段拼接生成评论所在的具体url的。<br><img src="https://ih.itaru.xyz/images/20211025151308.png" alt="20211025151308"></p><h4 id="SMTP-PASS"><a href="#SMTP-PASS" class="headerlink" title="SMTP_PASS"></a>SMTP_PASS</h4><p>如果是用的qq邮箱，填的是开启POP3/SMTP服务之后提供的授权码，而不是独立密码。<br><img src="https://ih.itaru.xyz/images/20211027170624.png" alt="20211027170624"><br>说明中有一句<code>QQ邮箱需要获取独立密码</code>，我以为是填独立密码。于是报了<code>Error: Invalid login: 535 Login Fail. Please enter your authorization code to login</code>错误。文档的意思也许是，你需要开启独立密码登录功能，但这边使用SMTP登录密码登录邮箱。。</p><h4 id="ADMIN-URL"><a href="#ADMIN-URL" class="headerlink" title="ADMIN_URL"></a>ADMIN_URL</h4><p>这个是后台管理页面的url，需要先在<code>设置-&gt;域名绑定</code>中绑定域名。域名可以是<code>xxx.YourDomain</code>的形式。<br><img src="https://ih.itaru.xyz/images/20211025160333.png" alt="20211025160333"><br>第一次绑定时，会提示你配置DNS，即配置CNAME<br><img src="https://ih.itaru.xyz/images/20211025160912.png" alt="20211025160912"><br>如果是非国际版的leancloud，则会检查域名是否备案。所以开头提前说明，域名没有备案，得用国际版。<br><img src="https://ih.itaru.xyz/images/20211025161129.png" alt="20211025161129"></p><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>设置完参数后<code>部署</code><br><img src="https://ih.itaru.xyz/images/20211025162407.png" alt="20211025162407"><br>部署成功后，域名加上/sign-up注册用户后，<code>我这是 https://leancloud.itaru.xyz/sign-up</code>，即可登录后台管理系统查看评论。<br><img src="https://ih.itaru.xyz/images/20211025161615.png" alt="20211025161615"><br><img src="https://ih.itaru.xyz/images/20211025221523.png" alt="20211025221523"><br>另外：体验实例有<a href="https://leancloud.cn/docs/leanengine_plan.html#:~:text=%E4%BD%93%E9%AA%8C%E5%AE%9E%E4%BE%8B%E5%9C%A8%E8%BF%9B%E8%A1%8C%E9%83%A8%E7%BD%B2%E7%AD%89%E7%AE%A1%E7%90%86%E6%93%8D%E4%BD%9C%E6%97%B6%E4%BC%9A%E6%9A%82%E5%81%9C%E6%9C%8D%E5%8A%A1%E3%80%82%20%E5%90%8C%E6%97%B6%20%E4%BD%93%E9%AA%8C%E5%AE%9E%E4%BE%8B%E4%BC%9A%E6%89%A7%E8%A1%8C%E4%BC%91%E7%9C%A0%E7%AD%96%E7%95%A5%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%AF%B7%E6%B1%82%E6%97%B6%E4%BC%9A%E4%BC%91%E7%9C%A0%EF%BC%8C%E6%9C%89%E8%AF%B7%E6%B1%82%E6%97%B6%E5%90%AF%E5%8A%A8%EF%BC%88%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E5%8D%81%E5%87%A0%E7%A7%92%E7%9A%84%E6%97%B6%E9%97%B4%EF%BC%89%EF%BC%8C%E6%AF%8F%E5%A4%A9%E6%9C%80%E5%A4%9A%E8%BF%90%E8%A1%8C%2018%20%E4%B8%AA%E5%B0%8F%E6%97%B6">休眠策略</a>，需要设置<a href="https://github.com/DesertsP/Valine-Admin#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%AE%BE%E7%BD%AE">定时任务</a>。</p><div class="note info simple"><p>参数配置错误，修改参数后重新部署才会生效。未收到邮件，可查看日志看是否有报错信息。</p></div> ]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> Valine </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Valine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用gulp和jsdelivr加快GitHub中搭建的hexo博客的访问速度</title>
      <link href="/blogs/1839fcb6.html"/>
      <url>/blogs/1839fcb6.html</url>
      
        <content type="html"><![CDATA[<p>如果域名已经备案，加快github搭建的hexo博客的访问速度的最好的方法是使用国内厂商提供的CDN。本博客使用的域名目前没有备案，所以用别的方式加速网站的访问。</p><h3 id="使用gulp压缩HTML、JS、CSS文件和图片"><a href="#使用gulp压缩HTML、JS、CSS文件和图片" class="headerlink" title="使用gulp压缩HTML、JS、CSS文件和图片"></a>使用gulp压缩HTML、JS、CSS文件和图片</h3><p>不喜欢重复造轮子，直接贴出我认为写得比较好的文章 <a href="https://blog.imzjw.cn/posts/b74f504f/#:~:text=gulp%20%E5%8E%8B%E7%BC%A9">gulp 压缩</a>。</p><p>以 css\index.css 查看其效果。</p><p>压缩前：<br><img src="https://ih.itaru.xyz/images/20211022145941.png" alt="20211022145941"><br>压缩后:<br><img src="https://ih.itaru.xyz/images/20211022150029.png" alt="20211022150029"></p><p>主页访问速度</p><div class="note simple"><p>即使有勾选清空缓存，每次刷新网页访问速度都会有差别，有时差别还特别大。这边截取的是我认为比较有代表性的两张图。总的来说，访问速度有提高，压缩率越高，访问速度提高得也越多。</p></div><p>压缩前：<br><img src="https://ih.itaru.xyz/images/20211022151514.png" alt="20211022151514"><br>压缩后：<br><img src="https://ih.itaru.xyz/images/20211022151529.png" alt="20211022151529"></p><h3 id="使用jsdelivr提供的免费CDN加速JS、CSS文件和图片"><a href="#使用jsdelivr提供的免费CDN加速JS、CSS文件和图片" class="headerlink" title="使用jsdelivr提供的免费CDN加速JS、CSS文件和图片"></a>使用jsdelivr提供的免费CDN加速JS、CSS文件和图片</h3><div class="note warning flat"><p>2021年12月下旬，<a href="https://hin.cool/posts/jsddown.html">jsdelivr 在中国大陆访问受限</a>，之后中国大陆的请求转为访问就近的节点（比如 香港）。访问算是恢复了，但访问速度大不如前。如果要使用 jsdelivr，最好先查下该问题是否修复。</p></div><a href="/blogs/e7630f6f.html" title="GitHub图床无法访问的解决方案">GitHub图床无法访问的解决方案</a>的方案二有提到使用jsdelivr加速图床，其实jsdelivr还可以用来加速博客中的文件。<p>在主题的_config.yml的配置文件中的JS、CSS文件和图片的相对路径前添加</p><pre>https://cdn.jsdelivr.net/gh/YourGithubName/blogRepoName</pre><p>包括但不限于以下几项：<br><img src="https://ih.itaru.xyz/images/20211022152107.png" alt="20211022152107"><br><img src="https://ih.itaru.xyz/images/20211022152124.png" alt="20211022152124"><br>这个方法加速还是挺明显的<br><img src="https://ih.itaru.xyz/images/20211022152348.png" alt="20211022152348"></p><div class="note warning simple"><p>这个方法会导致本地调试时也访问github中的相应文件。相应文件在本地有改动时，本地调试使用的还是github上的版本。</p></div><p>后来又发现了个问题，jsdelivr会在第一次访问某url时去获取github中相应的文件，然后缓存起来，之后访问会使用缓存的文件。也就是说，<a href="https://github.com/BNDong/Cnblogs-Theme-SimpleMemory/issues/42">更新的文件不会立即生效</a>，官方文档中说大概<a href="https://github.com/jsdelivr/jsdelivr#:~:text=Branches%20-%2012%20hours">12小时更新一次缓存</a>。<code>如果想要即时生效，得更改文件的名字，如将index.css改为index1.1.css，_config.yml中设置的url也得一并改。</code></p><p><a href="https://zhuanlan.zhihu.com/p/336641644#:~:text=%E6%9B%B4%E6%96%B0%E4%B8%80%E6%AC%A1%E5%B0%B1%E6%9B%B4%E6%96%B0%E4%B8%80%E4%B8%8B%E7%89%88%E6%9C%AC">这里还有个常用的方法</a>，这个方法每次更新或新增都得release新版本。更改其中一个css文件就得release这一点，感觉会比上述方法麻烦。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub图床无法访问的解决方案</title>
      <link href="/blogs/e7630f6f.html"/>
      <url>/blogs/e7630f6f.html</url>
      
        <content type="html"><![CDATA[<p>我是参考 <a href="https://blog.csdn.net/qq_43827595/article/details/104274769">10分钟配置 VScode插件picgo + github免费图床，实现Markdown写作高效插图</a> 这篇文章搭建图床的。教程写的很清楚，搭建得顺利。但picgo插件提供的默认域名 <code>raw<span>.</span>githubusercontent<span>.</span>com</code> 被墙了，大陆无法加载图片。于是寻找解决方法。</p><div class="note info simple"><p>方法一算是我踩得一个坑，但也挺有借鉴意义的。方法二才是真正简便高效的解决方案。直接看<a href="#%E6%96%B9%E6%B3%95%E4%BA%8C-%E4%BD%BF%E7%94%A8jsdelivr">方法二</a>也无妨。</p></div><h3 id="方法一-给图床添加自定义域名"><a href="#方法一-给图床添加自定义域名" class="headerlink" title="方法一 给图床添加自定义域名"></a>方法一 给图床添加自定义域名</h3><h4 id="给图床repo添加CNAME和index-html-两个文件夹"><a href="#给图床repo添加CNAME和index-html-两个文件夹" class="headerlink" title="给图床repo添加CNAME和index.html 两个文件夹"></a>给图床repo添加CNAME和index.html 两个文件夹</h4><p><img src="https://ih.itaru.xyz/images/1634526849(1).png" alt="1634526849(1)"><br>CNAME中添加自定义域名，indxe.html可以为空也可以是任意内容。<br><img src="https://ih.itaru.xyz/images/20211018111942.png" alt="20211018111942"></p><h4 id="DNS域名解析添加CNAME"><a href="#DNS域名解析添加CNAME" class="headerlink" title="DNS域名解析添加CNAME"></a>DNS域名解析添加CNAME</h4><p><img src="https://ih.itaru.xyz/images/20211018112439.png" alt="20211018112439"><br>不添加这个，域名会ping不通。<br><img src="https://ih.itaru.xyz/images/20211019163405.png" alt="20211019163405"><br>少了这一步直接配置网站的话，github中也会提示出错。<br><img src="https://ih.itaru.xyz/images/20211019162717.png" alt="20211019162717"><br>等待3、4分钟，直到域名能ping通。<br><img src="https://ih.itaru.xyz/images/20211019163510.png" alt="20211019163510"></p><h4 id="repo设置网站"><a href="#repo设置网站" class="headerlink" title="repo设置网站"></a>repo设置网站</h4><p><img src="https://ih.itaru.xyz/images/1634527597(1).png" alt="1634527597(1)"><br>配置完成后，等待几秒github布置网站。打开网站看是否生效，<code>我这是 <a href="https://ih.itaru.xyz/">https://ih.itaru.xyz/</a></code>。</p><h4 id="将vscode中picgo插件设置github的Customer-Url改为自己的域名"><a href="#将vscode中picgo插件设置github的Customer-Url改为自己的域名" class="headerlink" title="将vscode中picgo插件设置github的Customer Url改为自己的域名"></a>将vscode中picgo插件设置github的Customer Url改为自己的域名</h4><p><img src="https://ih.itaru.xyz/images/20211018113429.png" alt="20211018113429"></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>这样一来，图床可以以原先就行的<code><a href="https://raw.githubusercontent.com/simpleworldz/ImageHost/master/images/kyojin.png">https://raw.githubusercontent.com/simpleworldz/ImageHost/master/images/kyojin.png</a></code><br>和后来添加的<br><code><a href="https://ih.itaru.xyz/images/kyojin.png">https://ih.itaru.xyz/images/kyojin.png</a></code><br>两种形式访问。后者没有被墙。</p><p>为什么说是这方法是我踩得一个坑，因为虽然不被墙了，但github的服务器在海外，大陆加载图片特别慢，一张1M的图片需要加载10几秒。</p><p>提速可以使用CDN，这个被我放弃了，<a href="/blogs/859740d4.html" title="关于域名备案">关于域名备案</a> 这篇文章有说明原因。还有一种解决方案是再在coding中布置一个相同的博客网站，coding的服务器大陆访问比较快，用于大陆节点的访问，github中的网站用户海外节点的访问。</p><h3 id="方法二-使用jsdelivr"><a href="#方法二-使用jsdelivr" class="headerlink" title="方法二 使用jsdelivr"></a>方法二 使用jsdelivr</h3><div class="note warning flat"><p>2021年12月下旬，<a href="https://hin.cool/posts/jsddown.html">jsdelivr 在中国大陆访问受限</a>，之后中国大陆的请求转为访问就近的节点（比如 香港）。访问算是恢复了，但访问速度大不如前。如果要使用 jsdelivr，最好先查下该问题是否修复。</p></div><p>方法一结尾提到的两种改善访问速度的方法都不是很想用，想可否用更换图床插件的方式解决。于是注意到了一开始就看到，但是被我忽略的那篇文章， <a href="https://blog.csdn.net/qq_41121080/article/details/105565405">VSCode + Github + Picgo + jsDelivr 搭建稳定快速高效图床</a> 。一开始没用这篇文章的原因是开头提到的那篇文章写得比较仔细。</p><p><b>没啥要做的，就一步，将vscode中picgo插件设置github的Customer Url改为 </b></p><pre>https://cdn.jsdelivr.net/gh/YourGithubName/RepoName</pre><p><img src="https://ih.itaru.xyz/images/20211018161358.png" alt="20211018161358"></p><p>生成的url示例<br><code><a href="https://ih.itaru.xyz/images/kyojin.png">https://ih.itaru.xyz/images/kyojin.png</a></code></p><p>方法一和方法二不冲突，如果做了方法一只是让图床中的图片多了一种访问方式。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> 优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于域名备案</title>
      <link href="/blogs/859740d4.html"/>
      <url>/blogs/859740d4.html</url>
      
        <content type="html"><![CDATA[<p>本文原名“域名备案 从开始到放弃”，但最终由于 <a href="https://hin.cool/posts/jsddown.html">jsdelivr 在中国大陆访问受限</a>，以及双十二期间腾讯云给首次购买云服务器的用户提供优惠（有一年 50、75 的两种），购买了台，去做了备案。</p><p>备案过程比原以为的简单。我一开始想要在没有云服务器的情况下备案，最终没有找到方法。备案时间也比想象的短，10天左右（按工作日算的话 8 天，福建地区）。提交备案后，腾讯云客服 1、2 天内会打电话和你说明注意事项，备案信息如果有填错的地方，有些他甚至会自己帮你更改，服务特到位。</p><ul><li><a href="https://cloud.tencent.com/document/product/243/45097">备案说明文档</a></li><li><a href="https://cloud.tencent.com/document/product/243/19650">不同省份备案预计时间</a></li></ul><p>依预计时间，其实大部分省份购买一个月的云服务器就足够了。</p><hr><h2 id="域名备案-从开始到放弃"><a href="#域名备案-从开始到放弃" class="headerlink" title="域名备案 从开始到放弃"></a>域名备案 从开始到放弃</h2><p>今天（2021-10-16）想给网站做个CDN，以提高国内的访问速度。据说github搭建的网站访问速度不是很给力。我自己的访问速度倒是还行，奈何可能其他省份，其他运营商的网访问速度欠佳呢。在腾讯云的CDN中添加域名，提示域名没有备案，于是打算去备案。</p><h3 id="开始备案"><a href="#开始备案" class="headerlink" title="开始备案"></a>开始备案</h3><p>腾讯云有自带的备案系统，录入信息时又发现备案需要云服务器，而我没有购买云服务器。那么，就去寻找别的域名备案的方法。</p><p>半个小时过去了，竟是找不到代替的备案方式。渐渐烦躁，没道理啊，备案很多人做，那么网上应该有很多教程才对。我以前也有过类似的经历，一个很多人使用的工具报错了，网上却怎么也找不到解决方案。毫无例外都是我犯了如名称、格式搞错了，或者是按着教程做，却漏了一步之类的低级错误。</p><div class="note blue no-icon simple"><p>当一个你认为是很普遍的问题，却在网上怎么也找不到解决方法时，往往是你犯了特别低级的错误，或者是前提条件就是错的。</p></div><p>该不会是<code>备案域名，必须购买一台云服务器</code>？网上说是或不是的说法都有，说是的比较多，我感觉必须要有服务器的论调比较可信。说不需要的人，你倒是给个方法啊。我半天都没搜。</p><h3 id="放弃备案"><a href="#放弃备案" class="headerlink" title="放弃备案"></a>放弃备案</h3><p><b>服务器在海外的网站，本就不用备案，基于github的博客是不用备案的。</b><code>写到这边，我发现个华点，既然需不需要备案和服务器所在地址有关，那备案看来是真的需要一台服务器。</code>备案所需时间大概需要20-30天，这期间是不能使用域名的。有人通过租用短期服务器的方法给网站备案，但这也有被回收备案的风险。还有人说一台服务器有5个备案号，可以备案5个域名，可以向已有云服务器的人要。</p><p>hexo有些插件是必须域名备案后才能使用的，并且国内的一些服务，如CDN和微信小程序衔接之类的需要备案。</p><p><b>对于我这个新生不到一周的小小个人网站，还是先把备案一事放一放吧，以后再看有没有必要。</b></p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> 域名 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站点的搭建</title>
      <link href="/blogs/2116d0e1.html"/>
      <url>/blogs/2116d0e1.html</url>
      
        <content type="html"><![CDATA[<p>查询v2ray如何配置pac时发现了这个站点：<a href="https://www.zyskys.com/">零奇部落阁</a>。好羡慕他们拥有自己的站点。正好裸辞在家，想过段时间再去找工作，有不少闲暇时间，就开始搭建自己的站点了。</p><div class="note blue no-icon simple"><p>以前公司给我钱，我为公司工作；现在没人给我钱了，我为自己做事。</p></div><h3 id="搭建方式的选择"><a href="#搭建方式的选择" class="headerlink" title="搭建方式的选择"></a>搭建方式的选择</h3><p>我以为搭建站点需要自己购买服务器，一开始的方向是在找便宜且稳定，最好是国内访问速度也还行的服务器。腾讯云和阿里云都太贵了，1M带宽的会比较便宜，但也只是活动价。并且想想1M带宽加载文字还行，加载图片那不得太慢了吧。还是决定购买国外的vps。国外的vps带宽是1G起步的，价格是5美元起步，一年将近400块，想想还是肉疼的。vultr美国个别地区的机房有2.5美元一个月的，但只限ipv6，不懂这对网站的布置会有什么限制。</p><p><b>外国服务器有被墙的风险</b>，据说vultr和搬瓦工是重灾区。为了架设ssr，大概3年前我在vultr中购买过vps，感觉这个vps提供商还不错。并且网上查到了一些可以规避被墙的办法，想想还可以顺带布置下v2ray。于是在vultr购买了一台东京的5美元一个月的服务器，直接选用自带的wordpress。</p><p><b>这台位于东京的服务器，ping值不是很高，100左右，丢包80%左右，丢包率比以前高多了。</b>访问wordpress时快时慢，有时得转好久。由于vultr是按时间计费的，对当前vps不满，完全可以换一台服务器，不产生额外费用。但最终我没这么选择，感觉wordpress庞大笨重了点，更关键的是，没找到自己喜欢的<code>主题</code>。</p><p>于是我去了解了下<code>hexo</code>。一开始我以为hexo和wordpress是差不多的，这时才发现，他们完全不一样。布置wordpress网站，你得有独立的服务器，但是hexo网站，可以通过github或者coding布置网站。省去购买vps的钱，以及维护vps的时间。并且，<code>主题也比较好看</code>。文章开头提到的那个网站，也是用hexo的搭建的。</p><p>那还有什么好犹豫的呢，直接上hexo。</p><p>对比wordpress的傻瓜试的点几下鼠标就将能一个网站的大致框架布置好。hexo还是比较复杂点的。</p><h3 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h3><p>只需要购买域名的费用，普通的第一年几块到几十不等，续费会比较贵，但也就几十到一百几。如果是靓号，那多贵的都有。如果你选择使用github提供的<code>YourGithubName.github.io</code>形式的域名的话，那么连购买域名也省了。</p><h3 id="搭建网站"><a href="#搭建网站" class="headerlink" title="搭建网站"></a>搭建网站</h3><p>其实参考<a href="https://www.nesxc.com/post/hexo.html">nesxc的hexo安装教程</a>的第一部分就行，我参考了好几篇hexo教程，这篇是写得最好最详细的。完成了第一部分，其实网站框架就搭建成功了，你可以通过<code>http:<span>//</span>YourGithubName<span>.</span>github<span>.</span>io</code>访问你的网站。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>可以参考这个，<a href="https://www.zhihu.com/question/31377141/answer/103056861">github怎么绑定自己的域名</a>。</p><h3 id="网站更换主题、添加功能以及美化"><a href="#网站更换主题、添加功能以及美化" class="headerlink" title="网站更换主题、添加功能以及美化"></a>网站更换主题、添加功能以及美化</h3><p>如果你和我一样选择的是<code>butterfly</code>可以参考官方网站<a href="https://butterfly.js.org/">butterfly</a>。每个主题都应该有自己的官方网站，照着做就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
